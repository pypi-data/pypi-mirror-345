{
  "passed": [
    "ollama_integration: runner imports",
    "voice_assistant: runner imports",
    "automation: runner imports",
    "hardware_demos: runner imports",
    "audio: runner imports",
    "input_devices: runner imports",
    "shell_cli: runner imports",
    "security: runner imports",
    "integrated_demo: runner imports",
    "tts: runner imports",
    "server: runner imports",
    "update: runner imports",
    "install: runner imports",
    "unitmcp: runner imports",
    "bridges: runner imports",
    "rpi_control: runner imports",
    "dsl: runner imports",
    "plugin: runner imports",
    "basic: runner imports",
    "raspberry_pi: runner imports",
    "llm: runner imports",
    "advanced: runner imports",
    "ai: runner imports",
    "template: runner imports"
  ],
  "failed": [
    "voice_assistant: runner imports - 'from runner.base_runner import BaseRunner' not found in '#!/usr/bin/env python3\\n\"\"\"\\nVoice Assistant Runner\\n\\nThis script sets up and runs both the client and server components\\nof the voice assistant example.\\n\"\"\"\\n\\nimport argparse\\nimport asyncio\\nimport logging\\nimport os\\nimport signal\\nimport subprocess\\nimport sys\\nimport yaml\\nfrom pathlib import Path\\nfrom typing import Dict, Any, Optional, List, Tuple\\n\\n# Add the project root to the Python path\\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\\n\\nfrom src.unitmcp.utils.env_loader import EnvLoader\\n\\n# Configure logging\\nlogging.basicConfig(\\n    level=logging.INFO,\\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\\n)\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass VoiceAssistantRunner:\\n    \"\"\"\\n    Runner for the voice assistant example.\\n    \\n    This class handles:\\n    - Loading environment variables\\n    - Starting the server process\\n    - Starting the client process\\n    - Handling signals for graceful shutdown\\n    \"\"\"\\n    \\n    def __init__(self, server_config_path: str, client_config_path: str):\\n        \"\"\"\\n        Initialize the voice assistant runner.\\n        \\n        Parameters\\n        ----------\\n        server_config_path : str\\n            Path to the server configuration file\\n        client_config_path : str\\n            Path to the client configuration file\\n        \"\"\"\\n        self.server_config_path = server_config_path\\n        self.client_config_path = client_config_path\\n        self.server_process = None\\n        self.client_process = None\\n        self.running = False\\n    \\n    def _load_config(self, config_path: str) -> Dict[str, Any]:\\n        \"\"\"\\n        Load a configuration from a YAML file.\\n        \\n        Parameters\\n        ----------\\n        config_path : str\\n            Path to the configuration file\\n            \\n        Returns\\n        -------\\n        Dict[str, Any]\\n            Configuration\\n        \"\"\"\\n        with open(config_path, \\'r\\') as f:\\n            config = yaml.safe_load(f)\\n        return config\\n    \\n    def start_server(self):\\n        \"\"\"Start the server process.\"\"\"\\n        logger.info(\"Starting server process...\")\\n        \\n        # Get the server script path\\n        server_script = os.path.join(os.path.dirname(__file__), \"server.py\")\\n        \\n        # Start the server process\\n        self.server_process = subprocess.Popen(\\n            [sys.executable, server_script],\\n            stdout=subprocess.PIPE,\\n            stderr=subprocess.PIPE,\\n            text=True,\\n            bufsize=1,\\n        )\\n        \\n        logger.info(f\"Server process started with PID {self.server_process.pid}\")\\n        \\n        # Start a thread to read server output\\n        import threading\\n        \\n        def read_server_output():\\n            for line in self.server_process.stdout:\\n                print(f\"[SERVER] {line.strip()}\")\\n        \\n        def read_server_error():\\n            for line in self.server_process.stderr:\\n                print(f\"[SERVER ERROR] {line.strip()}\")\\n        \\n        threading.Thread(target=read_server_output, daemon=True).start()\\n        threading.Thread(target=read_server_error, daemon=True).start()\\n    \\n    def start_client(self):\\n        \"\"\"Start the client process.\"\"\"\\n        logger.info(\"Starting client process...\")\\n        \\n        # Get the client script path\\n        client_script = os.path.join(os.path.dirname(__file__), \"client.py\")\\n        \\n        # Start the client process\\n        self.client_process = subprocess.Popen(\\n            [sys.executable, client_script],\\n            stdout=subprocess.PIPE,\\n            stderr=subprocess.PIPE,\\n            text=True,\\n            bufsize=1,\\n        )\\n        \\n        logger.info(f\"Client process started with PID {self.client_process.pid}\")\\n        \\n        # Start a thread to read client output\\n        import threading\\n        \\n        def read_client_output():\\n            for line in self.client_process.stdout:\\n                print(f\"[CLIENT] {line.strip()}\")\\n        \\n        def read_client_error():\\n            for line in self.client_process.stderr:\\n                print(f\"[CLIENT ERROR] {line.strip()}\")\\n        \\n        threading.Thread(target=read_client_output, daemon=True).start()\\n        threading.Thread(target=read_client_error, daemon=True).start()\\n    \\n    def stop_processes(self):\\n        \"\"\"Stop the server and client processes.\"\"\"\\n        logger.info(\"Stopping processes...\")\\n        \\n        # Stop the client process\\n        if self.client_process and self.client_process.poll() is None:\\n            logger.info(f\"Terminating client process (PID {self.client_process.pid})...\")\\n            self.client_process.terminate()\\n            try:\\n                self.client_process.wait(timeout=5)\\n            except subprocess.TimeoutExpired:\\n                logger.warning(\"Client process did not terminate, killing...\")\\n                self.client_process.kill()\\n        \\n        # Stop the server process\\n        if self.server_process and self.server_process.poll() is None:\\n            logger.info(f\"Terminating server process (PID {self.server_process.pid})...\")\\n            self.server_process.terminate()\\n            try:\\n                self.server_process.wait(timeout=5)\\n            except subprocess.TimeoutExpired:\\n                logger.warning(\"Server process did not terminate, killing...\")\\n                self.server_process.kill()\\n        \\n        logger.info(\"All processes stopped\")\\n    \\n    def run(self):\\n        \"\"\"Run the voice assistant.\"\"\"\\n        self.running = True\\n        \\n        # Set up signal handlers for graceful shutdown\\n        def signal_handler(sig, frame):\\n            logger.info(f\"Received signal {sig}, shutting down...\")\\n            self.running = False\\n            self.stop_processes()\\n            sys.exit(0)\\n        \\n        signal.signal(signal.SIGINT, signal_handler)\\n        signal.signal(signal.SIGTERM, signal_handler)\\n        \\n        try:\\n            # Load environment variables\\n            env_loader = EnvLoader()\\n            env_loader.load_env()\\n            \\n            # Start the server process\\n            self.start_server()\\n            \\n            # Wait for the server to start\\n            import time\\n            time.sleep(2)\\n            \\n            # Start the client process\\n            self.start_client()\\n            \\n            # Wait for processes to finish\\n            while self.running:\\n                # Check if processes are still running\\n                if self.server_process.poll() is not None:\\n                    logger.error(f\"Server process exited with code {self.server_process.returncode}\")\\n                    self.running = False\\n                    break\\n                \\n                if self.client_process.poll() is not None:\\n                    logger.error(f\"Client process exited with code {self.client_process.returncode}\")\\n                    self.running = False\\n                    break\\n                \\n                time.sleep(0.1)\\n        \\n        except KeyboardInterrupt:\\n            logger.info(\"Interrupted by user\")\\n        \\n        except Exception as e:\\n            logger.exception(f\"Error in runner: {e}\")\\n        \\n        finally:\\n            # Stop processes\\n            self.stop_processes()\\n\\n\\ndef parse_arguments():\\n    \"\"\"Parse command-line arguments.\"\"\"\\n    parser = argparse.ArgumentParser(description=\"Voice Assistant Runner\")\\n    \\n    parser.add_argument(\\n        \"--server-config\",\\n        type=str,\\n        default=os.path.join(os.path.dirname(__file__), \"config\", \"server.yaml\"),\\n        help=\"Path to the server configuration file\",\\n    )\\n    \\n    parser.add_argument(\\n        \"--client-config\",\\n        type=str,\\n        default=os.path.join(os.path.dirname(__file__), \"config\", \"client.yaml\"),\\n        help=\"Path to the client configuration file\",\\n    )\\n    \\n    return parser.parse_args()\\n\\n\\ndef main():\\n    \"\"\"Run the voice assistant.\"\"\"\\n    # Parse command-line arguments\\n    args = parse_arguments()\\n    \\n    # Create and run the runner\\n    runner = VoiceAssistantRunner(args.server_config, args.client_config)\\n    runner.run()\\n\\n\\nif __name__ == \"__main__\":\\n    main()\\n' : Runner in voice_assistant does not import BaseRunner",
    "object_recognition: runner imports - 'from runner.base_runner import BaseRunner' not found in '#!/usr/bin/env python3\\n\"\"\"\\nObject Recognition Runner\\n\\nThis script sets up and runs both the client and server components\\nof the object recognition example.\\n\"\"\"\\n\\nimport argparse\\nimport asyncio\\nimport logging\\nimport os\\nimport signal\\nimport subprocess\\nimport sys\\nimport yaml\\nfrom pathlib import Path\\nfrom typing import Dict, Any, Optional, List, Tuple\\n\\n# Add the project root to the Python path\\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\\n\\nfrom src.unitmcp.utils.env_loader import EnvLoader\\n\\n# Configure logging\\nlogging.basicConfig(\\n    level=logging.INFO,\\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\\n)\\nlogger = logging.getLogger(__name__)\\n\\n\\nclass ObjectRecognitionRunner:\\n    \"\"\"\\n    Runner for the object recognition example.\\n    \\n    This class handles:\\n    - Loading environment variables\\n    - Starting the server process\\n    - Starting the client process\\n    - Handling signals for graceful shutdown\\n    \"\"\"\\n    \\n    def __init__(self, server_config_path: str, client_config_path: str):\\n        \"\"\"\\n        Initialize the object recognition runner.\\n        \\n        Parameters\\n        ----------\\n        server_config_path : str\\n            Path to the server configuration file\\n        client_config_path : str\\n            Path to the client configuration file\\n        \"\"\"\\n        self.server_config_path = server_config_path\\n        self.client_config_path = client_config_path\\n        self.server_process = None\\n        self.client_process = None\\n        self.running = False\\n    \\n    def _load_config(self, config_path: str) -> Dict[str, Any]:\\n        \"\"\"\\n        Load a configuration from a YAML file.\\n        \\n        Parameters\\n        ----------\\n        config_path : str\\n            Path to the configuration file\\n            \\n        Returns\\n        -------\\n        Dict[str, Any]\\n            Configuration\\n        \"\"\"\\n        with open(config_path, \\'r\\') as f:\\n            config = yaml.safe_load(f)\\n        return config\\n    \\n    def start_server(self):\\n        \"\"\"Start the server process.\"\"\"\\n        logger.info(\"Starting server process...\")\\n        \\n        # Get the server script path\\n        server_script = os.path.join(os.path.dirname(__file__), \"server.py\")\\n        \\n        # Start the server process\\n        self.server_process = subprocess.Popen(\\n            [sys.executable, server_script],\\n            stdout=subprocess.PIPE,\\n            stderr=subprocess.PIPE,\\n            text=True,\\n            bufsize=1,\\n        )\\n        \\n        logger.info(f\"Server process started with PID {self.server_process.pid}\")\\n        \\n        # Start a thread to read server output\\n        import threading\\n        \\n        def read_server_output():\\n            for line in self.server_process.stdout:\\n                print(f\"[SERVER] {line.strip()}\")\\n        \\n        def read_server_error():\\n            for line in self.server_process.stderr:\\n                print(f\"[SERVER ERROR] {line.strip()}\")\\n        \\n        threading.Thread(target=read_server_output, daemon=True).start()\\n        threading.Thread(target=read_server_error, daemon=True).start()\\n    \\n    def start_client(self):\\n        \"\"\"Start the client process.\"\"\"\\n        logger.info(\"Starting client process...\")\\n        \\n        # Get the client script path\\n        client_script = os.path.join(os.path.dirname(__file__), \"client.py\")\\n        \\n        # Start the client process\\n        self.client_process = subprocess.Popen(\\n            [sys.executable, client_script],\\n            stdout=subprocess.PIPE,\\n            stderr=subprocess.PIPE,\\n            text=True,\\n            bufsize=1,\\n        )\\n        \\n        logger.info(f\"Client process started with PID {self.client_process.pid}\")\\n        \\n        # Start a thread to read client output\\n        import threading\\n        \\n        def read_client_output():\\n            for line in self.client_process.stdout:\\n                print(f\"[CLIENT] {line.strip()}\")\\n        \\n        def read_client_error():\\n            for line in self.client_process.stderr:\\n                print(f\"[CLIENT ERROR] {line.strip()}\")\\n        \\n        threading.Thread(target=read_client_output, daemon=True).start()\\n        threading.Thread(target=read_client_error, daemon=True).start()\\n    \\n    def stop_processes(self):\\n        \"\"\"Stop the server and client processes.\"\"\"\\n        logger.info(\"Stopping processes...\")\\n        \\n        # Stop the client process\\n        if self.client_process and self.client_process.poll() is None:\\n            logger.info(f\"Terminating client process (PID {self.client_process.pid})...\")\\n            self.client_process.terminate()\\n            try:\\n                self.client_process.wait(timeout=5)\\n            except subprocess.TimeoutExpired:\\n                logger.warning(\"Client process did not terminate, killing...\")\\n                self.client_process.kill()\\n        \\n        # Stop the server process\\n        if self.server_process and self.server_process.poll() is None:\\n            logger.info(f\"Terminating server process (PID {self.server_process.pid})...\")\\n            self.server_process.terminate()\\n            try:\\n                self.server_process.wait(timeout=5)\\n            except subprocess.TimeoutExpired:\\n                logger.warning(\"Server process did not terminate, killing...\")\\n                self.server_process.kill()\\n        \\n        logger.info(\"All processes stopped\")\\n    \\n    def run(self):\\n        \"\"\"Run the object recognition example.\"\"\"\\n        self.running = True\\n        \\n        # Set up signal handlers for graceful shutdown\\n        def signal_handler(sig, frame):\\n            logger.info(f\"Received signal {sig}, shutting down...\")\\n            self.running = False\\n            self.stop_processes()\\n            sys.exit(0)\\n        \\n        signal.signal(signal.SIGINT, signal_handler)\\n        signal.signal(signal.SIGTERM, signal_handler)\\n        \\n        try:\\n            # Load environment variables\\n            env_loader = EnvLoader()\\n            env_loader.load_env()\\n            \\n            # Start the server process\\n            self.start_server()\\n            \\n            # Wait for the server to start\\n            import time\\n            time.sleep(2)\\n            \\n            # Start the client process\\n            self.start_client()\\n            \\n            # Wait for processes to finish\\n            while self.running:\\n                # Check if processes are still running\\n                if self.server_process.poll() is not None:\\n                    logger.error(f\"Server process exited with code {self.server_process.returncode}\")\\n                    self.running = False\\n                    break\\n                \\n                if self.client_process.poll() is not None:\\n                    logger.error(f\"Client process exited with code {self.client_process.returncode}\")\\n                    self.running = False\\n                    break\\n                \\n                time.sleep(0.1)\\n        \\n        except KeyboardInterrupt:\\n            logger.info(\"Interrupted by user\")\\n        \\n        except Exception as e:\\n            logger.exception(f\"Error in runner: {e}\")\\n        \\n        finally:\\n            # Stop processes\\n            self.stop_processes()\\n\\n\\ndef parse_arguments():\\n    \"\"\"Parse command-line arguments.\"\"\"\\n    parser = argparse.ArgumentParser(description=\"Object Recognition Runner\")\\n    \\n    parser.add_argument(\\n        \"--server-config\",\\n        type=str,\\n        default=os.path.join(os.path.dirname(__file__), \"config\", \"server.yaml\"),\\n        help=\"Path to the server configuration file\",\\n    )\\n    \\n    parser.add_argument(\\n        \"--client-config\",\\n        type=str,\\n        default=os.path.join(os.path.dirname(__file__), \"config\", \"client.yaml\"),\\n        help=\"Path to the client configuration file\",\\n    )\\n    \\n    return parser.parse_args()\\n\\n\\ndef main():\\n    \"\"\"Run the object recognition example.\"\"\"\\n    # Parse command-line arguments\\n    args = parse_arguments()\\n    \\n    # Create and run the runner\\n    runner = ObjectRecognitionRunner(args.server_config, args.client_config)\\n    runner.run()\\n\\n\\nif __name__ == \"__main__\":\\n    main()\\n' : Runner in object_recognition does not import BaseRunner"
  ],
  "skipped": []
}