#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
A post-processing module for DFT lattice dynamics by harmonic and quasiharmonic
approximations (HA/QHA).
"""
from warnings import warn, filterwarnings
from copy import deepcopy

from numpy.polynomial.polynomial import Polynomial, polyfit
import numpy as np
from scipy.constants import N_A as Avogadro
from scipy.constants import h as Planck
from scipy.constants import k as Boltzmann
from scipy.optimize import minimize, linear_sum_assignment
from sympy import diff, lambdify, symbols

from CRYSTALpytools.base.dump import ThermoHA, ThermoQHA
from CRYSTALpytools import units
from CRYSTALpytools.phonons import Phonon

molh = Planck * Avogadro
molk = Boltzmann * Avogadro
molpv = Avogadro * 1e-24 # kJ/mol


class Harmonic():
    """
    A class for harmonic phonon calclulations. It can be parameterized from a
    CRYSTAL output file, phonopy ouput file or by setting all the information
    (usually for QHA).

    Args:
        temperature (array|float): *Optional* Temperatures where thermodynamic
            properties are computed. Unit: K
        pressure (array|float): *Optional* Pressures where thermodyanmic
            properties are calculated. Unit: GPa
        filename (str | None): Name of the printed-out file. If None, do not
            print out file.
        autocalc (bool): Automatically launch calculations.
        use_old (bool): Use the deprecated text fomat output, which cannot be
            used for restarting calculation.

    Temperatures and pressures can also be defined by ``self.thermodynamics``,
    whose entries always cover the entries here.

    Phonon dispersions are forced to be summed if the automatic scheme
    (``autocalc=True``) is launched. To get verbose outputs, call
    ``self.thermodynamics()`` first and then call ``self.print_results()``.

    Usage::

        ha = Harmonic(temperature=[0, 100, 200, 300], pressure=[0.,])
        ha.from_file('harmonic_phonon.out')
    """

    def __init__(self, temperature=[], pressure=[], filename=None,
                 autocalc=True, use_old=False):
        self.temperature = np.array(temperature, dtype=float, ndmin=1)
        self.pressure = np.array(pressure, dtype=float, ndmin=1)
        self.autocalc = autocalc
        self.filename = str(filename)
        if self.filename != 'None':
            if use_old == True:
                warn('The text output is deprecated. Please use the dumping file in YAML format.', stacklevel=2)
                self.filefmt = 'txt'
            else:
                self.filefmt = 'yaml'
        else:
            self.filefmt = 'None'

    @property
    def edft(self):
        """For compatibility"""
        return self.u_0

    @classmethod
    def restart(cls, filename):
        """
        Restart calculation from a dumped YAML file. ``autocalc`` is switched
        off. Instantiation will not update the dumped file, but thermodynamic
        calculations will.

        Args:
            filename (str): YAML file
        Returns:
            obj (Harmonic)
        """
        obj = ThermoHA.restart(filename)
        obj.filename = filename
        obj.filefmt = 'yaml'
        return obj

    def from_file(self, filename, source='crystal',
                  scale=1.0, scale_range=[],
                  imaginary_tol=-1e-4, q_overlap_tol=1e-4,
                  q_id=None, q_coord=None, read_eigvt=False, **kwargs):
        """
        Generate the Harominc object from an output file. Files generated by
        the following methods are supported (also the accepted entries for
        ``source``):

        * ``'crystal'``: CRYSTAL harmonic phonon outputs (Gamma, dispersion).  
        * ``'crystal-QHA'``: CRYSTAL QHA outputs.  
        * ``'phonopy'``: Phonopy qpoints and mesh files.

        .. note::

            In rare cases, the user might want to collect data of a few
            specific q points. ``q_id`` and ``q_coord`` can be set but not
            simultaneously. If set, ``q_id`` takes priority and ``q_coord`` is
            ignored.

        Args:
            filename (str): Name of the output file.
            source (str): The program used for the output file.
            scale (float|array): Scaling factors
            scale_range (array): nScale\*2 array. The frequency range of the
                scaling factor. Including the minimum and excluding the maximum.
                Use empty list for a uniform scaling.
            imaginary_tol (float): The threshold of negative frequencies.
            q_overlap_tol (float): The threshold of overlapping points, defined
                as the 2nd norm of the difference of fractional q vectors
            q_id (array): Index (from 0) of q points to be read. 1\*nqpoint.
            q_coord (array): Fractional coordinates of q points to read.
                nqpoint\*3 list.
            read_eigvt: Deprecated.
            \*\*kwargs: Other keywords passed to corresponding I/O functions.
                See below.
            qha_index (int): *crystal-QHA*. The index of calculation to read (from 0).
            struc_yaml (str): *phonopy*. 'qpoints.yaml' only.
            u_0 (float): *phonopy*. Static internal energy in kJ/mol.
            irreps_yaml (array[str]): *phonopy*. Read 'irreps.yaml' for mode
                symmetry symbols. The fractional coordinates in the file are
                used for ``q_coord`` if not specified. Phonopy 'irreps.yaml'
                only contains symmetry info of a q point. Use a list of
                filenames for multiple q points.

        Returns:
            self (Harmonic): Attributes listed below.
            structure (CStructure): Extended Pymatgen structure class. For
                the finite displacement method, this is the cell before
                supercell expansion.
            natom (int): Number of atoms in the cell.
            volume (float): Volume of the cell. Unit: :math:`\\AA^{3}`
            u_0 (float): Internal energy. Unit: kJ/mol
            nqpoint (int): Number of q points
            qpoint (list): nQpoint\*4 list. The first three elements are 
                fractional coordinates in reciprocal space and the last is
                its weight, i.e., number of equivalent q points.
            nmode (int): Number of modes.
            frequency (array[float]): nQpoint\*nMode array of frequencies in THz.
            mode_symm (array[str]): nQpoint\*nMode array of the  irreducible
                representations. In Mulliken symbols.
            eigenvector (array[float]): nQpoint\*nMode\*nAtom\*3 array of phonon
                eigenvectors.
        """
        if hasattr(self, "frequency"):
            raise Exception("Data exists. Please start from an empty object.")

        # kJ/mol to eV
        if 'u_0' in kwargs.keys():
            kwargs['u_0'] = units.H_to_eV(units.kjmol_to_H(kwargs['u_0']))

        phonon = Phonon.from_file(filename, source=source,
                                  q_id=q_id, q_coord=q_coord, **kwargs)
        # eV to kJ/mol
        u_0 = units.H_to_kjmol(units.eV_to_H(phonon.u_0))

        phonon.frequency = phonon.scale_frequency(scale, scale_range)
        phonon.clean_q_overlap(threshold=q_overlap_tol)
        phonon.clean_imaginary(threshold=imaginary_tol)
        # Instantiation
        self.from_frequency(u_0, phonon.qpoint, phonon.frequency,
                            phonon.eigenvector, phonon.mode_symm,
                            structure=phonon.structure)
        # Autocalc
        if self.autocalc == True:
            self.thermodynamics()
        else:
            if self.filefmt=='yaml':
                ThermoHA.write(self)
            elif self.filefmt=='txt':
                ThermoHA.old_write(self)
        return self

    def from_frequency(self, u_0, qpoint, frequency, eigenvector, symmetry,
                       structure=None, natom=None, volume=None):
        """
        Generate a Harmonic object by specifying frequency and eigenvector.
        Usually called by other methods.

        Args:
            u_0 (float): Static total energy in kJ/mol.
            qpoint (array[float]): nQpoint\*4 array. The first three elements
                are fractional coordinate and the last is weight.
            frequency (array[float]): Array of frequencies. Unit: THz
            eigenvector (array[float]): Mass weighted and phased eigenvectors
            normalized to 1.
            symmetry (array[str]): Irreducible representations in Mulliken symbols.
            structure (CStructure): Extended Pymatgen structure class. For the
                finite displacement method, this is the cell before expansion.
            natom (int): Number of atoms in the reduced cell.
            volume (float): Volume of the reduced cell. Unit: :math:`\\AA^{3}`.

        .. note::

            The user should define ``structure``. ``natom`` and ``volume`` are
            for developers only.

        Returns:
            self (Harmonic): Attributes see ``from_file()``.

        :raise Exception: If computational data is stored in the object.
        :raise ValueError: If neither of the 2 available options are defined.
        """
        if hasattr(self, "frequency"):
            raise Exception("Data exists. Please start from an empty object.")

        if np.all(structure!=None):
            self.structure = structure
            self.natom = structure.num_sites
            self.volume = structure.lattice.volume
        elif np.all(natom!=None) and np.all(volume!=None):
            self.natom = int(natom)
            self.volume = float(volume)
        else:
            raise ValueError('Geometry is not sufficiently defined. Structure or volume + natom are needed.')

        if len(qpoint) != frequency.shape[0]:
            raise ValueError("The 1st dimension (n qpoint) of 'qpoint' and 'frequency' are not consistent.")
        if symmetry.shape[0] != frequency.shape[0] or symmetry.shape[1] != frequency.shape[1]:
            raise ValueError("Inconsistent dimensions between 'frequency' and 'symmetry'.")
        if eigenvector.shape[-1] != 0:
            if eigenvector.shape[0] != frequency.shape[0] or eigenvector.shape[1] != frequency.shape[1]:
                raise ValueError("Inconsistent dimensions between 'frequency' and 'eigenvector'.")
            if eigenvector.shape[2] != self.natom:
                raise ValueError("The 3rd dimension (n atom) of 'eigenvector' and input geometry are not consistent.")

        self.u_0 = u_0
        self.nqpoint = len(qpoint)
        self.qpoint = qpoint
        self.frequency = np.array(frequency, dtype=float, ndmin=2)
        self.nmode = self.frequency.shape[1]
        self.mode_symm = np.array(symmetry, dtype=str, ndmin=2)
        self.eigenvector = np.array(eigenvector, dtype=complex, ndmin=4)
        return self

    def thermodynamics(self, **kwargs):
        """
        Calculate the thermodynamic properties (zp_energy, u_vib, entropy, c_v
        and Gibbs and Helmholtz free energy) of the HA system.

        Zero-point energy :math:`E^{zp}`:

        .. math::

            E^{zp}=\\sum_{i,\\mathbf{q}}\\frac{1}{2}\\hbar\\omega_{i,\\mathbf{q}}

        Vibration contribution to internal energy :math:`U^{vib}`:

        .. math::

            U^{vib}\\left(T\\right)=E^{zp}+\\sum_{i,\\mathbf{q}}
            \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{\\exp{\\left(
                \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
            \\right)}-1}

        Entropy :math:`S`:

        .. math::

            S\\left(T\\right)=k_{B}\\sum_{i,\\mathbf{q}}\\left\\{
                \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T\\left[
                    \\exp{\\left(
                        \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
                    \\right)}-1
                \\right]}-\\ln{\\left[
                    1-\\exp{\\left(
                        -\\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
                    \\right)}
                \\right]}
            \\right\\}

        Constant volume specific heat :math:`C^{V}`:

        .. math::

            C_{V}\\left(T\\right)=\\sum_{i,\\mathbf{q}}
            \\frac{\\left(\\hbar\\omega_{i,\\mathbf{q}}\\right)^{2}}{k_{B}T^{2}}
            \\frac{\\exp{
            \\left(
                \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
            \\right)}
            }{\\left[
                \\exp{\\left(
                    \\frac{\\hbar\\omega_{i,\\mathbf{q}}}{k_{B}T}
                \\right)-1}
            \\right]^{2}
            }

        The Helmholtz and Gibbs free energies are defined as:

        .. math::

            F(T) = U_{0} + F_{vib}(T) = U_{0} + U_{vib}(T) - TS(T)

            G(T, p) = F + pV

        Args:
            temperature (array|float): *Optional* Unit: K
            pressure (array|float): *Optional* Unit: GPa
            sumphonon (bool): Deprecated. Not used.

        Returns:
            self (Harmonic): Attributes listed below.
            self.helmholtz (array): 1\*nTemperature. Unit: KJ/mol
            self.gibbs (array): nPressure\*nTemperature. Unit: KJ/mol
            self.zp_energy (float): Zero-point energy. Unit: KJ/mol
            self.u_vib (array): Vibrational contribution to internal energy.
                1\*nTemperature. Unit: KJ/mol
            self.entropy (array): 1\*nTemperature. Unit: J/mol\*K
            self.c_v (array): Constant volume specific heat. 1\*nTemperature.
                Unit: J/mol\*K

        :raise Exception: If temperature and pressure are defined neither here nor during initialization
        """
        # Generate temperature and pressure series
        if 'temperature' in kwargs:
            if len(self.temperature) > 0:
                warn('Temperature attribute exists. Input temperatures will be used to update the attribute.', stacklevel=2)
            self.temperature = np.array(kwargs['temperature'], dtype=float, ndmin=1)

        if 'pressure' in kwargs:
            if len(self.pressure) > 0:
                warn('Pressure attribute exists. Input pressures will be used to update the attribute.', stacklevel=2)
            self.pressure = np.array(kwargs['pressure'], dtype=float, ndmin=1)

        if len(self.temperature)==0 or len(self.pressure)==0:
            raise Exception('Temperature and pressure should be specified.')
        zp_energy = np.zeros([self.nqpoint,], dtype=float)
        u_vib = np.zeros([self.nqpoint, len(self.temperature)], dtype=float)
        entropy = np.zeros([self.nqpoint, len(self.temperature)], dtype=float)
        c_v = np.zeros([self.nqpoint, len(self.temperature)], dtype=float)

        it = np.where(self.temperature>1e-4)[0]
        tempt = self.temperature[it]
        kBT = molk * tempt * 1e-3 # kJ/mol
        for iq in range(self.nqpoint):
            freq = self.frequency[iq, np.where(self.frequency[iq]>1e-4)[0]]
            hbar_freq = freq * molh * 1e9 # kJ/mol
            zp_energy[iq] = 0.5 * np.sum(hbar_freq)

            hbar_freq = np.repeat(hbar_freq[:, np.newaxis], tempt.shape[0], axis=1) # nMode * nT
            beta = hbar_freq / kBT
            exp = np.exp(beta)
            u_vib[iq] += zp_energy[iq]
            u_vib[iq, it] += np.sum(hbar_freq / (exp - 1), axis=0)
            entropy[iq, it] = np.sum(molk * (beta/(1-1/exp) - np.log(exp-1)), axis=0)
            c_v[iq, it] = np.sum(beta**2 * molk / (exp - 2 + 1/exp), axis=0)

        helm = -entropy * self.temperature * 1e-3 + u_vib + self.u_0
        gibbs = np.zeros([self.nqpoint, len(self.pressure), len(self.temperature)], dtype=float)
        for npress, press in enumerate(self.pressure):
            gibbs[:, npress, :] = press * self.volume * molpv + helm

        wt = self.qpoint[:, 3] / np.sum(self.qpoint[:, 3])
        # wt = wt.reshape([1, self.nqpoint])
        # self.nqpoint = 1
        # self.qpoint = np.array([[0., 0., 0., 1.]], dtype=float)
        self.zp_energy = wt @ zp_energy
        self.u_vib = wt @ u_vib
        self.entropy = wt @ entropy
        self.c_v = wt @ c_v
        self.helmholtz = wt @ helm
        self.gibbs = np.zeros([len(self.pressure), len(self.temperature)], dtype=float)
        for i in range(len(self.pressure)):
            self.gibbs[i, :] = wt @ gibbs[:,i,:]

        # Deprecated attributes and methods
        if self.filefmt=='yaml':
            filterwarnings("ignore", 'The existing HA file will be overwritten.')
            ThermoHA.write(self)
        elif self.filefmt=='txt':
            ThermoHA.old_write(self)
        return self

    def mode_thermo(self, q, m, **kwargs):
        """Return to thermodynamic properties of the specified mode(s). Units
        are consistent with the ``thermodynamics()`` method.

        Args:
            q (int|array): Indices of q point, from 0.
            m (int|array): Indices of mode, from 0.
            \*\*kwargs: See below.
            temperature (array|float): If not present, use ``self.temperature``. It will not update the attribute.
            pressure (array|float): If not present, use ``self.pressure``. It will not update the attribute.
        Returns:
            zp_energy (float)
            u_vib (array): 1\*nTemperture
            entropy (array): 1\*nTemperture
            c_v (array): 1\*nTemperture
            helmholtz (array): 1\*nTemperture, excluding DFT total energy of the system
            gibbs (array): nPressure\*nTemperture, excluding DFT total energy of the system
        """
        if 'temperature' in kwargs: T = kwargs['temperature']
        else: T = self.temperature
        if 'pressure' in kwargs: p = kwargs['pressure']
        else: p = self.pressure

        if len(T)==0 or len(p)==0:
            raise Exception('Temperature and pressure should be specified.')

        q = np.array(q, dtype=int, ndmin=1)
        m = np.array(m, dtype=int, ndmin=1)
        nT = T.shape[0]; npress = p.shape[0]
        wt = self.qpoint[:, 3] / np.sum(self.qpoint[:, 3])

        zp_energy = 0.
        u_vib = np.zeros([nT, ], dtype=float)
        entropy = np.zeros([nT, ], dtype=float)
        c_v = np.zeros([nT, ], dtype=float)
        it = np.where(T>1e-4)[0]
        tempt = T[it]
        kBT = molk * tempt * 1e-3 # kJ/mol
        for iqpt, wqpt in zip(q, wt[q]):
            freq = self.frequency[iqpt, m]
            freq = freq[np.where(freq>1e-4)[0]]
            hbar_freq = freq * molh * 1e9 # kJ/mol
            zp_energy += 0.5 * np.sum(hbar_freq) * wqpt

            hbar_freq = np.repeat(hbar_freq[:, np.newaxis], tempt.shape[0], axis=1) # nMode * nT
            beta = hbar_freq / kBT
            exp = np.exp(beta)
            u_vib[it] += np.sum(hbar_freq / (exp - 1), axis=0) * wqpt
            entropy[it] += np.sum(molk * (beta/(1-1/exp) - np.log(exp-1)), axis=0) * wqpt
            c_v[it] += np.sum(beta**2 * molk / (exp - 2 + 1/exp), axis=0) * wqpt

        u_vib += zp_energy
        helmholtz = -entropy * T * 1e-3 + u_vib
        gibbs = np.zeros([npress, nT], dtype=float)
        for ipress, press in enumerate(p):
            gibbs[ipress, :] = press * self.volume * molpv + helmholtz
        return zp_energy, u_vib, entropy, c_v, helmholtz, gibbs

    def write_HA_result(self):
        """Write output. Typically the code dumps data to file automatically."""
        if self.filename == 'None':
            warn('Output file not specified. Return.')
            return
        if self.filefmt=='yaml':
            filterwarnings("ignore", 'The existing HA file will be overwritten.')
            ThermoHA.write(self)
        elif self.filefmt=='txt':
            ThermoHA.old_write(self)
        return

# -------------------------------- deprecated --------------------------------#
    def from_phonopy(self, phono_yaml, struc_yaml=None, edft=None, scale=1.0,
                     imaginary_tol=1e-4, q_overlap_tol=1e-4, q_id=None, q_coord=None):
        """Deprecated. Call ``from_file()`` directly."""
        warn("Deprecated. Call 'from_file(source='phonopy')' instead.", stacklevel=2)
        inpargs = {}
        if edft != None:
            inpargs['u_0'] = edft
        if struc_yaml != None:
            inpargs['struc_yaml'] = struc_yaml
        self.from_file(phono_yaml, source='phonopy', scale=scale,
                       imaginary_tol=imaginary_tol, q_overlap_tol=q_overlap_tol,
                       q_id=q_id, q_coord=q_coord, **inpargs)
        return self


class Quasi_harmonic:
    """
    Generate and rearrange harmonic phonons, store the fitted, volume-dependent
    QHA phonon information and obtain the QHA thermodynamic properties.

    Args:
        temperature (array|float): Should be given in ascending order, or will be sorted. Unit: K
        pressure (array|float): Should be given in ascending order, or will be sorted. Unit: GPa
        filename (str): Name of the output file in YAML format for restarting calculation.
        use_old (bool): Use the deprecated text fomat output, which cannot be
            used for restarting calculation.

    Temperatures and pressures can also be defined by ``self.thermodynamics``,
    whose entries always cover the entries here.

    Usage::

        qha = Quasi_harmonic()
        qha.from_QHA_file('qha_phonon.out')
        qha.thermo_freq(eos_method='birch_murnaghan', temperature=[0, 100, 200, 300], pressure=[0., 0.5, 1.]):
    """

    def __init__(self, temperature=[], pressure=[], filename=None, use_old=False):
        self.temperature = np.array(temperature, dtype=float, ndmin=1)
        self.pressure = np.array(pressure, dtype=float, ndmin=1)
        if self.temperature.shape[-1] > 0: self.temperature.sort()
        if self.pressure.shape[-1] > 0: self.pressure.sort()

        self.filename = str(filename)
        # should be changed by the corresponding method only.
        self.method = 'unknown'
        if self.filename != 'None':
            if use_old == True:
                warn('The text output is deprecated. Please use the dumping file in YAML format.', stacklevel=2)
                self.filefmt = 'txt'
            else:
                self.filefmt = 'yaml'
        else:
            self.filefmt = 'None'


    def from_file(self, *filename, source='crystal', mode_sort_tol=0.4, **kwargs):
        """
        Instatiation from output file(s). Files generated by the following
        methods are supported (also the accepted entries for ``source``):

        * ``'crystal'``: CRYSTAL harmonic phonon outputs (Gamma, dispersion).  
        * ``'crystal-QHA'``: CRYSTAL QHA outputs.  
        * ``'phonopy'``: Phonopy qpoints and mesh files.

        Instatiation from outputs.

        Args:
            \*filename (str): Phonon output filename(s). Extendable.
            source (str): The program used for the output file.
            mode_sort_tol (float | None): The threshold of close mode overlaps
                with eigenvectors if present. If none, do not sort modes and
                eigenvector is not read.
            \*\*kwargs: Optional keywords passed to ``Harmonic().from_file()``.
            scale (float|array):
            scale_range (array):
            imaginary_tol (float):
            q_overlap_tol (float):
            q_id (array): Applied to all HA calculations.
            q_coord (array): Applied to all HA calculations.
            struc_yaml (list[str]): *phonopy*. 'qpoints.yaml' only.
            u_0 (list[float]): *phonopy*. Static internal energy in kJ/mol.
            irreps_yaml (array[str]): *phonopy*. nCalc\*nQpoint array. Read
                'irreps.yaml' for mode symmetry symbols. The fractional coordinates
                in the file are used for ``q_coord`` if not specified. Phonopy
                'irreps.yaml' only contains symmetry info of a q point. Use a
                list of filenames for multiple q points.

        Returns:
            self (Quasi_harmonic): New Attributes listed below
            ncalc (int): Number of HA phonon calculations.
            combined_volume (array[float]): 1\*nCalc volumes. Unit: :math:`\\AA^{3}`
            combined_struc (list[CStructure]): 1\*nCalc HA structures.
            combined_u0 (array[float]): 1\*nCalc static internal energies. Unit: kJ/mol
            combined_freq (array[float]): nQpoint\*nMode\*nCalc frequencies. Unit: THz
            combined_symm (array[str]): nQpoint\*nMode\*nCalc mode symmetry in Mulliken symbol.
            nqpoint (int): Number of q points.
            qpoint (array[float]): nQpoint\*4 array. The first three elements are fractional coordinates,
                and the last is the weight.
            nmode (int): Number of modes.
            natom (int): Number of atoms.
        """
        import pandas as pd

        if hasattr(self, "ncalc"):
            Exception("Data exists. Please start from an empty object.")

        # compatibility with older versions.
        if isinstance(filename[0], list) or isinstance(filename[0], np.ndarray):
            filename = filename[0]

        source = source.lower()
        source_list = ['crystal', 'crystal-qha', 'phonopy']
        if source not in source_list:
            raise Exception("Unknown source file: '{}'.".format(source))

        if source == 'crystal-qha':
            if len(filename) != 1: raise Exception("The source 'crystal-QHA' only accepts one input file.")
            file = open(filename[0])
            df = pd.DataFrame(file)
            file.close()
            qhatitle = df[df[0].str.contains(r'\s+QUASI\-HARMONIC APPROXIMATION\s*$')].index
            if len(qhatitle) == 0: raise Exception("Not a CRYSTAL QHA file.")
            dftitle = df[df[0].str.contains(r'\s*\*\s+CELL DEFORMATION\s*$')].index.tolist()
            self.ncalc = len(dftitle); del df
        else:
            self.ncalc = len(filename)

        if self.ncalc == 1:
            raise Exception('Only 1 input file! Use Harmonic object or from_QHA_file method.')

        # Harmonic input arguments
        accepted_args = ['scale', 'scale_range', 'imaginary_tol', 'q_overlap_tol',
                         'q_id', 'q_coord', 'struc_yaml', 'u_0', 'irreps_yaml']
        list_args = ['struc_yaml', 'u_0', 'irreps_yaml']
        hainp = dict(source=source)
        for a in kwargs.keys():
            if a in accepted_args:
                if a in list_args:
                    inplist = np.array(kwargs[a])
                    if inplist.shape[0] != self.ncalc:
                        raise Exception("Input '{}' must have the same dimension as number of calculations.".format(a))
                    hainp[a] = inplist
                else:
                    hainp[a] = kwargs[a]
        if mode_sort_tol != None: hainp['read_eigvt'] = True
        else: hainp['read_eigvt'] = False

        # Instatiate HA objects.
        ha_list = []
        if source == 'crystal':
            for file in filename:
                ha_list.append(
                    Harmonic(filename=None, autocalc=False).from_file(file, **hainp)
                )
        elif source == 'crystal-qha':
            for icalc in range(self.ncalc):
                hainp['qha_index'] = icalc
                ha_list.append(
                    Harmonic(filename=None, autocalc=False).from_file(filename[0], **hainp)
                )
        elif source == 'phonopy':
            for ifile, file in enumerate(filename):
                realinp = deepcopy(hainp)
                if 'u_0' in hainp.keys(): # kJ/mol
                    realinp['u_0'] = hainp['u_0'][ifile]
                if 'struc_yaml' in hainp.keys():
                    realinp['struc_yaml'] = hainp['struc_yaml'][ifile]
                if 'irreps_yaml' in hainp.keys():
                    realinp['irreps_yaml'] = hainp['irreps_yaml'][ifile]
                ha_list.append(
                    Harmonic(filename=None, autocalc=False).from_file(file, **realinp)
                )

        if mode_sort_tol!=None and ha_list[0].eigenvector.shape[-1] != 0:
            close_overlap, dot_pdt = self._combine_data(ha_list, mode_sort_tol=mode_sort_tol)
        else:
            _ = self._combine_data(ha_list, mode_sort_tol=None)
            close_overlap = []; dot_pdt = []

        if self.filefmt=='yaml':
            ThermoQHA.write_combine_data(self, close_overlap, dot_pdt)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_combine_data(self, close_overlap)
        return self


    @property
    def combined_edft(self):
        """For compatibility with older versions"""
        return self.combined_u0


    @classmethod
    def restart(cls, filename):
        """
        Restart calculation from a dumped YAML file. Instantiation will not
        update the dumped file, but thermodynamic calculations will.

        Args:
            filename (str): YAML file
        Returns:
            obj (Quasi_harmonic)
        """
        obj = ThermoQHA.restart(filename)
        obj.filename = filename
        obj.filefmt = 'yaml'
        return obj


    def thermo_freq(self, eos_method='birch_murnaghan', poly_order=[2, 3],
                    min_method='BFGS', volume_bound=None, mutewarning=False,
                    **kwargs):
        """
        Obtain thermodynamic properties by explicitly fitting phonon
        frequencies as polynomial functions of volume. DFT total energies are
        fitted as a function of volume by equation of states (EOS).

        The equilibrium volume is fitted by minimizing Gibbs free energy at
        constant temperature and pressure.

        .. math::

            V(T,p)=\\text{min}[G(V;T,p)]=\\text{min}[E_{0}(V)+F_{vib}(V;T,p)+pV)]

        Parameterized and tested algorithms for ``min_method``:

        * BFGS(no boundary)  
        * L-BFGS-B(with boundary)

        Isothermal bulk modulus :math:`K_{T}` is obtained by a secondary fit of
        $F(V; T)$ with the same ``eos_method``.

        .. math::

            K_{T}(p;T) = V(p;T)\\left(\\frac{\\partial^{2}F(V;T)}{\\partial V^{2}}\\right)_{T}

        .. note::

            For a good fitting of isothermal bulk modulus :math:`K_{T}`, the
            number of pressures must >= 5.

        The mode-specific Grüneisen parameters are obtained by deriving the
        the fitted frequency at given temperature, pressure and equilibrium volume:

        .. math::

            \\gamma_{\\textbf{q}i}(T,p)=-\\frac{V_{0}}{\\omega_{\\textbf{q}i}}\\frac{\\text{d}\\omega_{\\textbf{q}i}}{\\text{d}V_{0}}

        Then the macroscopic Grüneisen parameters and thermal expansions are
        obtained with the standard Grüneisen method. See the ``thermo_gruneisen()``
        method below.

        Args:
            eos_method (str): EOS used to fit DFT total energy and Helmholtz
                free energy (to get bulk modules). Valid entries are consistent
                with `PyMatGen eos module <https://pymatgen.org/pymatgen.analysis.html#module-pymatgen.analysis.eos>`_.
            poly_order (array[int]): The order of polynomials used to fit
                frequency as the function of volumes.
            min_method (string): Minimisation algorithms, 'BFGS'/'L-BFGS-B'.
                See above.
            volume_bound (tuple-like), Boundary conditions of equilibrium
                volumes. Unit: :math:`\\AA^{3}`
            mutewarning (bool): Whether print out warning messages.
            \*\*kwargs: See below
            temperature (array[float]): Should be given in ascending order, or will be sorted. Unit: K
            pressure (array[float]): Should be given in ascending order, or will be sorted. Unit: GPa
            order (int): For DeltaFactor / Polynomial EOSs.
            min_ndata_factor, max_poly_order_factor, min_poly_order_factor (int):
                For Numerical EOS.
        Returns:
            self (Quasi_harmonic): New Attributes listed below
            self.temperature (array): Unit: K
            self.pressure (array): Unit: GPa
            self.volume (array): nPressure\*nTemperature, same below. Equilibrium volumes. Unit: :math:`\\AA^{3}`
            self.helmholtz (array): Helmholtz free energy. Unit: kJ/mol
            self.gibbs (array): Gibbs free energy. Unit: kJ/mol
            self.entropy (array): Entropy. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.gruneisen(array): npressure\*ntemperature, same below. Macroscopic Grüneisen parameter.
            self.alpha_v (array): Thermal expansion coefficient by Grüneisen method.
            self.c_v (array): Constant volume specific heat. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.c_p (array): Constant pressure specific heat by Grüneisen method. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.k_t (array): Isothermal bulk modulus. Unit: GPa.
            self.k_s (array): Adiabatic bulk modulus by Grüneisen method. Unit: GPa.
            self.eos_method (str): Name of the EOS.
            self.u0_fit (Pymatgen EOS): EOS used to fit DFT energy.
            self.eos (list[Pymatgen EOS]): Pymatgen EOS objects. EOS used to fit Helmholtz free energy.
            self.e0_eos_method: Deprecated. Synonym of 'self.eos_method'.
            self.e0_eos: Deprecated. Synonym of 'self.u0_fit'.

        :raise Exception: If temperature or pressure is defined neither here nor during initialization.
        """
        # Sanity check
        if self.ncalc < 3: raise Exception('Insufficient database. Increase HA phonons')
        if self._mode_sorted == False: raise Exception('Vibrational modes must be sorted with their eigenvectors.')

        if self.method != 'thermo_freq': refit = True
        else: refit = False

        # Temperature and pressure
        if 'temperature' in kwargs:
            if len(self.temperature)>0 and (mutewarning == False or refit == False):
                warn('Temperature attribute exists. Input temperatures will be used to update the attribute.', stacklevel=2)
            self.temperature = np.array(kwargs['temperature'], dtype=float, ndmin=1)
            refit = True
        if 'pressure' in kwargs:
            if len(self.pressure)>0 and (mutewarning == False or refit == False):
                warn('Pressure attribute exists. Input pressures will be used to update the attribute.', stacklevel=2)
            self.pressure = np.array(kwargs['pressure'], dtype=float, ndmin=1)
            refit = True
        if len(self.temperature)==0 or len(self.pressure)==0:
            raise Exception('Temperature and pressure should be specified.')

        if len(self.pressure) < 5:
            raise Exception("At least 5 pressures are required")

        self.temperature.sort(); self.pressure.sort()

        # eos
        if hasattr(self, 'eos_method'):
            if self.eos_method != eos_method: refit = True
        else:
            refit = True

        # Polynomial, at least 1 redundant data to fit dV
        poly_order = np.unique(np.array(poly_order, dtype=int, ndmin=1))
        poly_order = poly_order[np.where((poly_order<self.ncalc)&(poly_order>0))[0]]
        if len(poly_order) == 0:
            raise Exception('At least order+1 phonon calculations are needed.')
        if hasattr(self, 'fit_order'):
            for i in poly_order:
                if i not in self.fit_order: refit = True; break
        else:
            refit = True

        # Min_method
        if hasattr(self, 'min_method'):
            if self.min_method != min_method: refit = True
        else:
            refit = True

        # Other args
        if np.all(volume_bound!=None) or 'order' in kwargs.keys() \
        or 'min_ndata_factor' in kwargs.keys() or 'max_poly_order_factor' in kwargs.keys() \
        or 'min_poly_order' in kwargs.keys(): refit = True

        if refit == False:
            warnings.warn('Nothing to re-fit. Return to the same object.', stacklevel=2)
            return self

        # Fit DFT total energy. Fitted values will not be covered.
        if self.method == 'thermo_freq' and hasattr(self, 'eos'):
            pass
        else:
            eosinp = {}; eos_method = eos_method.lower()
            for i in ['min_ndata_factor', 'max_poly_order_factor', 'min_poly_order_factor ']:
                if i in kwargs.keys(): eosinp[i] = kwargs[i]
            self.u0_fit = self.eos_fit(self.combined_volume, self.combined_u0, eos_method, **eosinp)
            self.eos_method = eos_method

        # Fit frequencies, Fitted values will not be covered.
        if self.method == 'thermo_freq' and hasattr(self, 'fit_order'):
            r2tot = [['unknown' for i in range(qha.nmode)] for j in range(qha.nqpoint)]
            r2avg='Not available for restarted calculations.'
        else:
            r2tot, r2avg = self.freq_polynomial_fit(order=poly_order)
            r2tot = [[float(j) for j in i] for i in r2tot]
            r2avg = float(r2avg)

        # Minimization
        self._clean_thermoprop()
        self.method = 'thermo_freq'
        self.min_method = min_method
        methods = {
            'BFGS': "vol = minimize(gibbs_opt, v_init, args=(t, p, obj, zp, wt, kBt), method='BFGS', jac='3-point')",
            'L-BFGS-B': "vol = minimize(gibbs_opt, v_init, args=(t, p, obj, zp, wt, kBt), method='L-BFGS-B', jac='3-point', bounds=volume_bound)",
        }

        # Expression of Gibbs free energy
        def gibbs_opt(volume, t, p, obj, zp, wt, kBt):
            volume = volume[0]
            dv = volume - obj.combined_volume[0]

            mTS = 0.
            if t > 1e-4:
                for iq in range(obj.nqpoint):
                    freq = np.array([i(dv) for i in obj.freq_fit[iq]])
                    beta = molh*freq[np.where(freq>1e-4)[0]]*1e9 / kBt
                    mTS += wt[iq] * kBt * np.sum(np.log(1 - np.exp(-beta)))
            return obj.u0_fit(volume) + zp(dv) + mTS + p*volume

        # Gibbs(V; T, p) minimization nPress*nTempt list
        self.volume = np.zeros([len(self.pressure), len(self.temperature)])
        v_init = np.mean(self.combined_volume)

        zp = 0. # analytical expression of U
        wt = self.qpoint[:, 3] / np.sum(self.qpoint[:, 3])
        for iq in range(self.nqpoint):
            zp += wt[iq] * 0.5 * molh * np.sum([self.freq_fit[iq][im] for im in range(self.nmode)])

        for idx_p, p in enumerate(self.pressure):
            for idx_t, t in enumerate(self.temperature):
                params = {'minimize': minimize,
                          'gibbs_opt': gibbs_opt,
                          'v_init': v_init,
                          't': t,
                          'p': p,
                          'obj' : self,
                          'zp' : zp,
                          'wt' : wt,
                          'kBt' : t*molk*1e-3,
                          'volume_bound': volume_bound}
                exec(methods[min_method], params)
                self.volume[idx_p, idx_t] = params['vol'].x[0]

                if (params['vol'].x[0] < min(self.combined_volume) or params['vol'].x[0] > max(self.combined_volume)) and not mutewarning:
                    warn('Optimized volume exceeds the sampled range. Special care should be taken of.\n  Volume: %12.4f, Temperature: %6.2f, Pressure: %6.2f\n'
                         % (params['vol'].x[0], t, p), stacklevel=2)

        self.helmholtz = np.zeros(self.volume.shape)
        self.gibbs = np.zeros(self.volume.shape)
        self.entropy = np.zeros(self.volume.shape)
        self.c_v = np.zeros(self.volume.shape)

        filterwarnings("ignore", 'MORE THAN 3 IMAGINARY MODES!')
        symm = self.combined_symm[:, :, 0]
        # empty eigenvector
        eigvt = np.array([[[[] for j in range(self.natom)] for k in range(self.nmode)] for l in range(self.nqpoint)])
        for idx_p, p in enumerate(self.pressure):
            for idx_t, t in enumerate(self.temperature):
                vol = self.volume[idx_p, idx_t]
                num_freq = np.zeros([self.nqpoint, self.nmode])
                dvol = vol - self.combined_volume[0]
                for iq in range(self.nqpoint):
                    for im in range(self.nmode):
                        num_freq[iq, im] = self.freq_fit[iq][im](dvol)
                ha = Harmonic(temperature=t, pressure=p).from_frequency(
                    self.u0_fit(vol), self.qpoint, num_freq, eigvt, symm,
                    natom=self.natom, volume=vol
                ).thermodynamics()
                self.helmholtz[idx_p, idx_t] = ha.helmholtz[0]
                self.gibbs[idx_p, idx_t] = ha.gibbs[0, 0]
                self.entropy[idx_p, idx_t] = ha.entropy[0]
                self.c_v[idx_p, idx_t] = ha.c_v[0]

        # Fit equation of states for K_T.
        self.eos = []; self.k_t = np.zeros(self.volume.shape)
        v = symbols('v')
        for idx_t, i in enumerate(self.temperature):
            eos = self.eos_fit(self.volume[:, idx_t], self.helmholtz[:, idx_t], self.eos_method, **eosinp)
            df = diff(eos(v), v, 2)
            lam_df = lambdify(v, df, 'numpy')
            self.k_t[:, idx_t] = self.volume[:, idx_t] * lam_df(self.volume[:, idx_t]) / molpv
            self.eos.append(eos)

        # Get mode-specific and macroscopic Grüneisen parameter
        self.gruneisen = np.zeros(self.volume.shape)

        iT = np.where(self.temperature>1e-4)[0]
        vol = self.volume[:, iT]
        dvol = vol - self.combined_volume[0]
        kBT = molk * self.temperature[iT] # J/mol
        weight = self.qpoint[:, 3] / np.sum(self.qpoint[:, 3])
        for iq in range(self.nqpoint):
            wt = weight[iq]
            for im in range(self.nmode):
                gru = np.zeros(vol.shape)
                poly = self.freq_fit[iq][im]
                freq = poly(dvol)
                irow, icol = np.where(freq>1e-4)
                gru[irow, icol] = -vol[irow, icol]/freq[irow, icol] * poly.deriv(1)(dvol[irow, icol]) # nP*nT

                beta = freq*molh*1e12 / np.repeat(kBT[np.newaxis, :], len(self.pressure), axis=0) # nP*nT
                exp = np.exp(beta)
                c_v = np.zeros(vol.shape)
                c_v[irow, icol] = beta[irow, icol]**2 * molk / (exp[irow, icol] - 2 + 1/exp[irow, icol])
                self.gruneisen[:, iT] += wt * gru*c_v
        self.gruneisen[:, iT] =  self.gruneisen[:, iT] / self.c_v[:, iT]

        self.alpha_v = (self.c_v*self.gruneisen*1e-3) / (self.k_t*self.volume*molpv)
        self.c_p = self.c_v + self.alpha_v**2 * (self.k_t*self.volume*molpv) * self.temperature * 1e3
        self.k_s = np.zeros(self.volume.shape) + self.k_t
        self.k_s[:, iT] += self.k_t[:, iT] \
                         * (self.alpha_v[:, iT]**2 * self.temperature[iT] * self.volume[:, iT]*self.k_t[:, iT]*molpv) \
                         / (self.c_v[:, iT]*1e-3)

        # Deprecated attributes and methods
        self.e0_eos = self.u0_fit
        self.e0_eos_method = self.eos_method
        if self.filefmt=='yaml':
            ThermoQHA.write_thermo_freq(self, r2tot, r2avg, min_method, volume_bound)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_thermo_freq(self, min_method, volume_bound)
        return self


    def thermo_gruneisen(self, eos_method='birch_murnaghan', min_method='BFGS',
                         volume_bound=None, mutewarning=False, **kwargs):
        """
        Obtain thermodynamic properties by Grüneisen parameters.

        The pressure and temperature independent mode-specific Grüneisen parameters are obtained by:

        .. math::

            \\gamma_{\\textbf{q}i}=-\\frac{\\ln{\\omega}-\\ln{\\omega_{0}}}{\\ln{V}-\\ln{V_{0}}}

        :math:`V_{0}` is the most compact structure sampled. Frequency at given
        volume can be expressed analytically by:

        .. math::

            \\omega_{\\textbf{q}i}(V) = \\omega_{\\textbf{q}i}(V_{0})\\left(\\frac{V}{V_{0}}\\right)^{-\\gamma_{\\textbf{q}i}}

        Then the Gibbs free energy is minimized in the same way as ``thermo_freq()``.

        The macroscopic Grüneisen parameter is defined as:

        .. math::

            \\gamma=\\sum_{\\textbf{q}i}\\frac{\\gamma_{\\textbf{q}i}C_{V,\\textbf{q}i}}{C_{V}}

        Thermal expansion coefficient in Grüneisen model:

        .. math::

            \\alpha_{V}^{gru}=\\frac{\\gamma C_{V}}{K_{T}V}

        Therefore this method does not require polynomial fittings of
        volume-temperature for expansion rate, adiabatic bulk modulus and
        constant pressure specific heat.

        Args:
            eos_method (str): EOS used to fit DFT total energy and Helmholtz
                free energy (to get bulk modules). Valid entries are consistent
                with `PyMatGen eos module <https://pymatgen.org/pymatgen.analysis.html#module-pymatgen.analysis.eos>`_.
            min_method (string): Minimisation algorithms, 'BFGS'/'L-BFGS-B'.
                See ``thermo_freq()``.
            volume_bound (tuple-like), Boundary conditions of equilibrium
                volumes. Unit: :math:`\\AA^{3}`
            mutewarning (bool): Whether print out warning messages.
            \*\*kwargs: See below
            temperature (array[float]): Should be given in ascending order, or will be sorted. Unit: K
            pressure (array[float]): Should be given in ascending order, or will be sorted. Unit: GPa
            order (int): For DeltaFactor / Polynomial EOSs.
            min_ndata_factor, max_poly_order_factor, min_poly_order_factor (int):
                For Numerical EOS.
        Returns:
            self (Quasi_harmonic): New Attributes listed below
            self.temperature (array): Unit: K
            self.pressure (array): Unit: GPa
            self.volume (array): nPressure\*nTemperature, same below. Equilibrium volumes. Unit: :math:`\\AA^{3}`
            self.helmholtz (array): Helmholtz free energy. Unit: kJ/mol
            self.gibbs (array): Gibbs free energy. Unit: kJ/mol
            self.entropy (array): Entropy. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.gruneisen(array): npressure\*ntemperature, same below. Macroscopic Grüneisen parameter.
            self.alpha_v (array): Thermal expansion coefficient by Grüneisen method.
            self.c_v (array): Constant volume specific heat. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.c_p (array): Constant pressure specific heat by Grüneisen method. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.k_t (array): Isothermal bulk modulus. Unit: GPa.
            self.k_s (array): Adiabatic bulk modulus by Grüneisen method. Unit: GPa.
            self.eos_method (str): Name of the EOS.
            self.u0_fit (Pymatgen EOS): EOS used to fit DFT energy.
            self.eos (list[Pymatgen EOS]): Pymatgen EOS objects. EOS used to fit Helmholtz free energy.
            self.alpha_vgru: Deprecated. Synonym of 'self.alpha_v'.
            self.c_pgru: Deprecated. Synonym of 'self.c_p'.
            self.k_sgru: Deprecated. Synonym of 'self.k_s'.
        """
        # Sanity check
        if self.ncalc < 2: raise Exception('Insufficient database. Increase HA phonons')
        if self._mode_sorted == False: raise Exception('Vibrational modes must be sorted with their eigenvectors.')

        if self.method != 'thermo_gruneisen': refit = True
        else: refit = False

        # Temperature and pressure
        if 'temperature' in kwargs:
            if len(self.temperature)>0 and (mutewarning == False or refit == False):
                warn('Temperature attribute exists. Input temperatures will be used to update the attribute.', stacklevel=2)
            self.temperature = np.array(kwargs['temperature'], dtype=float, ndmin=1)
            refit = True
        if 'pressure' in kwargs:
            if len(self.pressure)>0 and (mutewarning == False or refit == False):
                warn('Pressure attribute exists. Input pressures will be used to update the attribute.', stacklevel=2)
            self.pressure = np.array(kwargs['pressure'], dtype=float, ndmin=1)
            refit = True
        if len(self.temperature)==0 or len(self.pressure)==0:
            raise Exception('Temperature and pressure should be specified.')

        self.temperature.sort(); self.pressure.sort()

        # eos
        if hasattr(self, 'eos_method'):
            if self.eos_method != eos_method: refit = True
        else:
            refit = True

        # Min_method
        if hasattr(self, 'min_method'):
            if self.min_method != min_method: refit = True
        else:
            refit = True

        # Other args
        if np.all(volume_bound!=None) or 'order' in kwargs.keys() \
        or 'min_ndata_factor' in kwargs.keys() or 'max_poly_order_factor' in kwargs.keys() \
        or 'min_poly_order' in kwargs.keys(): refit = True

        if refit == False:
            warnings.warn('Nothing to re-fit. Return to the same object.', stacklevel=2)
            return self

        # Fit DFT total energy. Fitted values will not be covered.
        if self.method == 'thermo_gruneisen' and hasattr(self, 'eos'):
            pass
        else:
            eosinp = {}; eos_method = eos_method.lower()
            for i in ['min_ndata_factor', 'max_poly_order_factor', 'min_poly_order_factor ']:
                if i in kwargs.keys(): eosinp[i] = kwargs[i]
            self.u0_fit = self.eos_fit(self.combined_volume, self.combined_u0, eos_method, **eosinp)
            self.eos_method = eos_method

        # Fit gruneisen parameters, Fitted values will not be covered.
        if self.method == 'thermo_gruneisen' and len(self.gru_fit)>0:
            r2tot = [['unknown' for i in range(qha.nmode)] for j in range(qha.nqpoint)]
            r2avg='Not available for restarted calculations.'
        else:
            r2tot, r2avg = self.freq_gruneisen_fit()
            r2tot = [[float(j) for j in i] for i in r2tot]
            r2avg = float(r2avg)

        # Minimization
        self._clean_thermoprop()
        self.method = 'thermo_gruneisen'
        self.min_method = min_method
        methods = {
            'BFGS': "vol = minimize(gibbs_opt, v_init, args=(t, p, obj, wt, kBt), method='BFGS', jac='3-point')",
            'L-BFGS-B': "vol = minimize(gibbs_opt, v_init, args=(t, p, obj, wt, kBt), method='L-BFGS-B', jac='3-point', bounds=volume_bound)",
        }

        # Expression of Gibbs free energy
        def gibbs_opt(volume, t, p, obj, wt, kBt):
            volume = volume[0]
            v_by_v0 = volume / obj.combined_volume[0]

            mTS = 0.; zp = 0.
            if t > 1e-4:
                for iq in range(obj.nqpoint):
                    omega0 = obj.combined_freq[iq, :, 0]
                    freq = np.array(omega0 * v_by_v0**-self.gru_fit[iq])
                    beta = molh*freq[np.where(freq>1e-4)[0]]*1e9 / kBt
                    mTS += wt[iq] * kBt * np.sum(np.log(1 - np.exp(-beta)))
                    zp += wt[iq] * np.sum(0.5 * molh * freq)
            return obj.u0_fit(volume) + zp + mTS + p*volume

        # Gibbs(V; T, p) minimization nPress*nTempt list
        self.volume = np.zeros([len(self.pressure), len(self.temperature)])
        v_init = np.mean(self.combined_volume)

        wt = self.qpoint[:, 3] / np.sum(self.qpoint[:, 3])
        for idx_p, p in enumerate(self.pressure):
            for idx_t, t in enumerate(self.temperature):
                params = {'minimize': minimize,
                          'gibbs_opt': gibbs_opt,
                          'v_init': v_init,
                          't': t,
                          'p': p,
                          'obj' : self,
                          'wt' : wt,
                          'kBt' : t*molk*1e-3,
                          'volume_bound': volume_bound}
                exec(methods[min_method], params)
                self.volume[idx_p, idx_t] = params['vol'].x[0]

                if (params['vol'].x[0] < min(self.combined_volume) or params['vol'].x[0] > max(self.combined_volume)) and not mutewarning:
                    warn('Optimized volume exceeds the sampled range. Special care should be taken of.\n  Volume: %12.4f, Temperature: %6.2f, Pressure: %6.2f\n'
                         % (params['vol'].x[0], t, p), stacklevel=2)

        self.helmholtz = np.zeros(self.volume.shape)
        self.gibbs = np.zeros(self.volume.shape)
        self.entropy = np.zeros(self.volume.shape)
        self.c_v = np.zeros(self.volume.shape)
        # Macroscopic Gruneisen parameters
        self.gruneisen = np.zeros(self.volume.shape)

        filterwarnings("ignore", 'MORE THAN 3 IMAGINARY MODES!')
        symm = self.combined_symm[:, :, 0]
        omega0 = self.combined_freq[:, :, 0]
        # empty eigenvector
        eigvt = np.array([[[[] for j in range(self.natom)] for k in range(self.nmode)] for l in range(self.nqpoint)])
        for idx_p, p in enumerate(self.pressure):
            for idx_t, t in enumerate(self.temperature):
                vol = self.volume[idx_p, idx_t]
                v_by_v0 = vol / self.combined_volume[0]
                num_freq = omega0 * v_by_v0**-self.gru_fit
                ha = Harmonic(temperature=t, pressure=p).from_frequency(
                    self.u0_fit(vol), self.qpoint, num_freq, eigvt, symm,
                    natom=self.natom, volume=vol
                ).thermodynamics()
                self.helmholtz[idx_p, idx_t] = ha.helmholtz[0]
                self.gibbs[idx_p, idx_t] = ha.gibbs[0, 0]
                self.entropy[idx_p, idx_t] = ha.entropy[0]
                self.c_v[idx_p, idx_t] = ha.c_v[0]
                # Gruneisen
                if t > 1e-4:
                    kBT = molk * t * 1e-3 # kJ/mol
                    irow, icol = np.where(num_freq>1e-4)
                    hbar_freq = num_freq[irow, icol] * molh * 1e9 # kJ/mol, nQ*nM
                    gru = self.gru_fit[irow, icol]
                    beta = hbar_freq / kBT
                    exp = np.exp(beta)
                    self.gruneisen[idx_p, idx_t] = np.sum((beta**2 * molk / (exp - 2 + 1/exp)) * gru)

        iT = np.where(self.temperature>1e-4)[0]
        self.gruneisen[:, iT] /= self.c_v[:, iT]

        # Fit equation of states for K_T.
        self.eos = []; self.k_t = np.zeros(self.volume.shape)
        v = symbols('v')
        for idx_t, i in enumerate(self.temperature):
            eos = self.eos_fit(self.volume[:, idx_t], self.helmholtz[:, idx_t], self.eos_method, **eosinp)
            df = diff(eos(v), v, 2)
            lam_df = lambdify(v, df, 'numpy')
            self.k_t[:, idx_t] = self.volume[:, idx_t] * lam_df(self.volume[:, idx_t]) / molpv
            self.eos.append(eos)

        # Other thermodynamic functions
        self.alpha_v = (self.c_v*self.gruneisen*1e-3) / (self.k_t*self.volume*molpv)
        self.c_p = self.c_v + self.alpha_v**2 * (self.k_t*self.volume*molpv) * self.temperature * 1e3
        self.k_s = np.zeros(self.volume.shape) + self.k_t
        self.k_s[:, iT] += self.k_t[:, iT] \
                         * (self.alpha_v[:, iT]**2 * self.temperature[iT] * self.volume[:, iT]*self.k_t[:, iT]*molpv) \
                         / (self.c_v[:, iT]*1e-3)

        # Deprecated attributes and methods
        self.alpha_vgru = self.alpha_v
        self.c_pgru = self.c_p
        self.k_sgru = self.k_s
        if self.filefmt=='yaml':
            ThermoQHA.write_thermo_gru(self, r2tot, r2avg, min_method, volume_bound)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_thermo_gru(self, min_method, volume_bound)
        return self


    def thermo_eos(self, eos_method='birch_murnaghan', poly_order=[3, 4],
                   min_method='BFGS', volume_bound=None, mutewarning=False,
                   **kwargs):
        """
        Obtain thermodynamic properties by fitting EOS, which is fitted by the
        Helmholtz free energies of sampled harmonic phonons. The explicit
        sorting and fitting of frequency-volume relationship is disabled.

        The equilibrium volume is fitted by minimizing the difference between
        analytical pressure and the given pressure at constant temperature.

        .. math::

            V(T,p_{0})=\\text{min}\\left[
                -\\left(
                    \\frac{\\partial F(V)}{\\partial V}
                \\right)_{T} - p_{0}
            \\right]^{2}

        Parameterized and tested algorithms for ``min_method``:

        * BFGS(no boundary)  
        * L-BFGS-B(with boundary)

        Entropy is obtained by taking the derivative of Gibbs free energy at
        constant pressure.

        .. math::

            S=-\\left(\\frac{\\partial G}{\\partial T}\\right)_{p}

        Constant pressure specific heat is obtained by taking the second
        derivative of :math:`G`.

        .. math::

            C_{p}=-T\\left(\\frac{\\partial^{2}G}{\\partial T^{2}}\\right)_{p}

        :math:`G(T)` is fitted as polynomial specified by ``poly_order``. The
        first order is forced to be 0 to ensure :math:`S=0` at 0 K.

        .. note::

            For a good fitting of :math:`G(T)`, entropy and c_p, the number of
            temperatures must >= 5. ``poly_order`` must > 2.

        Args:
            eos_method (str): EOS used to fit DFT total energy and Helmholtz
                free energy (to get bulk modules). Valid entries are consistent
                with `PyMatGen eos module <https://pymatgen.org/pymatgen.analysis.html#module-pymatgen.analysis.eos>`_.
            poly_order (array[int]): The order of polynomials used to fit
                Gibbs free energy as the function of volumes.
            min_method (string, optional): Minimisation algorithms, 'BFGS'/'L-BFGS-B'.
                See above.
            volume_bound (tuple-like), Boundary conditions of equilibrium
                volumes. Unit: :math:`\\AA^{3}`
            mutewarning (bool): Whether print out warning messages.
            \*\*kwargs: See below
            temperature (array[float]): Unit: K
            pressure (array[float]): Unit: GPa
            order (int): For DeltaFactor / Polynomial EOSs.
            min_ndata_factor, max_poly_order_factor, min_poly_order_factor (int):
                For Numerical EOS.
        Returns:
            self (Quasi_harmonic): New attributes listed below
            self.method (str): 'thermo_eos'
            self.temperature (array): Should be given in ascending order, or will be sorted. Unit: K
            self.pressure (array): Should be given in ascending order, or will be sorted. Unit: GPa
            self.volume (array): nPressure\*nTemperature, same below. Equilibrium volumes. Unit: :math:`\\AA^{3}`
            self.helmholtz (array): Helmholtz free energy. Unit: kJ/mol
            self.gibbs (array): Gibbs free energy. Unit: kJ/mol
            self.entropy (array): Entropy. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.c_p (array): Constant pressure specific heat. Unit: :math:`J.mol^{-1}.K^{-1}`
            self.k_t (array): Isothermal bulk modulus. Unit: GPa.
            self.eos (list[Pymatgen EOS]): nTemperature\*1 list of Pymatgen EOS objects. EOSs used to fit HA free energy at constant temperature.
            self.eos_method (str): The name of EOS used.
            self.gibbs_fit (list[Polynomial]): nPressure list of Polynomials of fitted Gibbs free energy, for entropy and c_p.
            self.fe_eos: Deprecated. Synonym of 'self.eos'.
            self.fe_eos_method: Deprecated. Synonym of 'self.fe_eos_method'.

        :raise Exception: If the number of HA calculations is less than 4.
        :raise Exception: If temperature or pressure is defined neither here nor during initialization.
        """
        # Sanity check
        if self.ncalc < 4: raise Exception('Insufficient database. Increase HA phonons')

        if self.method != 'thermo_eos': refit = True
        else: refit = False

        # Temperature and pressure
        if 'temperature' in kwargs:
            if len(self.temperature)>0 and (mutewarning == False or refit == False):
                warn('Temperature exists. Using new temperatures will update all the fittings if present.', stacklevel=2)
            self.temperature = np.array(kwargs['temperature'], dtype=float, ndmin=1)
            refit = True
        if 'pressure' in kwargs:
            if len(self.pressure)>0 and (mutewarning == False or refit == False):
                warn('Pressure exists. Using new pressures will update all the fittings if present.', stacklevel=2)
            self.pressure = np.array(kwargs['pressure'], dtype=float, ndmin=1)
            refit = True
        if len(self.temperature)==0 or len(self.pressure)==0:
            raise Exception('Temperature and pressure should be specified.')

        if len(self.temperature) < 5:
            raise Exception("At least 5 temperatures are required")

        self.temperature.sort(); self.pressure.sort()

        # eos
        if hasattr(self, 'eos_method'):
            if self.eos_method != eos_method: refit = True
        else:
            refit = True

        # polynomial, at least 1 redundant data points
        poly_order = np.unique(np.array(poly_order, dtype=int, ndmin=1))
        poly_order = poly_order[np.where((poly_order<len(self.temperature))&(poly_order>2))[0]]
        if len(poly_order) == 0:
            raise Exception('At least a cubic polynomial and order+1 temperatures are needed for polynomial fitting.')
        if hasattr(self, 'fit_order'):
            for i in poly_order:
                if i not in self.fit_order: refit = True; break
        else:
            refit = True

        # Min_method
        if hasattr(self, 'min_method'):
            if self.min_method != min_method: refit = True
        else:
            refit = True

        # Other args
        if np.all(volume_bound!=None) or 'order' in kwargs.keys() \
        or 'min_ndata_factor' in kwargs.keys() or 'max_poly_order_factor' in kwargs.keys() \
        or 'min_poly_order' in kwargs.keys(): refit = True

        if refit == False:
            warnings.warn('Nothing to re-fit. Return to the same object.', stacklevel=2)
            return self

        # Fit EOS
        self._clean_thermoprop()
        self.method = 'thermo_eos'
        self.fit_order = poly_order
        helmholtz = np.zeros([len(self.temperature), self.ncalc], dtype=float)
        # empty eigenvector
        eigvt = np.array([[[[] for j in range(self.natom)] for k in range(self.nmode)] for l in range(self.nqpoint)])
        for idx_c in range(self.ncalc):
            ha = Harmonic().from_frequency(self.combined_u0[idx_c],
                                           self.qpoint,
                                           self.combined_freq[:, :, idx_c],
                                           eigvt,
                                           self.combined_symm[:, :, idx_c],
                                           natom=self.natom,
                                           volume=self.combined_volume[idx_c])
            ha.thermodynamics(temperature=self.temperature, pressure=[0.])
            helmholtz[:, idx_c] = ha.helmholtz

        eos_method = eos_method.lower()
        self.eos_method = eos_method
        self.eos = []
        eosinp = {}
        for i in ['min_ndata_factor', 'max_poly_order_factor', 'min_poly_order_factor ']:
            if i in kwargs.keys(): eosinp[i] = kwargs[i]
        for it, t in enumerate(self.temperature):
            self.eos.append(
                self.eos_fit(self.combined_volume, helmholtz[it, :], eos_method, **eosinp)
            )

        # Get thermoproperties
        self.volume = np.zeros([len(self.pressure), len(self.temperature)])
        self.helmholtz = np.zeros(self.volume.shape)
        self.gibbs = np.zeros(self.volume.shape)
        self.entropy = np.zeros(self.volume.shape)
        self.c_p = np.zeros(self.volume.shape)
        self.k_t = np.zeros(self.volume.shape)
        v = symbols('v')
        if np.all(volume_bound==None):
            minp = {'method':'BFGS', 'jac':'3-point'}
        else:
            minp = {'method':'L-BFGS-B', 'jac':'3-point', 'bounds':volume_bound}
        for it, eos in enumerate(self.eos):
            p_eos = -diff(eos(v), v, 1)
            for ip, p in enumerate(self.pressure):
                p_kj = p * Avogadro / 1e24  # GPa --> kJ/mol.Angstrom^3
                lam_p = lambdify(v, (p_eos - p_kj)**2, 'numpy')
                fit = minimize(lam_p, eos.v0, **minp)
                if fit.success == False:
                    raise Exception('EOS fitting failed at %6.2f K, %6.2f GPa. More sampling points needed.' % (self.temperature[idx_t], p))
                if (fit.x[0] < min(self.combined_volume) or fit.x[0] > max(self.combined_volume)) and not mutewarning:
                    warn('Optimized volume exceeds the sampled range. Special care should be taken of.\n  Volume: %12.4f, Temperature: %6.2f, Pressure: %6.2f\n'
                         % (fit.x[0], self.temperature[it], p), stacklevel=2)
                self.volume[ip, it] = fit.x[0]
                self.helmholtz[ip, it] = eos(fit.x[0])
                self.gibbs[ip, it] = eos(fit.x[0]) + p_kj * fit.x[0]

            second = lambdify(v, diff(eos(v), v, 2), 'numpy')
            self.k_t[:, it] = self.volume[:, it] * second(self.volume[:, it]) / molpv

        # Second fit G(T; p), get entropy and C_p.
        self.gibbs_fit = []; r2tot = []
        dT = self.temperature - self.temperature[0]
        ## Fix S(0K) = 0
        if self.temperature[0] < 1e-4: fix0K = True
        else: fix0K = False

        for ip, gb in enumerate(self.gibbs):
            allr2 = []; allfunc = []
            dgb = gb - gb[0]
            for o in poly_order:
                deg = [i+1 for i in range(o)]
                if fix0K == True: deg = deg[1:]
                coef, lst = polyfit(dT, dgb, deg=deg, full=True)
                poly = Polynomial(coef)
                allr2.append(1 - lst[0][0]/np.sum((dgb - np.mean(dgb))**2))
                allfunc.append(poly+gb[0])
            idx = np.argmax(allr2)
            self.gibbs_fit.append(allfunc[idx])
            r2tot.append(allr2[idx])
        r2tot = np.array(r2tot)
        r2avg = np.mean(r2tot)

        for ip in range(self.pressure.shape[0]):
            func = self.gibbs_fit[ip]
            entropy = func.deriv(1)
            self.entropy[ip, :] = -entropy(self.temperature) * 1000.
            c_p = func.deriv(2)
            self.c_p[ip, :] = -c_p(self.temperature) * 1000 * self.temperature

        # Deprecated attributes and methods
        self.fe_eos_method = self.eos_method
        self.fe_eos = self.eos
        if self.filefmt=='yaml':
            ThermoQHA.write_thermo_eos(self, r2tot.tolist(), float(r2avg), min_method, volume_bound)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_thermo_eos(self)
        return self


    def expansion_vol(self, poly_order=[2, 3], plot=True, fit_fig='expansion_fit.png'):
        """
        Fit the thermal expansion curve as polynomials and get thermal expansion
        coefficients at equilibrium volumes.

        The volumetric thermal expansion coefficient at constant pressure:

        .. math::

            \\alpha_{V}(T) = \\frac{1}{V(T)}\\left(\\frac{\\partial V(T)}{\\partial T}\\right)_{p}

        ``thermo_freq()`` and ``thermo_gruneisen()`` methods have fitted thermal
        expansion with Grüneisen model. Calling this will overwrite the fittings.

        .. note::

            For a good fitting. ``poly_order`` must be no smaller than 2. The
            length of ``self.temperature`` must no smaller than ``poly_order+1``.

        Args:
            poly_order (list[int]): Order of polynomials.
            plot (bool): Plot V-T curves to examine the goodness of fitting. The
                order with the largest :math:`R^{2}` is automatically selected.
            fit_fig (str): File name for the fitting plot.

        Returns:
            self (Quasi_harmonic): New attributes listed below
            self.vol_fit (list): 1\*nPressure. List of Numpy polynomial object, the fitted volume V(T).
            self.alpha_v (array): nPressure\*nTemperature. Expansion coefficients at equilibrium volumes.
        """
        from matplotlib.pyplot import subplots
        from matplotlib.colors import TABLEAU_COLORS as mcolors

        # Sanity check
        if not hasattr(self, 'volume'):
            raise Exception('Equilibrium volume should be fit first.')
        if hasattr(self, 'alpha_v'):
            warn("The fitted thermal expansion coefficient will be overwritten.", stacklevel=2)

        # polynomial, at least 1 redundant data points
        poly_order = np.unique(np.array(poly_order, dtype=int, ndmin=1))
        poly_order = poly_order[np.where((poly_order<len(self.temperature))&(poly_order>=2))[0]]
        if len(poly_order) == 0:
            raise Exception('At least order+1 calculations are needed for polynomial fitting. Order of polynomials must >= 2.')

        # Polynomial fitting, nPressure
        func = []
        r2tot = []
        dt = self.temperature - self.temperature[0]
        dv = (self.volume.T - self.volume[:, 0].T).T
        ## Force \alpha(0K) = 0
        if self.temperature[0] < 1e-4: fix0K = True
        else: fix0K = False

        for ip, dvp in enumerate(dv):
            func_p = []
            r2_p = []
            for o in poly_order:
                deg = [i+1 for i in range(o)]
                if fix0K == True: deg = deg[1:]
                coef, lst = polyfit(dt, dvp, deg=deg, full=True)
                poly = Polynomial(coef)
                r2_p.append(1 - lst[0][0]/np.sum((dvp - np.mean(dvp))**2))
                func_p.append(poly+self.volume[ip, 0])
            idx = np.argmax(r2_p)
            func.append(func_p[idx])
            r2tot.append(r2_p[idx])
        self.vol_fit = func
        r2tot = np.array(r2tot)
        r2avg = np.mean(r2tot)

        if plot == True:
            fig, ax = subplots(1, 1, figsize=(8, 6))
            clist = list(mcolors.keys())
            mlist = ['P', 'X', 'v', '^', '<', '>', 'o', 'D', 'p', 'h']
            T = np.linspace(self.temperature.min(), self.temperature.max(), 1000)
            dT = T - self.temperature.min()
            for ip, p in enumerate(self.pressure):
                m = mlist[ip % len(mlist)]
                c = clist[ip % len(clist)]
                label = 'p {:.4f} GPa, Order {:d}, R^2 {:.4f}'.format(p, len(func[ip].coef)-1, r2tot[ip])
                ax.plot(T, func[ip](dT), color=c, label=label)
                ax.scatter(self.temperature, self.volume[ip], color='k', marker=m, s=40)
            ax.legend(loc='lower right')
            ax.set_xlabel('Temperature (K)')
            ax.set_ylabel(r'Volume ($\AA^{3}$)')
            fig.savefig(fname=fit_fig, dpi=200)

        # Expansion coefficients
        self.alpha_v = np.zeros([len(self.pressure), len(self.temperature)])
        dT = self.temperature - self.temperature.min()
        for idx_p, v_p in enumerate(self.volume):
            self.alpha_v[idx_p, :] = self.vol_fit[idx_p].deriv(1)(dT) / self.volume[idx_p]

        # Deprecated attributes and methods
        if self.filefmt=='yaml':
            ThermoQHA.write_expansion_vol(self, poly_order, r2tot.tolist(), float(r2avg))
        elif self.filefmt=='txt':
            ThermoQHA.old_write_expansion_vol(self, r2tot, r2avg)
        return self


    def bulk_modulus(self, **kwargs):
        """
        Calculate isothermal and adiabatic bulk moduli at equilibrium volumes.

        The following equation is used:

        .. math::

            K_{S} = K_{T} + \\frac{\\alpha^{2}_{V}VTK^{2}_{T}}{C_{V}}

        .. note::

            * With ``thermo_eos()``, must call ``expansion_vol()`` first.
            * With ``thermo_freq()`` and ``thermo_gruneisen()``, unless the
                ``expansion_vol()`` has been called, it will not change the
                results.

        Args:
            \*\*kwargs: Only functions as a container of deprecated keywords. Not used.
        Returns:
            self (Quasi_harmonic): New attributes listed below
            self.k_t (array): Isothermal bulk modulus. Unit: GPa.
            self.k_s (array): nPressure\*nTemperature. Adiabatic bulk modulus. Unit: GPa.
        """
        # Sanity check
        if not hasattr(self, 'alpha_v'):
            raise AttributeError('Expansion coefficient should be fit at first.')
        if hasattr(self, 'k_s'):
            warn("Attributes 'k_s' exists, the fitting will be overwritten.", stacklevel=2)

        self.k_s = np.zeros(self.k_t.shape) + self.k_t
        if not hasattr(self, 'c_v'): self.specific_heat()

        iT = np.where(self.temperature > 1e-4)[0] # > 0K
        self.k_s[:, iT] += self.k_t[:, iT] \
                         * (self.alpha_v[:, iT]**2 * self.temperature[iT] * self.volume[:, iT]*self.k_t[:, iT]*molpv) \
                         / (self.c_v[:, iT]*1e-3)

        # Deprecated attributes and methods
        if self.filefmt=='yaml':
            ThermoQHA.write_bulk_modulus(self)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_bulk_modulus(self, adiabatic)
        return self


    def specific_heat(self):
        """
        Calculate constant volume or pressure specific heat at equilibrium volumes.

        The following equation is used:

        .. math::

            C_{p} - C_{V} = \\alpha_{V}^{2}K_{T}VT

        .. note::

            * With ``thermo_eos()``, must call ``expansion_vol()`` first.
            * With ``thermo_freq()`` and ``thermo_gruneisen()``, unless the
                ``expansion_vol()`` has been called, it will not change the
                results.

        Returns:
            self (Quasi_harmonic): New attributes listed below
            self.c_v (array): nPressure\*nTemperature. Constant volume specific heat. Unit: J/mol/K
            self.c_p (array): nPressure\*nTemperature. Constant pressure specific heat. Unit: J/mol/K.
        """
        # Sanity check
        if not hasattr(self, 'alpha_v'):
            raise AttributeError('Expansion coefficient should be fit at first.')

        if not hasattr(self, 'c_p'): # thermo_freq
            self.c_p = self.c_v + self.alpha_v**2 * self.k_t * self.volume * self.temperature * molpv*1000
        elif not hasattr(self, 'c_v'): # thermo_eos
            self.c_v = self.c_p - self.alpha_v**2 * self.k_t * self.volume * self.temperature * molpv*1000
        else:
            warn("Attributes 'c_v' and 'c_p' both exist. The fitting will be overwritten.", stacklevel=2)

        # Deprecated attributes and methods
        if self.filefmt=='yaml':
            ThermoQHA.write_specific_heat(self)
        elif self.filefmt=='txt':
            ThermoQHA.old_write_specific_heat(self, adiabatic)
        return self


    def lattice_poly(self, poly_order=[2,3], interp=0):
        """Fit anisotropic expansions, i.e., lattice parameters, by polynomial
        fitting lattice parameters with repect to volume. (:math:`V^{1/3}` is used.)
        More robust than ``thermo_hess()``.

        Lattice will be expanded and aligned to the standard conventional cell.
        Volume constrain is applied. Minimum HA references: ``poly_order+2``.

        .. note::

            Use ``interp`` to linearly interpolate reference geometries and
            insert reference Gibbs free energies. Only available to objects
            generated by ``thermo_freq()`` and ``thermo_gruneisen()``.
            ``interp`` must less than ``self.ncalc``.

        Currently only the fitted ``self.lattice`` can be read from dump file.

        Args:
            poly_order (list[int]): The order of polynomials used to fit lattice
                parameters as function of volumes.
            interp (int): Number of interpolated HA calculations.
        Returns:
            self: New attribute listed below.
            self.sg (int): International space group number.
            self.lattice (array): nPress\*nTempt\*3\*3 lattice matrix at given
                temperature and pressure. Standard conventional cell is used.
            self.latt_params (array): nPress\*nTempt\*nLatt minimal set of
                lattice parameters. The standard conventional cell is used.
        """
        # Sainity check
        if not hasattr(self, 'volume'):
            raise Exception('Equilibrium volumes should be fit first.')
        if interp == None: interp = 0 # Compatibility
        if interp != 0 and self.method == 'thermo_eos':
            warn("'Thermo_eos()' method does not allow interpolation.", stacklevel=2)
            interp = 0
        if hasattr(self, 'lattice'): warn("The fitted lattice parameters will be overwritten.", stacklevel=2)

        poly_order = np.unique(np.array(poly_order, dtype=int, ndmin=1))
        poly_order = poly_order[np.where((poly_order<self.ncalc)&(poly_order>0))[0]]
        if len(poly_order) == 0:
            raise Exception('At least order+1 phonon calculations are needed.')

        # Reference data
        sg, vscale, rot, lmx, _ = self._interp_HA(interp, False)

        # Independent lattice parameters.
        ## iparam: index in lattrice matrix
        ## ltemplate: 3x3 lattice matrix, [index_in_independent_params, factor]
        if sg > 195: # cubic
            cst = (self.volume * vscale)**(1/3)
            self.lattice = np.zeros([self.volume.shape[0], self.volume.shape[1], 3, 3])
            for i in self.volume.shape[0]:
                for j in self.volume.shape[1]:
                    self.lattice[i,j] = np.eye(3)*cst[i,j] @ rot
            return self
        elif sg >= 143 and sg < 195: # hexagonal and trigonal
            iparam = np.array([[0, 0], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[0, -0.5], [0, 0.5*3**0.5], [0, 0]],
                                  [[0, 0], [0, 0], [1, 1]]], dtype=float)
        elif sg >= 75 and sg < 143:  # tetragonal
            iparam = np.array([[0, 0], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[0, 0], [0, 1], [0, 0]],
                                  [[0, 0], [0, 0], [1, 1]]], dtype=float)
        elif sg >= 16 and sg < 75:  # orthorhombic
            iparam = np.array([[0, 0], [1, 1], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[0, 0], [1, 1], [0, 0]],
                                  [[0, 0], [0, 0], [2, 1]]], dtype=float)
        elif sg >= 3 and sg < 16:  # monoclinic
            iparam = np.array([[0, 0], [1, 1], [2, 0], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[0, 0], [1, 1], [0, 0]],
                                  [[2, 1], [0, 0], [3, 1]]], dtype=float)
        else: # triclinic
            iparam = np.array([[0, 0], [1, 0], [1, 1], [2, 0], [2, 1], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[1, 1], [2, 1], [0, 0]],
                                  [[3, 1], [4, 1], [5, 1]]], dtype=float)

        # Fit polynomial and lattice
        v0 = self.combined_volume[0]**(1/3)
        vols = np.array([np.linalg.det(i) for i in lmx], dtype=float)**(1/3)
        iref = np.argsort(vols)
        dv = vols[iref] - v0

        lfit = []; r2tot = []
        for p in iparam[:-1]:
            allr2 = []; allfunc = []
            pref = lmx[iref, p[0], p[1]]
            dp = pref - pref[0]
            for o in poly_order:
                deg = [i+1 for i in range(o)]
                coef, lst = polyfit(dv, dp, deg=deg, full=True)
                poly = Polynomial(coef)
                allr2.append(1 - lst[0][0]/np.sum((dp - np.mean(dp))**2))
                allfunc.append(poly+pref[0])
            idx = np.argmax(allr2)
            lfit.append(allfunc[idx])
            r2tot.append(allr2[idx])
        r2tot = np.array(r2tot)
        r2avg = np.mean(r2tot)

        self.sg = sg
        self.lattice = np.zeros([self.volume.shape[0], self.volume.shape[1], 3, 3])
        for ip, v_p in enumerate(self.volume**(1/3)):
            for it, v in enumerate(v_p):
                latt = []
                for fit in lfit: latt.append(fit(v-v0))

                # Volume constraint for cz
                L = np.zeros([3,3])
                for i in range(2):
                    for j in range(3):
                        L[i, j] = latt[int(ltemplate[i, j, 0])] * ltemplate[i, j, 1]
                for j in range(2):
                    L[2, j] = latt[int(ltemplate[2, j, 0])] * ltemplate[2, j, 1]

                L[2, 2] = v**3 + (L[0,2]*L[1,1] - L[0,1]*L[1,2])*L[2,0] + (L[0,0]*L[1,2] - L[0,2]*L[1,0])*L[2,1]
                L[2, 2] /= (L[0,0]*L[1,1] - L[0,1]*L[1,0])
                self.lattice[ip, it] = L @ rot

        if self.filefmt=='yaml':
            ThermoQHA.write_latt_poly(self, poly_order, interp, lfit, r2tot, r2avg)
        return self


    def lattice_hess(self, interp=0, **kwargs):
        """
        Fit anisotropic expansions, i.e., lattice parameters, by the second-order
        perturbation of Gibbs free energy :math:`G`.

        .. math::

            G(\\mathbf{v})=G_{0}(\\mathbf{v_{0}})+\\Delta\\mathbf{v}\\mathbf{H}\\Delta\\mathbf{v}^{T}

        :math:`\\mathbf{v}` is the row vector of inequivalent lattice parameters.
        :math:`\\mathbf{v_0}` is the row vector of equilibrium lattice parameters.
        :math:`\\Delta\\mathbf{v}` is the difference between :math:`\\mathbf{v_0}`
        and :math:`\\mathbf{v}`. :math:`\\mathbf{H}` is the Hessian matrix.

        .. note::

            Inspired by *Phys. Rev. Mater.*, 2019, **3**, 053605.

        The root-mean-squared deviations (RMSD) between :math:`\\Delta\\mathbf{v}\\mathbf{H}\\Delta\\mathbf{v}^{T}`
        and `G-G_{0}` is minimized at constant temperature and pressure.
        Lattice will be expanded and aligned to the standard conventional cell.

        This method requires a larger number of HA calculations to ensure a
        successful fitting, which depends on the symmetry of the system. Volume
        constrain is applied to reduce one inequivalent lattice parameter, but
        its dimension in :math:`\\mathbf{H}` is kept.

        Minimum HA references:

        * Hexagonal, trigonal and tetragonal: 4  
        * Orthorhombic: 8  
        * Monoclinic: 13  
        * Triclinic: 26

        .. note::

            Use ``interp`` to linearly interpolate reference geometries and
            insert reference Gibbs free energies. Only available  to objects
            generated by ``thermo_freq()`` and ``thermo_gruneisen()``.
            ``interp`` must less than ``self.ncalc``.

        Currently only the fitted ``self.lattice`` can be read from dump file.

        Args:
            interp (int): Number of interpolated HA calculations.
            \*\*kwargs: Passed to `scipy.optimize.minimize() <https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html>`_
                Passed keywords listed below.
            method (str): Default 'BFGS'.
            jac (str): Default '3-point'.
            hess: Scipy default settings.
            hessp: Scipy default settings.
            bounds: Scipy default settings.
            constraints: Scipy default settings.
            tol (float): Default 0.05.
            options: Scipy default settings.
        Returns:
            self: New attribute listed below.
            self.sg (int): International space group number.
            self.lattice (array): nPress\*nTempt\*3\*3 lattice matrix at given
                temperature and pressure. Standard conventional cell is used.
            self.latt_params (array): nPress\*nTempt\*nLatt minimal set of
                lattice parameters. The standard conventional cell is used.
            self.latt_cart (array): nPress\*nTempt\*3 projected lengths of cell
                on Cartesian coordinates. The standard conventional cell is used.
        """
        # Sainity check
        if not hasattr(self, 'volume'):
            raise Exception('Equilibrium volumes should be fit first.')
        if interp == None: interp = 0 # Compatibility
        if interp != 0 and self.method == 'thermo_eos':
            warn("'Thermo_eos()' method does not allow interpolation.", stacklevel=2)
            interp = 0
        if hasattr(self, 'lattice'): warn("The fitted lattice parameters will be overwritten.", stacklevel=2)

        # Reference data
        sg, vscale, rot, lmx, Gibbs = self._interp_HA(interp, True)

        # Independent lattice parameters.
        ## iparam: index in lattrice matrix
        ## ltemplate: 3x3 lattice matrix, [index_in_independent_params, factor]
        if sg > 195: # cubic
            cst = (self.volume * vscale)**(1/3)
            self.lattice = np.zeros([self.volume.shape[0], self.volume.shape[1], 3, 3])
            for i in self.volume.shape[0]:
                for j in self.volume.shape[1]:
                    self.lattice[i,j] = np.eye(3)*cst[i,j] @ rot
            return self
        elif sg >= 143 and sg < 195: # hexagonal and trigonal
            iparam = np.array([[0, 0], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[0, -0.5], [0, 0.5*3**0.5], [0, 0]],
                                  [[0, 0], [0, 0], [1, 1]]], dtype=float)
            init_x0 = np.array([1, 0, 1, 0], dtype=float)
            lenhess = 3
        elif sg >= 75 and sg < 143:  # tetragonal
            iparam = np.array([[0, 0], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[0, 0], [0, 1], [0, 0]],
                                  [[0, 0], [0, 0], [1, 1]]], dtype=float)
            init_x0 = np.array([1, 0, 1, 0], dtype=float)
            lenhess = 3
        elif sg >= 16 and sg < 75:  # orthorhombic
            iparam = np.array([[0, 0], [1, 1], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[0, 0], [1, 1], [0, 0]],
                                  [[0, 0], [0, 0], [2, 1]]], dtype=float)
            init_x0 = np.array([1, 0, 0, 1, 0, 1, 0, 0], dtype=float)
            lenhess = 6
        elif sg >= 3 and sg < 16:  # monoclinic
            iparam = np.array([[0, 0], [1, 1], [2, 0], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[0, 0], [1, 1], [0, 0]],
                                  [[2, 1], [0, 0], [3, 1]]], dtype=float)
            init_x0 = np.array([1, 0, 0, 0,
                                1, 0, 0,
                                1, 0,
                                1,
                                0, 0, 0], dtype=float)
            lenhess = 10
        else: # triclinic
            iparam = np.array([[0, 0], [1, 0], [1, 1], [2, 0], [2, 1], [2, 2]], dtype=int)
            ltemplate = np.array([[[0, 1], [0, 0], [0, 0]],
                                  [[1, 1], [2, 1], [0, 0]],
                                  [[3, 1], [4, 1], [5, 1]]], dtype=float)
            init_x0 = np.array([1, 0, 0, 0, 0, 0,
                                1, 0, 0, 0, 0,
                                1, 0, 0, 0,
                                1, 0, 0,
                                1, 0,
                                1,
                                0, 0, 0, 0, 0], dtype=float)
            lenhess = 21

        # Fit the hessian and eq lattice
        def perturb(x, Lref, dGref):
            H = np.zeros([len(x)-lenhess+1, len(x)-lenhess+1])
            count = 0
            for i in range(H.shape[0]):
                for j in range(i, H.shape[0]):
                    H[i, j] = x[count]
                    H[j, i] = x[count]
                    count += 1
            # Volume constrain applied to cz, the last element
            L = np.zeros([3,3])
            for i in range(2):
                for j in range(3):
                    L[i, j] = x[int(ltemplate[i, j, 0]+lenhess)] * ltemplate[i, j, 1]
            for j in range(2):
                L[2, j] = x[int(ltemplate[2, j, 0]+lenhess)] * ltemplate[2, j, 1]

            L[2, 2] = V0 + (L[0,2]*L[1,1] - L[0,1]*L[1,2])*L[2,0] + (L[0,0]*L[1,2] - L[0,2]*L[1,0])*L[2,1]
            L[2, 2] /= (L[0,0]*L[1,1] - L[0,1]*L[1,0])
            p = L[iparam[:, 0], iparam[:, 1]]
            # Energy difference
            ddG = np.zeros([Lref.shape[0],])
            for i in range(Lref.shape[0]):
                dp = (Lref[i, iparam[:, 0], iparam[:, 1]] - p).reshape([1, -1])
                ddG[i] = dGref[i] - (dp@H@dp.T)[0, 0]
            return (np.sum(ddG**2)/Lref.shape[0])**0.5

        self.sg = sg
        self.lattice = np.zeros([self.volume.shape[0], self.volume.shape[1], 3, 3])
        dG = Gibbs - self.gibbs*vscale
        for i, p in enumerate(iparam[:-1]):
            init_x0[i+lenhess] = np.mean(lmx[:, p[0], p[1]])
        min_inp = dict(method='BFGS', jac='3-point', tol=0.05)
        for key in ['method', 'jac', 'hess', 'hessp', 'bounds', 'constraints', 'tol', 'options']:
            if key in kwargs.keys(): min_inp[key] = kwargs[key]
        r2tot = []

        for ip, p in enumerate(self.pressure):
            x0 = init_x0
            for it, t in enumerate(self.temperature):
                V0 = self.volume[ip, it]
                min_inp['args'] = (lmx, dG[:, ip, it])
                out = minimize(perturb, x0, **min_inp)
                if out.success == False:
                    raise Exception("Linear expansion fitting fails at {:.4f} K, {:.4f} GPa. Message: '{}'.".format(t, p, out.message))

                # Volume constraint for cz
                L = np.zeros([3,3])
                for i in range(2):
                    for j in range(3):
                        L[i, j] = out.x[int(ltemplate[i, j, 0]+lenhess)] * ltemplate[i, j, 1]
                for j in range(2):
                    L[2, j] = out.x[int(ltemplate[2, j, 0]+lenhess)] * ltemplate[2, j, 1]

                L[2, 2] = V0 + (L[0,2]*L[1,1] - L[0,1]*L[1,2])*L[2,0] + (L[0,0]*L[1,2] - L[0,2]*L[1,0])*L[2,1]
                L[2, 2] /= (L[0,0]*L[1,1] - L[0,1]*L[1,0])
                self.lattice[ip, it] = L @ rot

                x0 = out.x
                r2tot.append(1 - lmx.shape[0]*out.fun**2/np.sum((dG[:, ip, it]-np.mean(dG[:, ip, it]))**2))

        r2avg = np.mean(r2tot)
        if self.filefmt=='yaml':
            minarg = {}
            for key in min_inp.keys():
                if key in ['method', 'jac', 'hess']: minarg[key] = str(min_inp[key])
                elif key in ['tol']: minarg[key] = float(min_inp[key])
                elif key in ['bounds']: minarg[key] = min_inp[key].tolist()
                elif key in ['hessp', 'constraints', 'options']: minarg[key] = 'unsaved'
            ThermoQHA.write_latt_hess(self, interp, minarg, len(iparam), r2avg)
        return self


    @property
    def latt_params(self):
        """Generate nPress\*nTempt\*nLattice minimum set of lattice parameters
        from lattice matrices of the standard conventional cell. Callable only
        if the equilibrium lattice parametes are fitted."""
        if not hasattr(self, 'lattice') or not hasattr(self, 'sg'):
            raise Exception("Only callable after 'lattice_*()' fittings.")

        latt = np.zeros([self.lattice.shape[0], self.lattice.shape[1], 6])
        for ip in range(self.lattice.shape[0]):
            for it in range(self.lattice.shape[1]):
                latt[ip, it, 0] = np.linalg.norm(self.lattice[ip, it, 0])
                latt[ip, it, 1] = np.linalg.norm(self.lattice[ip, it, 1])
                latt[ip, it, 2] = np.linalg.norm(self.lattice[ip, it, 2])
                latt[ip, it, 3] = 180/np.pi * np.arccos(np.dot(self.lattice[ip, it, 1], self.lattice[ip, it, 2]) / latt[ip, it, 1] / latt[ip, it, 2])
                latt[ip, it, 4] = 180/np.pi * np.arccos(np.dot(self.lattice[ip, it, 0], self.lattice[ip, it, 2]) / latt[ip, it, 0] / latt[ip, it, 2])
                latt[ip, it, 5] = 180/np.pi * np.arccos(np.dot(self.lattice[ip, it, 0], self.lattice[ip, it, 1]) / latt[ip, it, 0] / latt[ip, it, 1])
        if self.sg > 195: # cubic
            return latt[:, :, 0].reshape([self.lattice.shape[0], self.lattice.shape[1], 1])
        elif self.sg >= 75 and self.sg < 195: # tetragonal, hexagonal and trigonal
            return latt[:, :, [0, 2]]
        elif self.sg >= 16 and self.sg < 75:  # orthorhombic
            return latt[:, :, [0, 1, 2]]
        elif self.sg >= 3 and self.sg < 16:  # monoclinic
            return latt[:, :, [0, 1, 2, 4]]
        else: # triclinic
            return latt


    @property
    def latt_cart(self):
        """Generate nPress\*nTempt\*3 set of projected lengths of cell on
        Cartesian coordinates from lattice matrices of the standard conventional
        cell. Callable only if the equilibrium lattice parametes are fitted."""
        if not hasattr(self, 'lattice'):
            raise Exception("Only callable after 'lattice_*()' fittings.")
        corners = np.array([[i, j, k] for i in [0,1] for j in [0,1] for k in [0,1]])
        length = np.zeros([self.lattice.shape[0], self.lattice.shape[1], 3])
        for ip in range(self.lattice.shape[0]):
            for it in range(self.lattice.shape[1]):
                cart = corners @ self.lattice[ip, it]
                length[ip, it, 0] = cart[:, 0].ptp()
                length[ip, it, 1] = cart[:, 1].ptp()
                length[ip, it, 2] = cart[:, 2].ptp()
        return length


    def expansion_latt(self, poly_order=[2,3], Cartesian=False,
                       plot=True, fit_fig='expansion_latt_{}.png'):
        """
        Fit the thermal expansion curve as polynomials and get linear thermal
        expansion coefficients.

        The linear thermal expansion coefficient at constant pressure:

        .. math::

            \\alpha_{l}(T) = \\frac{1}{l(T)}\\left(\\frac{\\partial l(T)}{\\partial T}\\right)_{p}

        .. note::

            For a good fitting. ``poly_order`` must be no smaller than 2. The
            length of ``self.temperature`` must no smaller than ``poly_order+1``.

        Args:
            poly_order (list[int]): Order of polynomials.
            Cartesian (bool): Fit linear thermal expansion rate with reference to
                Cartesian coordinate. Useful for monoclinic and triclinic systems.
            plot (bool): Plot a-T curves to examine the goodness of fitting. The
                order with the largest :math:`R^{2}` is automatically selected.
            fit_fig (str): File name for the fitting plots. Must include the
                format string for string variables.

        Returns:
            self (Quasi_harmonic): New attributes listed below
            self.latt_fit (list): nPressure\*nLattice. List of Numpy polynomial
                object, the fitted lattice parameters. ``nLattice=3`` if ``Cartesian=True``.
            self.alpha_l (array): nPressure\*nTemperature\*nLattice. Expansion
                coefficients. ``nLattice=3`` if ``Cartesian=True``.
        """
        from matplotlib.pyplot import subplots
        from matplotlib.colors import TABLEAU_COLORS as mcolors

        # Sanity check
        if not hasattr(self, 'lattice'):
            raise Exception('Equilibrium lattice should be fit first.')
        if hasattr(self, 'alpha_l'):
            warn("The fitted thermal expansion coefficients will be overwritten.", stacklevel=2)

        # polynomial, at least 1 redundant data points
        poly_order = np.unique(np.array(poly_order, dtype=int, ndmin=1))
        poly_order = poly_order[np.where((poly_order<len(self.temperature))&(poly_order>=2))[0]]
        if len(poly_order) == 0:
            raise Exception('At least order+1 calculations are needed for polynomial fitting. Order of polynomials must >= 2.')

        dT = self.temperature - self.temperature[0]
        ## Force \alpha(0K) = 0
        if self.temperature[0] < 1e-4: fix0K = True
        else: fix0K = False

        # "Pseudo-lattice parameters"
        npress = len(self.pressure); ntempt = len(self.temperature)
        if Cartesian == True:
            nparam = 3
            L = self.latt_cart
            dL = np.zeros([npress, ntempt, 3])
            for i in range(ntempt):
                dL[:, i, :] = L[:, i, :] - L[:, 0, :]
            name = ['x', 'y', 'z']
        else:
            nparam = self.latt_params.shape[-1]
            L = self.latt_params
            dL = np.zeros(self.latt_params.shape)
            for i in range(ntempt):
                dL[:, i, :] = L[:, i, :] - L[:, 0, :]
            if self.sg > 195: name = ['a']
            elif self.sg >= 75 and self.sg < 195: name = ['a', 'c']
            elif self.sg >= 16 and self.sg < 75: name = ['a', 'b', 'c']
            elif self.sg >= 3 and self.sg < 16: name = ['a', 'b', 'c', 'beta']
            else: name = ['a', 'b', 'c', 'alpha', 'beta', 'gamma']

        func = [[] for i in range(npress)]
        r2tot = np.zeros([npress, nparam])
        for i in range(nparam):
            for ip in range(npress):
                func_p = []; r2_p = []
                dl = dL[ip, :, i]
                for o in poly_order:
                    deg = [i+1 for i in range(o)]
                    if fix0K == True: deg = deg[1:]
                    coef, lst = polyfit(dT, dl, deg=deg, full=True)
                    poly = Polynomial(coef)
                    r2_p.append(1 - lst[0][0]/np.sum((dl - np.mean(dl))**2))
                    func_p.append(poly+L[ip, 0, i])
                idx = np.argmax(r2_p)
                func[ip].append(func_p[idx])
                r2tot[ip, i] = r2_p[idx]

        self.latt_fit = func
        r2avg = np.mean(r2tot, axis=0)

        # Derive
        self.alpha_l = np.zeros([npress, ntempt, nparam])
        for ip in range(npress):
            for i in range(nparam):
                self.alpha_l[ip, :, i] = self.latt_fit[ip][i].deriv(1)(dT) / L[ip, :, i]

        # Plot
        if plot == True:
            for i in range(nparam):
                fig, ax = subplots(1, 1, figsize=(8, 6))
                clist = list(mcolors.keys())
                mlist = ['P', 'X', 'v', '^', '<', '>', 'o', 'D', 'p', 'h']
                T = np.linspace(self.temperature.min(), self.temperature.max(), 1000)
                dT = T - self.temperature.min()
                for ip, p in enumerate(self.pressure):
                    m = mlist[ip % len(mlist)]
                    c = clist[ip % len(clist)]
                    label = 'p {:.4f} GPa, Order {:d}, R^2 {:.4f}'.format(p, len(func[ip][i].coef)-1, r2tot[ip, i])
                    ax.plot(T, func[ip][i](dT), color=c, label=label)
                    ax.scatter(self.temperature, L[ip, :, i], color='k', marker=m, s=40)
                ax.legend(loc='lower right')
                ax.set_xlabel('Temperature (K)')
                ax.set_ylabel(r'Volume ($\AA^{3}$)')
                fig.savefig(fname=fit_fig.format(name[i]), dpi=200)

        if self.filefmt=='yaml':
            ThermoQHA.write_expansion_latt(self, name, poly_order, r2tot, r2avg)
        return self


    def eos_fit(self, volume, energy, method, **kwargs):
        """
        Fit energy-volume relationship by equation of states. Expected to be
        called internally.

        Args:
            volume (array[float]): Unit: Angstrom^3
            energy (array[float]): Unit: kJ/mol
            method (str): Name of EoS used. Consistent with
                `Pymatgen <https://pymatgen.org/pymatgen.analysis.html#module-pymatgen.analysis.eos>`_.
            order (int): For DeltaFactor / Polynomial methods.
            min_ndata_factor, max_poly_order_factor, min_poly_order_factor (int):
                For the NumericalEOS method.

        Returns:
            eos (Pymatgen EOS): The fitted equation of state.
        """
        from pymatgen.analysis.eos import Murnaghan, Birch, BirchMurnaghan, \
            PourierTarantola, Vinet, DeltaFactor, NumericalEOS, PolynomialEOS

        classes = {
            "murnaghan"         : Murnaghan,
            "birch"             : Birch,
            "birch_murnaghan"   : BirchMurnaghan,
            "pourier_tarantola" : PourierTarantola,
            "vinet"             : Vinet,
            "deltafactor"       : DeltaFactor,
            "numerical_eos"     : NumericalEOS,
            "polynomial"        : PolynomialEOS,
        }
        try:
            eos = classes[method.lower()](volume, energy)
        except KeyError:
            raise ValueError("Unknown EOS method: '{}'.".format(method))
        eos_command = 'eos.fit('
        # Polynomial / Deltafactor / Numerical
        for key in kwargs.keys():
            if key in ['order', 'min_ndata_factor', 'max_poly_order_factor', 'min_poly_order']:
                eos_command += ', {}={}'.format(key, kwargs[value])
        eos_command += ')'
        eval(eos_command)

        # Deprecated methods
        if self.filefmt=='txt':
            ThermoQHA.old_write_eosfit(self, self.filename, close_overlap)
        return eos


    def freq_polynomial_fit(self, order):
        """
        Fit phonon frequencies as polynomial functions of volumes. :math:`\\omega(\\Delta V)`
        is fitted. Expected to be called internally.

        Args:
            order (list[int] | array[int]): The order of polynomials used.
        Returns:
            r2tot (array): nQpoint\*nMode array of R^2.
            r2avg (array): Averaged R^2 at each q point.
            self: New attributes listed below.
            fit_order (array): Same as ``order``.
            freq_fit (list): nQpoint\*nMode list of fitted polynomials.
        """
        order = np.array(order, dtype=int, ndmin=1)

        # Polynomial without constant
        poly_fit = []; r2tot = np.zeros([self.nqpoint, self.nmode])
        dv = self.combined_volume - self.combined_volume[0]
        dfreq = (self.combined_freq.T - self.combined_freq[:, :, 0].T).T
        for iq, dfreq_q in enumerate(dfreq):
            fitq = []
            for im, df in enumerate(dfreq_q):
                freq = self.combined_freq[iq, im]
                if np.sum(np.abs(freq)) < 1e-2:
                    fitq.append(Polynomial([0. for i in range(order[0]+1)]))
                    r2tot[iq, im] = 1.
                else:
                    polys = []; r2s = []
                    for o in order:
                        coef, lst = polyfit(dv, df, deg=[i+1 for i in range(o)], full=True)
                        r2 = 1 - lst[0][0] / np.sum((df - np.mean(df))**2)
                        polys.append(Polynomial(coef))
                        r2s.append(r2)
                    idx = np.argmax(r2s)
                    fitq.append(polys[idx] + freq[0])
                    r2tot[iq, im] = r2s[idx]
            poly_fit.append(fitq)

        r2avg = np.mean(r2tot, axis=1)
        # Fit info saved for restart
        self.fit_order = order
        self.freq_fit = poly_fit

        # Deprecated methods
        if self.filefmt=='txt':
            Output.old_write_polyfit(self, r2tot, r2avg)
        return r2tot, r2avg


    def freq_gruneisen_fit(self):
        """
        Fit mode-specific Grüneisen parameters from sampled HA calculations.
        Expected to be called internally.

        Returns:
            rmsdtot (array): nQpoint\*nMode array of R^2.
            rmsdavg (array): Averaged R^2 at each q point.
            self: New attributes listed below.
            gru_fit (array): nQpoint\*nMode array of Grüneisen parameters.
        """
        # Polynomial without constant
        gru_fit = np.zeros([self.nqpoint, self.nmode])
        r2tot = np.zeros([self.nqpoint, self.nmode])
        v_by_v0 = self.combined_volume[1:] / self.combined_volume[0]
        for iq, freq_q in enumerate(self.combined_freq): # nQpt*nMode*nCalc
            for im, freq in enumerate(freq_q):
                if np.sum(np.abs(freq)) < 1e-2:
                    gru_fit[iq, im] = 0.
                    r2tot[iq, im] = 1.
                else:
                    omega0 = self.combined_freq[iq, im, 0]
                    omega = self.combined_freq[iq, im, 1:]
                    gru = np.mean(-np.log(omega/omega0) / np.log(v_by_v0))
                    gru_fit[iq, im] = gru
                    omeganew = omega0 * v_by_v0 ** -gru
                    r2tot[iq, im] = 1 - np.sum((omeganew - omega)**2) / np.sum((omega - np.mean(omega))**2)

        r2avg = np.mean(r2tot, axis=1)
        self.gru_fit = gru_fit
        return r2tot, r2avg


    def _combine_data(self, ha_list, mode_sort_tol):
        """
        Combine the HA calculation data and rearrange it in the ascending order
        of volumes.

        Args:
            ha_list (list[Harmonic]): List of harmonic objects.
            mode_sort_tol (float | None)

        Returns:
            close_overlap (array[int]): nQpoint\*nMode_ref\*nCalc*nMode_sort
                boolean array (only 1 and 0). Whether close overlap is
                identified between the n-1 (ref) and the n (sort) calculations.
                The first Calc is useless (always 0).
            dot_pdt (array[float]): nQpoint\*(nCalc-1) array, dot products between
                n-1 and n calculations.
            self : Attributes listed below.
            combined_volume (array[float]): 1\*nCalc
            combined_struc (list[CStructure]): 1\*nCalc
            combined_u0 (array[float]): 1\*nCalc
            combined_freq (array[float]): nQpoint\*nMode\*nCalc
            combined_symm (array[str]): nQpoint\*nMode\*nCalc
            nqpoint (int):
            qpoint (array[float]): nQpoint\*4
            nmode (int):
            natom (int):

        :raise Exception: If number of q points, modes or atoms are not consistent across the HA calculations.
        """
        from CRYSTALpytools.geometry import CStructure

        # Sorting data according to volumes
        sorted_vol = np.zeros([self.ncalc, 2])
        nqpoint = ha_list[0].nqpoint
        qpoint = ha_list[0].qpoint
        nmode = ha_list[0].nmode  # int
        natom = ha_list[0].natom  # int
        for index, ha_phonon in enumerate(ha_list):
            sorted_vol[index, :] = [index, ha_phonon.volume]
            # Check whether the numbers of modes and atoms are consistent.
            datom = natom-ha_phonon.natom
            dmode = nmode-ha_phonon.nmode
            dqpoint = nqpoint-ha_phonon.nqpoint
            if (datom!=0) or (dmode!=0) or (dqpoint!=0):
                raise Exception('The number of qpoints, modes or atoms is not consistent across the sampled HA calculations.')
            dqcd = np.linalg.norm(qpoint-ha_phonon.qpoint) # to avoid inconsistent dimension errors
            if (dqcd>1e-4):
                raise Exception('Coordinates of qpoints are not consistent across the sampled HA calculations.')
        del datom, dmode, dqpoint, dqcd

        sorted_vol = sorted_vol[np.argsort(sorted_vol[:, 1])]
        if ha_list[0].eigenvector.size == 0:
            do_eigvt = False
        else:
            do_eigvt = True

        # Volume, ncalc * 1 array
        combined_volume = np.zeros(self.ncalc)
        # Structure, ncalc * 1 list
        combined_struc = []
        # DFT total energy, ncalc * 1 array
        combined_u0 = np.zeros(self.ncalc)
        # Frequency, ncalc * nqpoint * nmode array
        combined_freq = np.zeros([self.ncalc, nqpoint, nmode])
        # Symmetry, ncalc * nqpoint * nmode array
        combined_symm = [[] for i in range(self.ncalc)]
        # Eigenvector, ncalc * nqpoint * nmode * natom * 3 array
        combined_eigvt = np.zeros([self.ncalc, nqpoint, nmode, natom, 3], dtype=complex)

        for idx_new, idx_vol in enumerate(sorted_vol):
            ha_phonon = ha_list[int(idx_vol[0])]
            combined_volume[idx_new] = idx_vol[1]
            combined_struc.append(ha_phonon.structure)
            combined_u0[idx_new] = ha_phonon.u_0
            combined_freq[idx_new] = ha_phonon.frequency
            combined_symm[idx_new] = ha_phonon.mode_symm
            if do_eigvt == True:
                combined_eigvt[idx_new] = ha_phonon.eigenvector
        combined_symm = np.array(combined_symm, dtype=str)
        del ha_list

        # Sort phonon modes if requested
        ## ncalc * nqpoint * nmode array to nqpoint * ncalc * nmode array
        combined_freq = np.transpose(combined_freq, axes=[1, 0, 2])
        combined_symm = np.transpose(combined_symm, axes=[1, 0, 2])
        if do_eigvt == True:
            ## ncalc * nqpoint * nmode * natom * 3 array to nqpoint * ncalc * nmode * natom * 3 array
            combined_eigvt = np.transpose(combined_eigvt, axes=[1, 0, 2, 3, 4])

        ## Sort
        close_overlap = np.zeros([nqpoint, self.ncalc, nmode, nmode], dtype=int)
        dot_pdt = np.zeros([nqpoint, self.ncalc-1])
        self._mode_sorted = False
        if np.all(mode_sort_tol!=None) and do_eigvt == True:
            self._mode_sorted = True
            for idx_q in range(nqpoint):
                combined_freq[idx_q], combined_eigvt[idx_q], \
                close_overlap[idx_q], dot_pdt[idx_q] \
                    = self._phonon_continuity(combined_freq[idx_q],
                                              combined_eigvt[idx_q],
                                              symm=combined_symm[idx_q],
                                              mode_sort_tol=mode_sort_tol)
            ## nqpoint * ncalc * nmode_ref * nmode_sort array to nqpoint * nmode_ref * ncalc * nmode_sort array
            close_overlap = np.transpose(close_overlap, axes=[0, 2, 1, 3])
            for q, overlap_q in enumerate(close_overlap):
                n_overlap = int(np.sum(overlap_q))
                if n_overlap > 0:
                    warn('Close overlap of phonon modes detected at qpoint {}: {} overlaps out of {}*{} mode combinations at this point.'.format(q, n_overlap, nmode, nmode),
                         stacklevel=2)
        elif np.all(mode_sort_tol!=None) and do_eigvt == False:
            warn('Eigenvectors not read. Mode sorting not available.', stacklevel=2)

        ## nqpoint * ncalc * nmode array to nqpoint * nmode * ncalc array
        combined_freq = np.transpose(combined_freq, axes=[0, 2, 1])
        combined_symm = np.transpose(combined_symm, axes=[0, 2, 1])
        if do_eigvt == True:
            ## nqpoint * ncalc * nmode * natom * 3 array to nqpoint *  nmode * ncalc * natom * 3 array
            combined_eigvt = np.transpose(combined_eigvt, axes=[0, 2, 1, 3, 4])

        self.combined_volume = combined_volume
        self.combined_struc = combined_struc
        self.combined_u0 = combined_u0
        self.combined_freq = combined_freq
        self.combined_symm = combined_symm
        self.nqpoint = nqpoint
        self.qpoint = qpoint
        self.nmode = nmode
        self.natom = natom
        return close_overlap, dot_pdt


    @staticmethod
    def _phonon_continuity(freq, eigvt, symm=None, mode_sort_tol=0.4):
        """
        Rearrange phonon modes by their continuity. If the difference between
        the maximum scalar product of corresponding eigenvectors (normalized to
        1) and scalar products of other modes is less than 0.4, warning is
        printed due to the potential overlap of modes. Adopted from CRYSTAL17.

        .. note::

            A. Erba, *J. Chem. Phys.*, 2014, **141**, 124115.

        Args:
            freq (array[float]): Phonon frequencies. Unit: THz
            eigvt (array[float]): Eigenvectores normalized to 1
            symm (array[str]): Irreducible representations in Mulliken symbols.
            mode_sort_tol (float): The threshold of close mode overlaps.

        Returns:
            freq (array[float]): Sorted phonon frequencies
            eigvt (array[float]): Sorted eigenvectores
            close_overlap (array[float]):ncalc\*nmode\*nmode boolean matrix
                (only 1 and 0). Whether close overlap is identified between the
                previous calculation (2nd dimension) and the current one (3rd).
            dot_pdt (array[float]): 1\*(nCalc-1) array, dot products between n-1
                and n calculations.
        """
        # Exclude negative and 0 frequencies
        ncalc = len(freq)
        nmode = len(freq[0])

        # Sort phonon
        close_overlap = np.zeros([ncalc, nmode, nmode])
        dot_pdt = np.zeros([ncalc-1,])
        for sort_c in range(1, ncalc):
            ref_c = sort_c - 1
            ref_eigvt = deepcopy(eigvt[ref_c])
            sort_eigvt = deepcopy(eigvt[sort_c])
            ref_eigvt = np.reshape(ref_eigvt, [nmode, nmode], order='C')
            sort_eigvt = np.reshape(sort_eigvt, [nmode, nmode], order='C')
            mode_product = np.abs(ref_eigvt @ sort_eigvt.conjugate().T) # row: ref_m, col: sort_m
            del ref_eigvt, sort_eigvt # save some space

            # subdivide the matrix by symmetry
            symm_product = []; irow = []; icol = [];
            if len(symm[0]) != 0:
                unique_symm = set(symm[0].tolist())
                for s in unique_symm:
                    idx_row = np.where(symm[ref_c] == s)[0]
                    idx_col = np.where(symm[sort_c] == s)[0]
                    if len(idx_row) != len(idx_col):
                        raise Exception("Inconsistent number of modes with symmetry '{}' between the {:d} and the {:d} calculations.".format(s, ref_c, sort_c))
                    col, row = np.meshgrid(idx_col, idx_row)
                    symm_product.append(mode_product[row, col])
                    irow.append(idx_row)
                    icol.append(idx_col)
            else:
                symm_product.append(mode_product)
                irow.append(np.array([i for i in range(nmode)], dtype=int))
                icol.append(np.array([i for i in range(nmode)], dtype=int))
            del mode_product # save some space

            # linear sum assignment of matrices of the same symmetry
            newidx = np.zeros([2, nmode], dtype=int) # 1st: Old index (sorted col) 2nd: New index (row)
            overlaps = []
            countcol = 0
            for pdt, row, col in zip(symm_product, irow, icol):
                rowidx, colidx = linear_sum_assignment(pdt, maximize=True)
                ncol = len(col)
                newidx[:, countcol:countcol+ncol] = np.vstack([col[colidx], row])
                countcol += ncol

                # Very poor overlaps
                if len(np.where(pdt[rowidx, colidx] < mode_sort_tol)[0]) > 0:
                    raise ValueError(
                        'Poor continuity detected between Calc {:d} and Calc {:d}. Min eigenvector product = {:.4f}'.format(
                            ref_c, sort_c, np.min(pdt[rowidx, colidx])))

                # averaged product
                dot_pdt[ref_c] += pdt[rowidx, colidx].sum()

                # close overlaps
                pdt[:, rowidx] = pdt[:, colidx]
                dpdt = -np.subtract(pdt, pdt[rowidx, rowidx].reshape([-1, 1]))
                claprow, clapcol = np.where((dpdt>0)&(dpdt<mode_sort_tol))
                if len(claprow) == 0: continue
                overlaps.append([row[claprow], row[clapcol]]) # 1st: ref mode idx 2nd: Sorted mode idx

            # rearrange the sorted calculation
            freq[sort_c, newidx[1]] = freq[sort_c, newidx[0]]
            eigvt[sort_c, newidx[1]] = eigvt[sort_c, newidx[0]]
            if len(symm[0]) != 0:
                symm[sort_c, newidx[1]] = symm[sort_c, newidx[0]]

            # close overlaps
            for o in overlaps:
                close_overlap[sort_c, o[0], o[1]] = 1

        return freq, eigvt, close_overlap, dot_pdt/nmode


    def _clean_thermoprop(self):
        """Clean fitted data. Called by 'thermo_\*' methods only."""
        props = ['volume', 'helmholtz', 'gibbs', 'entropy', 'c_v', 'c_p',
                 'k_t', 'k_s', 'alpha_v', 'gruneisen', 'lattice']
        for p in props:
            if hasattr(self, p): delattr(self, p)
        return self


    def _interp_HA(self, interp, thermo):
        """Interpolate harmonic phonons for lattice fitting. Interpolation
        is done by reducing the volume steplength by half, and add points closest
        to the boundary first.

        Lattice will be expanded to conventional cell and aligned. :math:`a` will
        be aligned to :math:`x` and :math:`b` in :math:`xOy` plane.

        .. note::

            Only available to objects generated by ``thermo_freq()`` and ``thermo_gruneisen()``.

        Args:
            interp (int): Number of interpolations. Must be smaller than ``self.ncalc``.
            thermo (bool): Whether to run HA thermodynamics.
        Returns:
            sg (int): International space group number.
            vscale (float): Volume ratio between conventional and primitive cell.
            rot (array): Rotation matrix from invernal convention to input / standard conventional cell.
            lmx (array): (nCalc+nInterp)\*3\*3 array of lattice matrices. The
                first nCalc elements are sampled lattices.
            Gibbs (array): (nCalc+nInterp)\*nPress\*nTempt array of Gibbs free energy in kJ/mol.
        """
        from pymatgen.symmetry.analyzer import SpacegroupAnalyzer

        if self.ncalc <= interp:
            raise Exception("The number of interpolated points must smaller than the number of sampled points.")

        # Reference lattice
        sg = SpacegroupAnalyzer(self.combined_struc[0]).get_space_group_number()
        lmx = np.zeros([self.ncalc+interp, 3, 3], dtype=float)
        for i, struc in enumerate(self.combined_struc):
            analyzer = SpacegroupAnalyzer(struc)
            newsg = analyzer.get_space_group_number()
            if sg != newsg:
                raise Exception("Inconsistent symmetry of sampled HA phonons.")

            ## align to conventional standard, and a along x, b within xy
            newstruc = analyzer.get_refined_structure()
            a, b, c, alpha, beta, gamma = newstruc.lattice.parameters
            alpha *= np.pi/180; beta *= np.pi/180; gamma *= np.pi/180
            const = (np.cos(alpha)-np.cos(beta)*np.cos(gamma)) / np.sin(gamma)
            lmx[i] = np.array([[a, 0., 0.],
                               [b*np.cos(gamma), b*np.sin(gamma), 0.],
                               [c*np.cos(beta), c*const, c*np.sqrt(1-np.cos(beta)**2-const**2)]],
                              dtype=float)

        ## volume might differ, scale the energy
        vscale = newstruc.lattice.volume / self.combined_struc[-1].lattice.volume
        ## rotation, L'@rot = L
        if (vscale-1)**2 < 1e-8: # No expansion, align to input
            rot = np.linalg.inv(lmx[self.ncalc-1]) @ self.combined_struc[-1].lattice.matrix
        else: # Expansion, align to standard
            rot = np.linalg.inv(lmx[self.ncalc-1])

        if interp != 0:
            newvol = np.linspace(self.combined_volume[0], self.combined_volume[-1], 2*self.ncalc-1)
            newvol = np.array([newvol[i] for i in range(1, 2*self.ncalc-1, 2)])
            newvol = np.vstack([newvol, newvol[::-1]]).T.flatten()
            for iv in range(interp):
                vol = newvol[iv]
                pidx = np.where(self.combined_volume<vol)[0][-1]
                scale = (vol / self.combined_volume[pidx])**(1/3)
                lmx[iv+self.ncalc] = lmx[pidx] * scale

        # Cubic
        if sg > 195:
            warn("Cubic lattice! Parameters generated from equilibrium volumes.", stacklevel=3)
            return sg, vscale, rot, lmx, []

        # Thermo
        if thermo == False: return sg, vscale, rot, lmx, []

        # Reference Gibbs
        Gibbs = np.zeros([self.ncalc+interp, self.volume.shape[0], self.volume.shape[1]])
        eigvt = np.array([[[[] for i in range(self.natom)] for j in range(self.nmode)] for k in range(self.nqpoint)])
        symm = np.array([['' for i in range(self.nmode)] for j in range(self.nqpoint)], dtype=str)
        for i, struc, u0, freq in zip(range(self.ncalc), self.combined_struc, self.combined_u0,
                                      np.transpose(self.combined_freq, axes=[2, 0, 1])):
            ha = Harmonic(filename=None, autocalc=False).from_frequency(u0, self.qpoint, freq, eigvt, symm, struc)
            ha.thermodynamics(temperature=self.temperature, pressure=self.pressure)
            Gibbs[i] = ha.gibbs

        if interp != 0:
            if self.method == 'thermo_freq':
                for iv in range(interp):
                    num_freq = np.zeros([self.nqpoint, self.nmode])
                    vol = newvol[iv] / vscale
                    dvol = vol - self.combined_volume[0]
                    for iq in range(self.nqpoint):
                        for im in range(self.nmode):
                            num_freq[iq, im] = self.freq_fit[iq][im](dvol)
                    ha = Harmonic(filename=None, autocalc=False).from_frequency(
                        self.u0_fit(vol), self.qpoint, num_freq, eigvt, symm, natom=self.natom, volume=vol
                    )
                    ha.thermodynamics(temperature=self.temperature, pressure=self.pressure)
                    Gibbs[self.ncalc+iv] = ha.gibbs
            elif self.method == 'thermo_gruneisen':
                omega0 = self.combined_freq[:, :, 0]
                for iv in range(interp):
                    vol = newvol[iv] / vscale
                    v_by_v0 = vol / self.combined_volume[0]
                    num_freq = omega0 * v_by_v0**-self.gru_fit
                    ha = Harmonic(filename=None, autocalc=False).from_frequency(
                        self.u0_fit(vol), self.qpoint, num_freq, eigvt, symm, natom=self.natom, volume=vol
                    )
                    ha.thermodynamics(temperature=self.temperature, pressure=self.pressure)
                    Gibbs[self.ncalc+iv] = ha.gibbs
        Gibbs *=  vscale
        return sg, vscale, rot, lmx, Gibbs


# -------------------------------- deprecated --------------------------------#
    def from_HA_files(self, *input_files, imaginary_tol=1e-4, q_overlap_tol=1e-4,
                      mode_sort_tol=0.4):
        """Deprecated. Call ``from_file()`` directly."""
        warn("Deprecated. Call 'from_file(source='crystal')' instead.", stacklevel=2)
        self.from_file(*input_files, source='crystal', mode_sort_tol=mode_sort_tol,
                       imaginary_tol=imaginary_tol, q_overlap_tol=q_overlap_tol)
        return self

    def from_QHA_file(self, input_file, imaginary_tol=1e-4,
                      q_overlap_tol=1e-4, mode_sort_tol=0.4):
        """Deprecated. Call ``from_file()`` directly."""
        warn("Deprecated. Call 'from_file(source='crystal-QHA')' instead.", stacklevel=2)
        self.from_file(input_file, source='crystal-QHA', mode_sort_tol=mode_sort_tol,
                       imaginary_tol=imaginary_tol, q_overlap_tol=q_overlap_tol)
        return self

    def from_phonopy_files(self, phono_yaml, struc_yaml=None, edft=None,
                           scale=1.0, imaginary_tol=1e-4, q_overlap_tol=1e-4,
                           q_id=None, q_coord=None):
        """Deprecated. Call ``from_file()`` directly."""
        warn("Deprecated. Call 'from_file(source='phonopy')' instead.", stacklevel=2)
        self.from_file(*phono_yaml, source='phonopy', struc_yaml=struc_yaml,
                       u_0=edft, scale=scale, mode_sort_tol=mode_sort_tol,
                       imaginary_tol=imaginary_tol, q_overlap_tol=q_overlap_tol,
                       q_id=q_id, q_coord=q_coord)
        return self

    def expansion_lin(self, poly_order=[2, 3], interp=0):
        """Deprecated and not compatibable. Only prints error message."""
        raise Exception("This function has been disabled due to instability. Please refer to 'lattice_hess()', 'lattice_poly()' and 'expansion_latt()' methods.")



class Phonopy():
    """Deprecated."""
    @classmethod
    def read_structure(cls, file):
        from CRYSTALpytools.io.phonopy import YAML

        warn("Deprecated. Call 'CRYSTALpytools.io.phonopy.YAML.read()' method.", stacklevel=2)
        obj = YAML.read(file)
        return obj.structure

    @classmethod
    def read_frequency(cls, file, q_id=None, q_coord=None):
        raise Exception("Deprecated. Call 'CRYSTALpytools.io.phonopy.YAML.read()' method. Geometry is mandatory.")

    @classmethod
    def write_force_constants(cls, hessfile='HESSFREQ.DAT', phonopyfile='FORCE_CONSTANTS'):
        """
        Write Phonopy/VASP FORCE_CONSTANTS file by CRYSTAL HESSFREQ.DAT file.

        For example, to convert the calculation 'example' with a 4\*4\*4
        supercelland get phonon frequencies at Gamma point, use the following
        code:

        .. code-block:: python

            >>> from CRYSTALpytools.thermodynamics import Phonopy
            >>> Phonopy.write_force_constants(hessfile='example.HESSFREQ')
            >>> phonopy --crystal --qpoints='0 0 0' -c example.out --dim='4 4 4' --readfc

        Args:
            hessfile (str): The HESSFREQ.DAT file
            phonopyfile (str): The output name

        """
        import re
        import numpy as np
        from CRYSTALpytools.units import H_to_eV, angstrom_to_au

        # Note: Phonopy requires mass unweighted Hessian
        # Read hessfreq.dat
        file = open(hessfile, 'r')
        data = file.read()
        file.close()

        hess = np.array(data.strip().split(), dtype=float)
        natom = int((len(hess) / 9)**0.5)

        hess = np.reshape(hess, [3*natom, 3*natom], order='F')
        hess = angstrom_to_au(angstrom_to_au(H_to_eV(hess))) # Hartree.Bohr^-2 to eV.Angstrom^-2
        # Symmstrize Hessian with its lower half - Important. To address the print issue of HESSFREQ.DAT
        for i in range(3*natom):
            for j in range(i+1, 3*natom):
                hess[i, j] = hess[j, i]

        # Write force_constants
        file = open(phonopyfile, 'w')
        file.write('%4i%4i\n' % (natom, natom))
        for i in range(natom):
            for j in range(natom):
                file.write('%4i%4i\n' % (i + 1, j + 1))
                dynamic = hess[int(3 * i):int(3 * i + 3), int(3 * j):int(3 * j + 3)]
                for d in dynamic:
                    file.write('%22.15f%22.15f%22.15f\n' % (d[0], d[1], d[2]))

        file.close()


class Output():
    """Deprecated. Only prints out error messages."""
    @classmethod
    def write_HA_result(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write()' for txt output.")
    @classmethod
    def write_QHA_combinedata(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write_combine_data()' for txt output.")
    @classmethod
    def write_QHA_sortphonon(cls):
        raise Exception("Deprecated. Check 'CRYSTALpytools.base.dump.ThermoHA' class.")
    @classmethod
    def write_QHA_eosfit(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write_eosfit()' for txt output.")
    @classmethod
    def write_QHA_polyfit(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write_polyfit()' for txt output.")
    @classmethod
    def write_QHA_thermofreq(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write_thermo_freq()' for txt output.")
    @classmethod
    def write_QHA_thermogru(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write_thermo_gru()' for txt output.")
    @classmethod
    def write_QHA_thermoeos(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write_thermo_eos()' for txt output.")
    @classmethod
    def write_expansion_vol(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write_expansion_vol()' for txt output.")
    @classmethod
    def write_bulk_modulus(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write_bulk_modulus()' for txt output.")
    @classmethod
    def write_specific_heat(cls):
        raise Exception("Deprecated. Call 'CRYSTALpytools.base.dump.ThermoHA.old_write_specific_heat()' for txt output.")
    @classmethod
    def write_expansion_latt(cls):
        raise Exception("Deprecated. Check 'CRYSTALpytools.base.dump.ThermoHA' class.")
