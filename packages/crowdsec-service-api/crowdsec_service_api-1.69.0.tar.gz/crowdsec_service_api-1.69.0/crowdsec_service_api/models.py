# generated by datamodel-codegen:
#   filename:  <stdin>
#   timestamp: 2025-05-02T13:09:22+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Annotated, Dict, List, Optional, Union

from pydantic import AnyUrl, ConfigDict, Field, RootModel

from .base_model import BaseModelSdk


class AllowlistCreateRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[
        str,
        Field(
            description='Name of the allowlist',
            max_length=200,
            min_length=1,
            title='Name',
        ),
    ]
    description: Annotated[
        Optional[str],
        Field(description='Description of the allowlist', title='Description'),
    ] = None


class AllowlistCreateResponse(BaseModelSdk):
    id: Annotated[
        str,
        Field(
            description='ID of the allowlist',
            examples=['5f9d88b9e5c4f5b9a3d3e8b1'],
            title='Id',
        ),
    ]
    organization_id: Annotated[
        str, Field(description='ID of the owner organization', title='Organization Id')
    ]
    name: Annotated[str, Field(description='Name of the allowlist', title='Name')]
    description: Annotated[
        Optional[str],
        Field(description='Description of the allowlist', title='Description'),
    ] = None
    created_at: Annotated[
        datetime,
        Field(description='Time the allowlist was created', title='Created At'),
    ]
    updated_at: Annotated[
        Optional[datetime],
        Field(description='Time the allowlist was updated', title='Updated At'),
    ] = None
    from_cti_query: Annotated[
        Optional[str],
        Field(
            description='CTI query from which the blocklist was created',
            title='From Cti Query',
        ),
    ] = None
    since: Annotated[
        Optional[str],
        Field(
            description='Since duration for the CTI query (eg. 5m, 2h, 7d). Max is 30 days',
            title='Since',
        ),
    ] = None
    total_items: Annotated[
        int, Field(description='Number of items in the allowlist', title='Total Items')
    ]


class AllowlistItemUpdateRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Annotated[
        Optional[str],
        Field(description='Description of the allowlist entry', title='Description'),
    ] = None
    expiration: Annotated[
        Optional[datetime],
        Field(description='Time the allowlist entry will expire', title='Expiration'),
    ] = None


class AllowlistItemsCreateRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    items: Annotated[
        List[str],
        Field(description='List of values to add to the allowlist', title='Items'),
    ]
    description: Annotated[
        str,
        Field(description='Description of the allowlist entry', title='Description'),
    ]
    expiration: Annotated[
        Optional[datetime],
        Field(description='Time the allowlist entry will expire', title='Expiration'),
    ] = None


class AllowlistScope(Enum):
    IP = 'ip'
    RANGE = 'range'


class AllowlistSubscriptionResponse(BaseModelSdk):
    updated: Annotated[
        Optional[List[str]],
        Field(
            description='List of updated allowlist ids',
            examples=['5f9d88b9e5c4f5b9a3d3e8b1'],
            title='Updated',
        ),
    ] = None
    errors: Annotated[
        Optional[List[Dict[str, str]]],
        Field(
            description='List of errors if any',
            examples=[{'5f9d88b9e5c4f5b9a3d3e8b1': 'error message'}],
            title='Errors',
        ),
    ] = None


class Name(RootModel[str]):
    root: Annotated[
        str,
        Field(
            description='Name of the allowlist',
            max_length=200,
            min_length=1,
            title='Name',
        ),
    ]


class AllowlistUpdateRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[
        Optional[Name], Field(description='Name of the allowlist', title='Name')
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='Description of the allowlist', title='Description'),
    ] = None


class ApiKeyCredentials(BaseModelSdk):
    api_key: Annotated[
        str, Field(description='API key for the integration', title='Api Key')
    ]


class BasicAuthCredentials(BaseModelSdk):
    username: Annotated[
        str,
        Field(description='Basic auth username for the integration', title='Username'),
    ]
    password: Annotated[
        str,
        Field(description='Basic auth password for the integration', title='Password'),
    ]


class BlocklistAddIPsRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    ips: Annotated[List[str], Field(description='List of IPs or networks', title='Ips')]
    expiration: Annotated[
        Optional[datetime],
        Field(
            description='Expiration date',
            examples=['2030-01-01T00:00:00.000Z'],
            title='Expiration',
        ),
    ] = None


class BlocklistCategory(BaseModelSdk):
    name: Annotated[str, Field(title='Name')]
    label: Annotated[str, Field(title='Label')]
    description: Annotated[str, Field(title='Description')]
    priority: Annotated[int, Field(title='Priority')]


class BlocklistCreateRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[
        str,
        Field(
            description='Blocklist name, must be unique within the organization',
            max_length=200,
            min_length=1,
            title='Name',
        ),
    ]
    label: Annotated[
        Optional[str],
        Field(
            description='Blocklist human readable name (Default: name)', title='Label'
        ),
    ] = None
    description: Annotated[
        str,
        Field(description='Blocklist description', min_length=1, title='Description'),
    ]
    references: Annotated[
        Optional[List[str]],
        Field(
            description="Useful references on the list's origins", title='References'
        ),
    ] = []
    tags: Annotated[
        Optional[List[str]], Field(description='Classification tags', title='Tags')
    ] = []


class BlocklistDeleteIPsRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    ips: Annotated[List[str], Field(description='List of IPs or networks', title='Ips')]


class BlocklistIncludeFilters(Enum):
    PUBLIC = 'public'
    PRIVATE = 'private'
    SHARED = 'shared'
    ALL = 'all'


class BlocklistSources(Enum):
    CROWDSEC = 'crowdsec'
    THIRD_PARTY = 'third_party'
    CUSTOM = 'custom'


class BlocklistSubscription(BaseModelSdk):
    id: Annotated[str, Field(title='Id')]
    remediation: Annotated[Optional[str], Field(title='Remediation')] = None
    name: Annotated[str, Field(title='Name')]
    label: Annotated[str, Field(title='Label')]


class BlocklistSubscriptionResponse(BaseModelSdk):
    updated: Annotated[
        Optional[List[str]],
        Field(
            description='List of updated blocklist ids',
            examples=['5f9d88b9e5c4f5b9a3d3e8b1'],
            title='Updated',
        ),
    ] = None
    errors: Annotated[
        Optional[List[Dict[str, str]]],
        Field(
            description='List of errors if any',
            examples=[{'5f9d88b9e5c4f5b9a3d3e8b1': 'error message'}],
            title='Errors',
        ),
    ] = None


class BlocklistUpdateRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    label: Annotated[
        Optional[str], Field(description='Blocklist human readable name', title='Label')
    ] = None
    description: Annotated[
        Optional[str], Field(description='Blocklist description', title='Description')
    ] = None
    references: Annotated[
        Optional[List[str]],
        Field(description='Blocklist references', title='References'),
    ] = None
    tags: Annotated[
        Optional[List[str]], Field(description='Blocklist tags', title='Tags')
    ] = None
    from_cti_query: Annotated[
        Optional[str],
        Field(
            description='CTI query (doc link available soon)', title='From Cti Query'
        ),
    ] = None
    since: Annotated[
        Optional[str],
        Field(
            description='Since duration for the CTI query (eg. 5m, 2h, 7d). Max is 30 days',
            title='Since',
        ),
    ] = None


class BlocklistUsageStats(BaseModelSdk):
    model_config = ConfigDict(
        extra='allow',
    )
    engines_subscribed_directly: Annotated[
        Optional[int], Field(title='Engines Subscribed Directly')
    ] = 0
    engines_subscribed_through_org: Annotated[
        Optional[int], Field(title='Engines Subscribed Through Org')
    ] = 0
    engines_subscribed_through_tag: Annotated[
        Optional[int], Field(title='Engines Subscribed Through Tag')
    ] = 0
    total_subscribed_engines: Annotated[
        Optional[int], Field(title='Total Subscribed Engines')
    ] = 0
    total_subscribed_organizations: Annotated[
        Optional[int], Field(title='Total Subscribed Organizations')
    ] = 0
    updated_at: Annotated[Optional[datetime], Field(title='Updated At')] = None


class BodyUploadBlocklistContent(BaseModelSdk):
    file: Annotated[
        bytes, Field(description='Blocklist file in txt format', title='File')
    ]


class CtiAs(BaseModelSdk):
    model_config = ConfigDict(
        extra='allow',
    )
    as_num: Annotated[str, Field(title='As Num')]
    as_name: Annotated[str, Field(title='As Name')]
    total_ips: Annotated[int, Field(title='Total Ips')]


class CtiBehavior(BaseModelSdk):
    model_config = ConfigDict(
        extra='allow',
    )
    name: Annotated[str, Field(title='Name')]
    label: Annotated[str, Field(title='Label')]
    description: Annotated[str, Field(title='Description')]
    references: Annotated[List[str], Field(title='References')]
    total_ips: Annotated[int, Field(title='Total Ips')]


class CtiCategory(BaseModelSdk):
    model_config = ConfigDict(
        extra='allow',
    )
    name: Annotated[str, Field(title='Name')]
    label: Annotated[str, Field(title='Label')]
    description: Annotated[str, Field(title='Description')]
    total_ips: Annotated[int, Field(title='Total Ips')]


class CtiCountry(BaseModelSdk):
    model_config = ConfigDict(
        extra='allow',
    )
    country_short: Annotated[str, Field(title='Country Short')]
    total_ips: Annotated[int, Field(title='Total Ips')]


class CtiIp(BaseModelSdk):
    model_config = ConfigDict(
        extra='allow',
    )
    ip: Annotated[str, Field(title='Ip')]
    total_signals_1m: Annotated[int, Field(title='Total Signals 1M')]
    reputation: Annotated[Optional[str], Field(title='Reputation')] = 'unknown'


class CtiScenario(BaseModelSdk):
    model_config = ConfigDict(
        extra='allow',
    )
    name: Annotated[str, Field(title='Name')]
    label: Annotated[str, Field(title='Label')]
    description: Annotated[str, Field(title='Description')]
    references: Annotated[List[str], Field(title='References')]
    total_ips: Annotated[int, Field(title='Total Ips')]


class EntityType(Enum):
    ORG = 'org'
    TAG = 'tag'
    ENGINE = 'engine'
    FIREWALL_INTEGRATION = 'firewall_integration'
    REMEDIATION_COMPONENT_INTEGRATION = 'remediation_component_integration'
    REMEDIATION_COMPONENT = 'remediation_component'
    LOG_PROCESSOR = 'log_processor'


class InfoResponse(BaseModelSdk):
    organization_id: Annotated[
        str, Field(description='The organization ID', title='Organization Id')
    ]
    subscription_type: Annotated[
        str,
        Field(
            description='The organization subscription type', title='Subscription Type'
        ),
    ]
    api_key_name: Annotated[
        str, Field(description='The API key name that is used', title='Api Key Name')
    ]


class IntegrationType(Enum):
    FIREWALL_INTEGRATION = 'firewall_integration'
    REMEDIATION_COMPONENT_INTEGRATION = 'remediation_component_integration'


class Links(BaseModelSdk):
    first: Annotated[
        Optional[str], Field(examples=['/api/v1/users?limit=1&offset1'], title='First')
    ] = None
    last: Annotated[
        Optional[str], Field(examples=['/api/v1/users?limit=1&offset1'], title='Last')
    ] = None
    self: Annotated[
        Optional[str], Field(examples=['/api/v1/users?limit=1&offset1'], title='Self')
    ] = None
    next: Annotated[
        Optional[str], Field(examples=['/api/v1/users?limit=1&offset1'], title='Next')
    ] = None
    prev: Annotated[
        Optional[str], Field(examples=['/api/v1/users?limit=1&offset1'], title='Prev')
    ] = None


class MetricUnits(Enum):
    BYTE = 'byte'
    PACKET = 'packet'
    REQUEST = 'request'
    IP = 'ip'
    LINE = 'line'


class OutputFormat(Enum):
    PLAIN_TEXT = 'plain_text'
    F5 = 'f5'
    REMEDIATION_COMPONENT = 'remediation_component'
    FORTIGATE = 'fortigate'
    PALOALTO = 'paloalto'
    CHECKPOINT = 'checkpoint'
    CISCO = 'cisco'
    JUNIPER = 'juniper'
    MIKROTIK = 'mikrotik'
    PFSENSE = 'pfsense'
    OPNSENSE = 'opnsense'
    SOPHOS = 'sophos'


class Total(RootModel[int]):
    root: Annotated[int, Field(ge=0, title='Total')]


class Page(RootModel[int]):
    root: Annotated[int, Field(ge=1, title='Page')]


class Size(RootModel[int]):
    root: Annotated[int, Field(ge=1, title='Size')]


class Pages(RootModel[int]):
    root: Annotated[int, Field(ge=0, title='Pages')]


class Permission(Enum):
    READ = 'read'
    WRITE = 'write'


class PricingTiers(Enum):
    FREE = 'free'
    PREMIUM = 'premium'
    PLATINUM = 'platinum'


class RemediationMetricsData(BaseModelSdk):
    value: Annotated[
        Union[int, float], Field(description='Value of the metric', title='Value')
    ]
    timestamp: Annotated[
        datetime, Field(description='Timestamp of the metric', title='Timestamp')
    ]


class Share(BaseModelSdk):
    organization_id: Annotated[str, Field(title='Organization Id')]
    permission: Permission


class SourceType(Enum):
    USER = 'user'
    APIKEY = 'apikey'


class Stats(BaseModelSdk):
    count: Annotated[
        int,
        Field(
            description='Number of total blocklists items the integration will pull',
            title='Count',
        ),
    ]


class SubscriberEntityType(Enum):
    ORG = 'org'
    TAG = 'tag'
    ENGINE = 'engine'
    FIREWALL_INTEGRATION = 'firewall_integration'
    REMEDIATION_COMPONENT_INTEGRATION = 'remediation_component_integration'


class ValidationError(BaseModelSdk):
    loc: Annotated[List[Union[str, int]], Field(title='Location')]
    msg: Annotated[str, Field(title='Message')]
    type: Annotated[str, Field(title='Error Type')]


class VersionDetail(BaseModelSdk):
    deprecated: Annotated[
        Optional[bool],
        Field(
            description='Indicates whether this version is deprecated.',
            title='Deprecated',
        ),
    ] = False
    digest: Annotated[
        str,
        Field(
            description='The SHA256 digest of the versioned file.',
            examples=['Detect FTP bruteforce (vsftpd)'],
            title='Digest',
        ),
    ]


class AllowlistsListAllowlistsQueryParameters(BaseModelSdk):
    page: Annotated[
        Optional[int], Field(description='Page number', ge=1, title='Page')
    ] = 1
    size: Annotated[
        Optional[int], Field(description='Page size', ge=1, le=100, title='Size')
    ] = 50


class AllowlistsGetAllowlistPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]


class AllowlistsUpdateAllowlistPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]


class AllowlistsDeleteAllowlistQueryParameters(BaseModelSdk):
    force: Annotated[
        Optional[bool],
        Field(
            description='Force delete the allowlist, even if it has subscribers',
            title='Force',
        ),
    ] = False


class AllowlistsDeleteAllowlistPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]


class AllowlistsCreateAllowlistItemsPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]


class AllowlistsGetAllowlistItemsQueryParameters(BaseModelSdk):
    page: Annotated[
        Optional[int], Field(description='Page number', ge=1, title='Page')
    ] = 1
    size: Annotated[
        Optional[int], Field(description='Page size', ge=1, le=100, title='Size')
    ] = 50


class AllowlistsGetAllowlistItemsPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]


class AllowlistsGetAllowlistItemPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]
    item_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Item Id')
    ]


class AllowlistsUpdateAllowlistItemPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]
    item_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Item Id')
    ]


class AllowlistsDeleteAllowlistItemPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]
    item_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Item Id')
    ]


class AllowlistsGetAllowlistSubscribersQueryParameters(BaseModelSdk):
    page: Annotated[
        Optional[int], Field(description='Page number', ge=1, title='Page')
    ] = 1
    size: Annotated[
        Optional[int], Field(description='Page size', ge=1, le=100, title='Size')
    ] = 50


class AllowlistsGetAllowlistSubscribersPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]


class AllowlistsSubscribeAllowlistPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]


class AllowlistsUnsubscribeAllowlistPathParameters(BaseModelSdk):
    allowlist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Allowlist Id')
    ]
    entity_id: Annotated[str, Field(title='Entity Id')]


class BlocklistsGetBlocklistsQueryParameters(BaseModelSdk):
    page: Annotated[
        Optional[int], Field(description='Page number', ge=1, title='Page')
    ] = 1
    page_size: Annotated[
        Optional[int], Field(description='Page size', le=1000, title='Page Size')
    ] = 100
    subscribed_only: Annotated[
        Optional[bool],
        Field(description='only subscribed blocklists', title='Subscribed Only'),
    ] = False
    exclude_subscribed: Annotated[
        Optional[bool],
        Field(description='exclude subscribed blocklists', title='Exclude Subscribed'),
    ] = False
    include_filter: Annotated[
        Optional[List[BlocklistIncludeFilters]],
        Field(
            description='Include blocklists with the specified filters',
            title='Include Filter',
        ),
    ] = ['private', 'shared']
    category: Annotated[
        Optional[List[str]], Field(description='Filter by category', title='Category')
    ] = None
    size: Annotated[
        Optional[int], Field(description='Page size', ge=1, le=100, title='Size')
    ] = 50


class BlocklistsGetBlocklistPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsUpdateBlocklistPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsDeleteBlocklistQueryParameters(BaseModelSdk):
    force: Annotated[
        Optional[bool],
        Field(
            description='Force delete the blocklist if it is shared or subscribed',
            title='Force',
        ),
    ] = False


class BlocklistsDeleteBlocklistPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsUploadBlocklistContentQueryParameters(BaseModelSdk):
    expiration: Annotated[
        Optional[datetime],
        Field(
            description='Blocklist expiration',
            examples='2025-05-02T13:08:57.499429+00:00',
            title='Expiration',
        ),
    ] = None
    ignore_invalid_ips: Annotated[
        Optional[bool],
        Field(description='Ignore invalid IPs', title='Ignore Invalid Ips'),
    ] = False


class BlocklistsUploadBlocklistContentPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsAddIpsToBlocklistPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsOverwriteIpsPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsDeleteIpsFromBlocklistPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsDownloadBlocklistContentPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsDownloadBlocklistContentHeadersParameters(BaseModelSdk):
    if_modified_since: Annotated[
        Optional[str],
        Field(
            alias='if-modified-since',
            description='If_Modified_Since cache control header',
            title='If-Modified-Since',
        ),
    ] = None
    if_none_match: Annotated[
        Optional[str],
        Field(
            alias='if-none-match',
            description='If_None_Match cache control header',
            title='If-None-Match',
        ),
    ] = None


class BlocklistsSubscribeBlocklistPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsGetBlocklistSubscribersQueryParameters(BaseModelSdk):
    page: Annotated[
        Optional[int], Field(description='Page number', ge=1, title='Page')
    ] = 1
    size: Annotated[
        Optional[int], Field(description='Page size', ge=1, le=100, title='Size')
    ] = 50


class BlocklistsGetBlocklistSubscribersPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsUnsubscribeBlocklistPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]
    entity_id: Annotated[str, Field(title='Entity Id')]


class BlocklistsShareBlocklistPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]


class BlocklistsUnshareBlocklistPathParameters(BaseModelSdk):
    blocklist_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Blocklist Id')
    ]
    unshare_organization_id: Annotated[str, Field(title='Unshare Organization Id')]


class IntegrationsGetIntegrationsQueryParameters(BaseModelSdk):
    tag: Annotated[
        Optional[List[str]],
        Field(
            description='List of tags associated with the integrations (any of)',
            title='Tag',
        ),
    ] = None
    page: Annotated[
        Optional[int], Field(description='Page number', ge=1, title='Page')
    ] = 1
    size: Annotated[
        Optional[int], Field(description='Page size', ge=1, le=100, title='Size')
    ] = 50


class IntegrationsGetIntegrationPathParameters(BaseModelSdk):
    integration_id: Annotated[str, Field(title='Integration Id')]


class IntegrationsUpdateIntegrationPathParameters(BaseModelSdk):
    integration_id: Annotated[str, Field(title='Integration Id')]


class IntegrationsDeleteIntegrationPathParameters(BaseModelSdk):
    integration_id: Annotated[str, Field(title='Integration Id')]


class IntegrationsHeadIntegrationContentPathParameters(BaseModelSdk):
    integration_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Integration Id')
    ]


class PageSize(RootModel[int]):
    root: Annotated[
        int,
        Field(
            description='Maximum number of items to return, 0 means no limit (default), should be greater than 10000',
            ge=10000,
            title='Page Size',
        ),
    ]


class IntegrationsGetIntegrationContentQueryParameters(BaseModelSdk):
    page: Annotated[
        Optional[int], Field(description='Page number to return', ge=1, title='Page')
    ] = 1
    page_size: Annotated[
        Optional[PageSize],
        Field(
            description='Maximum number of items to return, 0 means no limit (default), should be greater than 10000',
            title='Page Size',
        ),
    ] = None


class IntegrationsGetIntegrationContentPathParameters(BaseModelSdk):
    integration_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Integration Id')
    ]


class IntegrationsGetIntegrationContentStreamQueryParameters(BaseModelSdk):
    startup: Annotated[
        Optional[bool],
        Field(
            description="Set to true if it's the first run to fetch all the content, otherwise only changes since the last pull.",
            title='Startup',
        ),
    ] = False


class IntegrationsGetIntegrationContentStreamPathParameters(BaseModelSdk):
    integration_id: Annotated[
        str, Field(examples=['5f9d88b9e5c4f5b9a3d3e8b1'], title='Integration Id')
    ]


class MetricsGetMetricsRemediationQueryParameters(BaseModelSdk):
    start_date: Annotated[
        Optional[datetime],
        Field(
            description='Start date of the metrics, default to last day',
            title='Start Date',
        ),
    ] = None
    end_date: Annotated[
        Optional[datetime],
        Field(description='End date of the metrics', title='End Date'),
    ] = None
    engine_ids: Annotated[
        Optional[List[str]], Field(description='List of engine ids', title='Engine Ids')
    ] = []
    tags: Annotated[
        Optional[List[str]], Field(description='List of tags', title='Tags')
    ] = []


class HubGetIndexQueryParameters(BaseModelSdk):
    with_content: Annotated[
        Optional[bool],
        Field(description='Include content in the index', title='With Content'),
    ] = False


class HubGetIndexPathParameters(BaseModelSdk):
    branch: Annotated[str, Field(title='Branch')]
    tenant: Annotated[str, Field(title='Tenant')]


class HubHeadIndexQueryParameters(BaseModelSdk):
    with_content: Annotated[
        Optional[bool],
        Field(description='Include content in the index', title='With Content'),
    ] = False


class HubHeadIndexPathParameters(BaseModelSdk):
    branch: Annotated[str, Field(title='Branch')]
    tenant: Annotated[str, Field(title='Tenant')]


class HubGetItemContentPathParameters(BaseModelSdk):
    item_path: Annotated[str, Field(title='Item Path')]
    branch: Annotated[str, Field(title='Branch')]
    tenant: Annotated[str, Field(title='Tenant')]


class HubHeadItemContentPathParameters(BaseModelSdk):
    item_path: Annotated[str, Field(title='Item Path')]
    branch: Annotated[str, Field(title='Branch')]
    tenant: Annotated[str, Field(title='Tenant')]


class AllowlistSubscriberEntity(BaseModelSdk):
    id: Annotated[str, Field(description='Subscriber entity id', title='Id')]
    entity_type: SubscriberEntityType


class AllowlistSubscribersCount(BaseModelSdk):
    entity_type: Annotated[
        SubscriberEntityType, Field(description='Subscriber entity type')
    ]
    count: Annotated[int, Field(description='Subscriber entity count', title='Count')]


class AllowlistSubscriptionRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    ids: Annotated[
        Optional[List[str]],
        Field(description='List of subscriber entity id', title='Ids'),
    ] = None
    entity_type: EntityType


class AllowlistUpdateResponse(BaseModelSdk):
    id: Annotated[
        str,
        Field(
            description='ID of the allowlist',
            examples=['5f9d88b9e5c4f5b9a3d3e8b1'],
            title='Id',
        ),
    ]
    organization_id: Annotated[
        str, Field(description='ID of the owner organization', title='Organization Id')
    ]
    name: Annotated[str, Field(description='Name of the allowlist', title='Name')]
    description: Annotated[
        Optional[str],
        Field(description='Description of the allowlist', title='Description'),
    ] = None
    created_at: Annotated[
        datetime,
        Field(description='Time the allowlist was created', title='Created At'),
    ]
    updated_at: Annotated[
        Optional[datetime],
        Field(description='Time the allowlist was updated', title='Updated At'),
    ] = None
    from_cti_query: Annotated[
        Optional[str],
        Field(
            description='CTI query from which the blocklist was created',
            title='From Cti Query',
        ),
    ] = None
    since: Annotated[
        Optional[str],
        Field(
            description='Since duration for the CTI query (eg. 5m, 2h, 7d). Max is 30 days',
            title='Since',
        ),
    ] = None
    total_items: Annotated[
        int, Field(description='Number of items in the allowlist', title='Total Items')
    ]
    subscribers: Annotated[
        Optional[List[AllowlistSubscribersCount]],
        Field(
            description='List of subscribers count by entity type', title='Subscribers'
        ),
    ] = []


class AttacksMetrics(BaseModelSdk):
    total: Annotated[
        Union[int, float], Field(description='Total value of the metric', title='Total')
    ]
    label: Annotated[
        str,
        Field(
            description='Label of the metric which is the attack type', title='Label'
        ),
    ]
    progression: Annotated[
        Optional[int],
        Field(
            description='Progression of the metric value from the previous period',
            title='Progression',
        ),
    ] = None
    data: Annotated[
        List[RemediationMetricsData], Field(description='Data points', title='Data')
    ]


class BlocklistContentStats(BaseModelSdk):
    model_config = ConfigDict(
        extra='allow',
    )
    total_seen: Annotated[Optional[int], Field(title='Total Seen')] = 0
    total_fire: Annotated[Optional[int], Field(title='Total Fire')] = 0
    total_seen_1m: Annotated[Optional[int], Field(title='Total Seen 1M')] = 0
    total_in_other_lists: Annotated[
        Optional[int], Field(title='Total In Other Lists')
    ] = 0
    total_false_positive: Annotated[
        Optional[int], Field(title='Total False Positive')
    ] = 0
    false_positive_removed_by_crowdsec: Annotated[
        Optional[int], Field(title='False Positive Removed By Crowdsec')
    ] = 0
    most_present_behaviors: Annotated[
        Optional[List[CtiBehavior]], Field(title='Most Present Behaviors')
    ] = []
    most_present_categories: Annotated[
        Optional[List[CtiCategory]], Field(title='Most Present Categories')
    ] = []
    most_present_scenarios: Annotated[
        Optional[List[CtiScenario]], Field(title='Most Present Scenarios')
    ] = []
    top_as: Annotated[Optional[List[CtiAs]], Field(title='Top As')] = []
    top_attacking_countries: Annotated[
        Optional[List[CtiCountry]], Field(title='Top Attacking Countries')
    ] = []
    top_ips: Annotated[Optional[List[CtiIp]], Field(title='Top Ips')] = []
    updated_at: Annotated[Optional[datetime], Field(title='Updated At')] = None


class BlocklistOrigin(BaseModelSdk):
    label: Annotated[str, Field(description='Label of the blocklist', title='Label')]
    id: Annotated[str, Field(description='ID of the blocklist', title='Id')]
    pricing_tier: Annotated[
        PricingTiers, Field(description='Pricing tier of the blocklist')
    ]


class BlocklistSearchRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    page: Annotated[
        Optional[int], Field(description='Page number', ge=1, title='Page')
    ] = 1
    page_size: Annotated[
        Optional[int], Field(description='Page size', le=1000, title='Page Size')
    ] = 100
    pricing_tiers: Annotated[
        Optional[List[PricingTiers]],
        Field(description='Pricing tiers', title='Pricing Tiers'),
    ] = []
    query: Annotated[
        Optional[str], Field(description='Search query', title='Query')
    ] = ''
    targeted_countries: Annotated[
        Optional[List[str]],
        Field(description='Targeted countries', title='Targeted Countries'),
    ] = []
    classifications: Annotated[
        Optional[List[str]],
        Field(description='Classifications', title='Classifications'),
    ] = []
    behaviors: Annotated[
        Optional[List[str]], Field(description='Behaviors', title='Behaviors')
    ] = []
    min_ips: Annotated[
        Optional[int], Field(description='Minimum number of IPs', ge=0, title='Min Ips')
    ] = 0
    sources: Annotated[
        Optional[List[BlocklistSources]], Field(description='Sources', title='Sources')
    ] = []
    categories: Annotated[
        Optional[List[str]], Field(description='Categories', title='Categories')
    ] = []
    is_private: Annotated[
        Optional[bool], Field(description='Private blocklist', title='Is Private')
    ] = None
    is_subscribed: Annotated[
        Optional[bool],
        Field(description='Subscribed blocklist (None: all)', title='Is Subscribed'),
    ] = None


class BlocklistShareRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    organizations: Annotated[
        List[Share],
        Field(
            description='List of organizations to share the blocklist',
            title='Organizations',
        ),
    ]


class BlocklistStats(BaseModelSdk):
    model_config = ConfigDict(
        extra='allow',
    )
    content_stats: Annotated[Optional[BlocklistContentStats], Field()] = {
        'total_seen': 0,
        'total_fire': 0,
        'total_seen_1m': 0,
        'total_in_other_lists': 0,
        'total_false_positive': 0,
        'false_positive_removed_by_crowdsec': 0,
        'most_present_behaviors': [],
        'most_present_categories': [],
        'most_present_scenarios': [],
        'top_as': [],
        'top_attacking_countries': [],
        'top_ips': [],
    }
    usage_stats: Optional[BlocklistUsageStats] = {
        'engines_subscribed_directly': 0,
        'engines_subscribed_through_org': 0,
        'engines_subscribed_through_tag': 0,
        'total_subscribed_engines': 0,
        'total_subscribed_organizations': 0,
    }
    addition_2days: Annotated[Optional[int], Field(title='Addition 2Days')] = 0
    addition_month: Annotated[Optional[int], Field(title='Addition Month')] = 0
    suppression_2days: Annotated[Optional[int], Field(title='Suppression 2Days')] = 0
    suppression_month: Annotated[Optional[int], Field(title='Suppression Month')] = 0
    change_2days_percentage: Annotated[
        Optional[float], Field(title='Change 2Days Percentage')
    ] = 0.0
    change_month_percentage: Annotated[
        Optional[float], Field(title='Change Month Percentage')
    ] = 0.0
    count: Annotated[Optional[int], Field(title='Count')] = 0
    updated_at: Annotated[Optional[datetime], Field(title='Updated At')] = None


class BlocklistSubscriberEntity(BaseModelSdk):
    id: Annotated[str, Field(description='Subscriber entity id', title='Id')]
    entity_type: SubscriberEntityType
    remediation: Annotated[str, Field(description='Remediation', title='Remediation')]


class BlocklistSubscribersCount(BaseModelSdk):
    entity_type: Annotated[
        SubscriberEntityType, Field(description='Subscriber entity type')
    ]
    count: Annotated[int, Field(description='Subscriber entity count', title='Count')]


class BlocklistSubscriptionRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    ids: Annotated[
        Optional[List[str]],
        Field(description='List of subscriber entity id', title='Ids'),
    ] = None
    entity_type: SubscriberEntityType
    remediation: Annotated[
        Optional[str], Field(description='Remediation', title='Remediation')
    ] = None


class HTTPValidationError(BaseModelSdk):
    detail: Annotated[Optional[List[ValidationError]], Field(title='Detail')] = None


class IntegrationCreateRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[
        str, Field(description='Name of the integration', min_length=1, title='Name')
    ]
    description: Annotated[
        Optional[str],
        Field(
            description='Description of the integration',
            min_length=1,
            title='Description',
        ),
    ] = None
    entity_type: Annotated[
        IntegrationType, Field(description='Type of the integration')
    ]
    output_format: Annotated[
        OutputFormat, Field(description='Output format of the integration')
    ]


class IntegrationCreateResponse(BaseModelSdk):
    id: Annotated[str, Field(description='ID of the integration', title='Id')]
    name: Annotated[
        str,
        Field(
            description='Name of the integration. Should be unique within the organization',
            title='Name',
        ),
    ]
    organization_id: Annotated[
        str, Field(description='ID of the owner organization', title='Organization Id')
    ]
    description: Annotated[
        Optional[str],
        Field(description='Description of the integration', title='Description'),
    ] = None
    created_at: Annotated[
        datetime,
        Field(description='Time the integration was created', title='Created At'),
    ]
    updated_at: Annotated[
        datetime,
        Field(description='Last time the integration was updated', title='Updated At'),
    ]
    entity_type: Annotated[
        IntegrationType, Field(description='Type of the integration')
    ]
    output_format: Annotated[
        OutputFormat, Field(description='Output format of the integration')
    ]
    last_pull: Annotated[
        Optional[datetime],
        Field(
            description='Last time the integration pulled blocklists', title='Last Pull'
        ),
    ] = None
    blocklists: Annotated[
        List[BlocklistSubscription],
        Field(
            description='Blocklists that are subscribed by the integration',
            title='Blocklists',
        ),
    ]
    endpoint: Annotated[
        AnyUrl,
        Field(
            description="Url that should be used by the firewall or the remediation component to fetch the integration's content",
            title='Endpoint',
        ),
    ]
    stats: Annotated[Optional[Stats], Field(description='Stats of the integration')] = {
        'count': 0
    }
    tags: Annotated[
        Optional[List[str]],
        Field(description='Tags associated with the integration', title='Tags'),
    ] = []
    credentials: Annotated[
        Union[ApiKeyCredentials, BasicAuthCredentials],
        Field(
            description='Credentials that were generated for the integration',
            title='Credentials',
        ),
    ]


class IntegrationGetResponse(BaseModelSdk):
    id: Annotated[str, Field(description='ID of the integration', title='Id')]
    name: Annotated[
        str,
        Field(
            description='Name of the integration. Should be unique within the organization',
            title='Name',
        ),
    ]
    organization_id: Annotated[
        str, Field(description='ID of the owner organization', title='Organization Id')
    ]
    description: Annotated[
        Optional[str],
        Field(description='Description of the integration', title='Description'),
    ] = None
    created_at: Annotated[
        datetime,
        Field(description='Time the integration was created', title='Created At'),
    ]
    updated_at: Annotated[
        datetime,
        Field(description='Last time the integration was updated', title='Updated At'),
    ]
    entity_type: Annotated[
        IntegrationType, Field(description='Type of the integration')
    ]
    output_format: Annotated[
        OutputFormat, Field(description='Output format of the integration')
    ]
    last_pull: Annotated[
        Optional[datetime],
        Field(
            description='Last time the integration pulled blocklists', title='Last Pull'
        ),
    ] = None
    blocklists: Annotated[
        List[BlocklistSubscription],
        Field(
            description='Blocklists that are subscribed by the integration',
            title='Blocklists',
        ),
    ]
    endpoint: Annotated[
        AnyUrl,
        Field(
            description="Url that should be used by the firewall or the remediation component to fetch the integration's content",
            title='Endpoint',
        ),
    ]
    stats: Annotated[Optional[Stats], Field(description='Stats of the integration')] = {
        'count': 0
    }
    tags: Annotated[
        Optional[List[str]],
        Field(description='Tags associated with the integration', title='Tags'),
    ] = []


class IntegrationUpdateRequest(BaseModelSdk):
    model_config = ConfigDict(
        extra='forbid',
    )
    name: Annotated[
        Optional[str], Field(description='New name', min_length=1, title='Name')
    ] = None
    description: Annotated[
        Optional[str],
        Field(description='New description', min_length=1, title='Description'),
    ] = None
    output_format: Annotated[
        Optional[OutputFormat], Field(description='New output format')
    ] = None
    regenerate_credentials: Annotated[
        Optional[bool],
        Field(
            description='Regenerate credentials for the integration',
            title='Regenerate Credentials',
        ),
    ] = None


class IntegrationUpdateResponse(BaseModelSdk):
    id: Annotated[str, Field(description='ID of the integration', title='Id')]
    name: Annotated[
        str,
        Field(
            description='Name of the integration. Should be unique within the organization',
            title='Name',
        ),
    ]
    organization_id: Annotated[
        str, Field(description='ID of the owner organization', title='Organization Id')
    ]
    description: Annotated[
        Optional[str],
        Field(description='Description of the integration', title='Description'),
    ] = None
    created_at: Annotated[
        datetime,
        Field(description='Time the integration was created', title='Created At'),
    ]
    updated_at: Annotated[
        datetime,
        Field(description='Last time the integration was updated', title='Updated At'),
    ]
    entity_type: Annotated[
        IntegrationType, Field(description='Type of the integration')
    ]
    output_format: Annotated[
        OutputFormat, Field(description='Output format of the integration')
    ]
    last_pull: Annotated[
        Optional[datetime],
        Field(
            description='Last time the integration pulled blocklists', title='Last Pull'
        ),
    ] = None
    blocklists: Annotated[
        List[BlocklistSubscription],
        Field(
            description='Blocklists that are subscribed by the integration',
            title='Blocklists',
        ),
    ]
    endpoint: Annotated[
        AnyUrl,
        Field(
            description="Url that should be used by the firewall or the remediation component to fetch the integration's content",
            title='Endpoint',
        ),
    ]
    stats: Annotated[Optional[Stats], Field(description='Stats of the integration')] = {
        'count': 0
    }
    tags: Annotated[
        Optional[List[str]],
        Field(description='Tags associated with the integration', title='Tags'),
    ] = []
    credentials: Annotated[
        Optional[Union[ApiKeyCredentials, BasicAuthCredentials]],
        Field(description='Credentials for the integration', title='Credentials'),
    ] = None


class OriginMetrics(BaseModelSdk):
    origin: Annotated[
        Optional[Union[BlocklistOrigin, str]],
        Field(description='Origin of the metric', title='Origin'),
    ] = None
    data: Annotated[
        List[RemediationMetricsData], Field(description='Data points', title='Data')
    ]


class PageTAnyCustomizedAllowlistSubscriberEntity(BaseModelSdk):
    items: Annotated[List[AllowlistSubscriberEntity], Field(title='Items')]
    total: Annotated[Optional[Total], Field(title='Total')] = None
    page: Annotated[Optional[Page], Field(title='Page')] = None
    size: Annotated[Optional[Size], Field(title='Size')] = None
    pages: Annotated[Optional[Pages], Field(title='Pages')] = None
    links: Links


class PageTAnyCustomizedBlocklistSubscriberEntity(BaseModelSdk):
    items: Annotated[List[BlocklistSubscriberEntity], Field(title='Items')]
    total: Annotated[Optional[Total], Field(title='Total')] = None
    page: Annotated[Optional[Page], Field(title='Page')] = None
    size: Annotated[Optional[Size], Field(title='Size')] = None
    pages: Annotated[Optional[Pages], Field(title='Pages')] = None
    links: Links


class PageTAnyCustomizedIntegrationGetResponse(BaseModelSdk):
    items: Annotated[List[IntegrationGetResponse], Field(title='Items')]
    total: Annotated[Optional[Total], Field(title='Total')] = None
    page: Annotated[Optional[Page], Field(title='Page')] = None
    size: Annotated[Optional[Size], Field(title='Size')] = None
    pages: Annotated[Optional[Pages], Field(title='Pages')] = None
    links: Links


class PublicBlocklistResponse(BaseModelSdk):
    id: Annotated[str, Field(description='Blocklist id', title='Id')]
    created_at: Annotated[
        datetime, Field(description='Blocklist creation date', title='Created At')
    ]
    updated_at: Annotated[
        datetime, Field(description='Blocklist update date', title='Updated At')
    ]
    name: Annotated[
        str,
        Field(
            description='Blocklist name, unique within the organization', title='Name'
        ),
    ]
    label: Annotated[
        Optional[str], Field(description='Blocklist human readable name', title='Label')
    ] = None
    description: Annotated[
        str, Field(description='Blocklist description', title='Description')
    ]
    references: Annotated[
        Optional[List[str]],
        Field(description='Blocklist references', title='References'),
    ] = []
    is_private: Annotated[
        bool,
        Field(
            description='Private blocklist if True or public if False',
            title='Is Private',
        ),
    ]
    tags: Annotated[
        Optional[List[str]], Field(description='Classification tags', title='Tags')
    ] = []
    pricing_tier: Annotated[
        PricingTiers, Field(description='Pricing tier for Crowdsec blocklists only')
    ]
    source: Annotated[BlocklistSources, Field(description='Blocklist source')]
    stats: Annotated[BlocklistStats, Field(description='Blocklist stats')]
    from_cti_query: Annotated[
        Optional[str],
        Field(
            description='CTI query from which the blocklist was created',
            title='From Cti Query',
        ),
    ] = None
    since: Annotated[
        Optional[str],
        Field(
            description='Since duration for the CTI query (eg. 5m, 2h, 7d). Max is 30 days',
            title='Since',
        ),
    ] = None
    shared_with: Annotated[
        Optional[List[Share]],
        Field(description='List of organizations shared with', title='Shared With'),
    ] = []
    organization_id: Annotated[
        Optional[str],
        Field(
            description="Blocklists owner's organization id", title='Organization Id'
        ),
    ] = None
    subscribers: Annotated[
        Optional[List[BlocklistSubscribersCount]],
        Field(
            description='List of subscribers to the blocklist. Only subscribers belonging to your organization are returned',
            title='Subscribers',
        ),
    ] = []
    categories: Annotated[
        Optional[List[BlocklistCategory]],
        Field(description='List of categories for the blocklist', title='Categories'),
    ] = []


class PublicPaginatedBlocklistResponse(BaseModelSdk):
    items: Annotated[
        List[PublicBlocklistResponse],
        Field(description='List of blocklists', title='Items'),
    ]
    page: Annotated[int, Field(description='Page number', title='Page')]
    total: Annotated[
        int, Field(description='Total number of blocklists', title='Total')
    ]
    size: Annotated[int, Field(description='Page size', title='Size')]
    pages: Annotated[int, Field(description='Total number of pages', title='Pages')]


class RemediationMetrics(BaseModelSdk):
    total: Annotated[
        Union[int, float], Field(description='Total value of the metric', title='Total')
    ]
    unit: Annotated[MetricUnits, Field(description='Unit of the metric')]
    progression: Annotated[
        Optional[int],
        Field(
            description='Progression of the metric value from the previous period',
            title='Progression',
        ),
    ] = None
    data: Annotated[
        List[OriginMetrics], Field(description='Data points per origin', title='Data')
    ]


class SourceInfo(BaseModelSdk):
    source_type: Annotated[
        SourceType,
        Field(description='The source type that created the allowlist entry'),
    ]
    identifier: Annotated[
        str,
        Field(
            description='The source identifier that created the allowlist entry',
            title='Identifier',
        ),
    ]


class AppsecConfigIndex(BaseModelSdk):
    content: Annotated[
        Optional[str],
        Field(
            description='The YAML content of the item, in plaintext.',
            examples=[
                'type: leaky\n#debug: true\nname: crowdsecurity/vsftpd-bf\ndescription: "Detect FTP bruteforce (vsftpd)"\nfilter: evt.Meta.log_type == \'ftp_failed_auth\'\nleakspeed: "10s"\ncapacity: 5\ngroupby: evt.Meta.source_ip\nblackhole: 5m\nlabels:\n  confidence: 3\n  spoofable: 0\n  classification:\n    - attack.T1110\n  behavior: "ftp:bruteforce"\n  label: "VSFTPD Bruteforce"\n  remediation: true\n  service: vsftpd'
            ],
            title='Content',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A short, plaintext description of the item',
            title='Description',
        ),
    ] = None
    labels: Annotated[
        Optional[Dict[str, Union[str, List[str], int]]],
        Field(
            description='Classification labels for the item',
            examples=[
                {
                    'behavior': 'ftp:bruteforce',
                    'classification': ['attack.T1110'],
                    'confidence': 3,
                    'label': 'VSFTPD Bruteforce',
                    'remediation': True,
                    'service': 'vsftpd',
                    'spoofable': 0,
                }
            ],
            title='Labels',
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Relative path to the item's YAML content",
            examples=['scenarios/crowdsecurity/vsftpd-bf.yaml'],
            title='Path',
        ),
    ] = None
    references: Annotated[
        Optional[List[str]],
        Field(
            description='List of references to external resources', title='References'
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description='Current version of the collection',
            examples=['0.2'],
            title='Version',
        ),
    ] = None
    versions: Annotated[
        Optional[Dict[str, VersionDetail]],
        Field(
            description="A dictionary where each key is a version number (e.g., '0.1', '0.2')",
            examples=[
                {
                    '0.1': {
                        'deprecated': False,
                        'digest': '3591247988014705cf3a7e42388f0c87f9b86d3141268d996c5820ceab6364e1',
                    },
                    '0.2': {
                        'deprecated': False,
                        'digest': 'd1ddf4797250c1899a93ce634e6366e5deaaaf7508135056d17e9b09998ddf91',
                    },
                }
            ],
            title='Versions',
        ),
    ] = None


class AppsecRuleIndex(BaseModelSdk):
    content: Annotated[
        Optional[str],
        Field(
            description='The YAML content of the item, in plaintext.',
            examples=[
                'type: leaky\n#debug: true\nname: crowdsecurity/vsftpd-bf\ndescription: "Detect FTP bruteforce (vsftpd)"\nfilter: evt.Meta.log_type == \'ftp_failed_auth\'\nleakspeed: "10s"\ncapacity: 5\ngroupby: evt.Meta.source_ip\nblackhole: 5m\nlabels:\n  confidence: 3\n  spoofable: 0\n  classification:\n    - attack.T1110\n  behavior: "ftp:bruteforce"\n  label: "VSFTPD Bruteforce"\n  remediation: true\n  service: vsftpd'
            ],
            title='Content',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A short, plaintext description of the item',
            title='Description',
        ),
    ] = None
    labels: Annotated[
        Optional[Dict[str, Union[str, List[str], int]]],
        Field(
            description='Classification labels for the item',
            examples=[
                {
                    'behavior': 'ftp:bruteforce',
                    'classification': ['attack.T1110'],
                    'confidence': 3,
                    'label': 'VSFTPD Bruteforce',
                    'remediation': True,
                    'service': 'vsftpd',
                    'spoofable': 0,
                }
            ],
            title='Labels',
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Relative path to the item's YAML content",
            examples=['scenarios/crowdsecurity/vsftpd-bf.yaml'],
            title='Path',
        ),
    ] = None
    references: Annotated[
        Optional[List[str]],
        Field(
            description='List of references to external resources', title='References'
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description='Current version of the collection',
            examples=['0.2'],
            title='Version',
        ),
    ] = None
    versions: Annotated[
        Optional[Dict[str, VersionDetail]],
        Field(
            description="A dictionary where each key is a version number (e.g., '0.1', '0.2')",
            examples=[
                {
                    '0.1': {
                        'deprecated': False,
                        'digest': '3591247988014705cf3a7e42388f0c87f9b86d3141268d996c5820ceab6364e1',
                    },
                    '0.2': {
                        'deprecated': False,
                        'digest': 'd1ddf4797250c1899a93ce634e6366e5deaaaf7508135056d17e9b09998ddf91',
                    },
                }
            ],
            title='Versions',
        ),
    ] = None


class CollectionIndex(BaseModelSdk):
    appsec_configs: Annotated[
        Optional[List[str]],
        Field(
            alias='appsec-configs',
            description='List of appsec-configs',
            title='Appsec-Configs',
        ),
    ] = None
    appsec_rules: Annotated[
        Optional[List[str]],
        Field(
            alias='appsec-rules',
            description='List of appsec-rules',
            title='Appsec-Rules',
        ),
    ] = None
    collections: Annotated[
        Optional[List[str]],
        Field(description='List of collections', title='Collections'),
    ] = None
    content: Annotated[
        Optional[str],
        Field(
            description='The YAML content of the item, in plaintext.',
            examples=[
                'type: leaky\n#debug: true\nname: crowdsecurity/vsftpd-bf\ndescription: "Detect FTP bruteforce (vsftpd)"\nfilter: evt.Meta.log_type == \'ftp_failed_auth\'\nleakspeed: "10s"\ncapacity: 5\ngroupby: evt.Meta.source_ip\nblackhole: 5m\nlabels:\n  confidence: 3\n  spoofable: 0\n  classification:\n    - attack.T1110\n  behavior: "ftp:bruteforce"\n  label: "VSFTPD Bruteforce"\n  remediation: true\n  service: vsftpd'
            ],
            title='Content',
        ),
    ] = None
    contexts: Annotated[
        Optional[List[str]], Field(description='List of contexts', title='Contexts')
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A short, plaintext description of the item',
            title='Description',
        ),
    ] = None
    labels: Annotated[
        Optional[Dict[str, Union[str, List[str], int]]],
        Field(
            description='Classification labels for the item',
            examples=[
                {
                    'behavior': 'ftp:bruteforce',
                    'classification': ['attack.T1110'],
                    'confidence': 3,
                    'label': 'VSFTPD Bruteforce',
                    'remediation': True,
                    'service': 'vsftpd',
                    'spoofable': 0,
                }
            ],
            title='Labels',
        ),
    ] = None
    parsers: Annotated[
        Optional[List[str]], Field(description='List of parsers', title='Parsers')
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Relative path to the item's YAML content",
            examples=['scenarios/crowdsecurity/vsftpd-bf.yaml'],
            title='Path',
        ),
    ] = None
    postoverflows: Annotated[
        Optional[List[str]],
        Field(description='List of postoverflows', title='Postoverflows'),
    ] = None
    references: Annotated[
        Optional[List[str]],
        Field(
            description='List of references to external resources', title='References'
        ),
    ] = None
    scenarios: Annotated[
        Optional[List[str]], Field(description='List of scenarios', title='Scenarios')
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description='Current version of the collection',
            examples=['0.2'],
            title='Version',
        ),
    ] = None
    versions: Annotated[
        Optional[Dict[str, VersionDetail]],
        Field(
            description="A dictionary where each key is a version number (e.g., '0.1', '0.2')",
            examples=[
                {
                    '0.1': {
                        'deprecated': False,
                        'digest': '3591247988014705cf3a7e42388f0c87f9b86d3141268d996c5820ceab6364e1',
                    },
                    '0.2': {
                        'deprecated': False,
                        'digest': 'd1ddf4797250c1899a93ce634e6366e5deaaaf7508135056d17e9b09998ddf91',
                    },
                }
            ],
            title='Versions',
        ),
    ] = None


class ContextIndex(BaseModelSdk):
    content: Annotated[
        Optional[str],
        Field(
            description='The YAML content of the item, in plaintext.',
            examples=[
                'type: leaky\n#debug: true\nname: crowdsecurity/vsftpd-bf\ndescription: "Detect FTP bruteforce (vsftpd)"\nfilter: evt.Meta.log_type == \'ftp_failed_auth\'\nleakspeed: "10s"\ncapacity: 5\ngroupby: evt.Meta.source_ip\nblackhole: 5m\nlabels:\n  confidence: 3\n  spoofable: 0\n  classification:\n    - attack.T1110\n  behavior: "ftp:bruteforce"\n  label: "VSFTPD Bruteforce"\n  remediation: true\n  service: vsftpd'
            ],
            title='Content',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A short, plaintext description of the item',
            title='Description',
        ),
    ] = None
    labels: Annotated[
        Optional[Dict[str, Union[str, List[str], int]]],
        Field(
            description='Classification labels for the item',
            examples=[
                {
                    'behavior': 'ftp:bruteforce',
                    'classification': ['attack.T1110'],
                    'confidence': 3,
                    'label': 'VSFTPD Bruteforce',
                    'remediation': True,
                    'service': 'vsftpd',
                    'spoofable': 0,
                }
            ],
            title='Labels',
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Relative path to the item's YAML content",
            examples=['scenarios/crowdsecurity/vsftpd-bf.yaml'],
            title='Path',
        ),
    ] = None
    references: Annotated[
        Optional[List[str]],
        Field(
            description='List of references to external resources', title='References'
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description='Current version of the collection',
            examples=['0.2'],
            title='Version',
        ),
    ] = None
    versions: Annotated[
        Optional[Dict[str, VersionDetail]],
        Field(
            description="A dictionary where each key is a version number (e.g., '0.1', '0.2')",
            examples=[
                {
                    '0.1': {
                        'deprecated': False,
                        'digest': '3591247988014705cf3a7e42388f0c87f9b86d3141268d996c5820ceab6364e1',
                    },
                    '0.2': {
                        'deprecated': False,
                        'digest': 'd1ddf4797250c1899a93ce634e6366e5deaaaf7508135056d17e9b09998ddf91',
                    },
                }
            ],
            title='Versions',
        ),
    ] = None


class ParserIndex(BaseModelSdk):
    content: Annotated[
        Optional[str],
        Field(
            description='The YAML content of the item, in plaintext.',
            examples=[
                'type: leaky\n#debug: true\nname: crowdsecurity/vsftpd-bf\ndescription: "Detect FTP bruteforce (vsftpd)"\nfilter: evt.Meta.log_type == \'ftp_failed_auth\'\nleakspeed: "10s"\ncapacity: 5\ngroupby: evt.Meta.source_ip\nblackhole: 5m\nlabels:\n  confidence: 3\n  spoofable: 0\n  classification:\n    - attack.T1110\n  behavior: "ftp:bruteforce"\n  label: "VSFTPD Bruteforce"\n  remediation: true\n  service: vsftpd'
            ],
            title='Content',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A short, plaintext description of the item',
            title='Description',
        ),
    ] = None
    labels: Annotated[
        Optional[Dict[str, Union[str, List[str], int]]],
        Field(
            description='Classification labels for the item',
            examples=[
                {
                    'behavior': 'ftp:bruteforce',
                    'classification': ['attack.T1110'],
                    'confidence': 3,
                    'label': 'VSFTPD Bruteforce',
                    'remediation': True,
                    'service': 'vsftpd',
                    'spoofable': 0,
                }
            ],
            title='Labels',
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Relative path to the item's YAML content",
            examples=['scenarios/crowdsecurity/vsftpd-bf.yaml'],
            title='Path',
        ),
    ] = None
    references: Annotated[
        Optional[List[str]],
        Field(
            description='List of references to external resources', title='References'
        ),
    ] = None
    stage: Annotated[str, Field(description='The stage of the parser', title='Stage')]
    version: Annotated[
        Optional[str],
        Field(
            description='Current version of the collection',
            examples=['0.2'],
            title='Version',
        ),
    ] = None
    versions: Annotated[
        Optional[Dict[str, VersionDetail]],
        Field(
            description="A dictionary where each key is a version number (e.g., '0.1', '0.2')",
            examples=[
                {
                    '0.1': {
                        'deprecated': False,
                        'digest': '3591247988014705cf3a7e42388f0c87f9b86d3141268d996c5820ceab6364e1',
                    },
                    '0.2': {
                        'deprecated': False,
                        'digest': 'd1ddf4797250c1899a93ce634e6366e5deaaaf7508135056d17e9b09998ddf91',
                    },
                }
            ],
            title='Versions',
        ),
    ] = None


class PostoverflowIndex(BaseModelSdk):
    content: Annotated[
        Optional[str],
        Field(
            description='The YAML content of the item, in plaintext.',
            examples=[
                'type: leaky\n#debug: true\nname: crowdsecurity/vsftpd-bf\ndescription: "Detect FTP bruteforce (vsftpd)"\nfilter: evt.Meta.log_type == \'ftp_failed_auth\'\nleakspeed: "10s"\ncapacity: 5\ngroupby: evt.Meta.source_ip\nblackhole: 5m\nlabels:\n  confidence: 3\n  spoofable: 0\n  classification:\n    - attack.T1110\n  behavior: "ftp:bruteforce"\n  label: "VSFTPD Bruteforce"\n  remediation: true\n  service: vsftpd'
            ],
            title='Content',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A short, plaintext description of the item',
            title='Description',
        ),
    ] = None
    labels: Annotated[
        Optional[Dict[str, Union[str, List[str], int]]],
        Field(
            description='Classification labels for the item',
            examples=[
                {
                    'behavior': 'ftp:bruteforce',
                    'classification': ['attack.T1110'],
                    'confidence': 3,
                    'label': 'VSFTPD Bruteforce',
                    'remediation': True,
                    'service': 'vsftpd',
                    'spoofable': 0,
                }
            ],
            title='Labels',
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Relative path to the item's YAML content",
            examples=['scenarios/crowdsecurity/vsftpd-bf.yaml'],
            title='Path',
        ),
    ] = None
    references: Annotated[
        Optional[List[str]],
        Field(
            description='List of references to external resources', title='References'
        ),
    ] = None
    stage: Annotated[
        str, Field(description='The stage of the postoverflow', title='Stage')
    ]
    version: Annotated[
        Optional[str],
        Field(
            description='Current version of the collection',
            examples=['0.2'],
            title='Version',
        ),
    ] = None
    versions: Annotated[
        Optional[Dict[str, VersionDetail]],
        Field(
            description="A dictionary where each key is a version number (e.g., '0.1', '0.2')",
            examples=[
                {
                    '0.1': {
                        'deprecated': False,
                        'digest': '3591247988014705cf3a7e42388f0c87f9b86d3141268d996c5820ceab6364e1',
                    },
                    '0.2': {
                        'deprecated': False,
                        'digest': 'd1ddf4797250c1899a93ce634e6366e5deaaaf7508135056d17e9b09998ddf91',
                    },
                }
            ],
            title='Versions',
        ),
    ] = None


class ScenarioIndex(BaseModelSdk):
    content: Annotated[
        Optional[str],
        Field(
            description='The YAML content of the item, in plaintext.',
            examples=[
                'type: leaky\n#debug: true\nname: crowdsecurity/vsftpd-bf\ndescription: "Detect FTP bruteforce (vsftpd)"\nfilter: evt.Meta.log_type == \'ftp_failed_auth\'\nleakspeed: "10s"\ncapacity: 5\ngroupby: evt.Meta.source_ip\nblackhole: 5m\nlabels:\n  confidence: 3\n  spoofable: 0\n  classification:\n    - attack.T1110\n  behavior: "ftp:bruteforce"\n  label: "VSFTPD Bruteforce"\n  remediation: true\n  service: vsftpd'
            ],
            title='Content',
        ),
    ] = None
    description: Annotated[
        Optional[str],
        Field(
            description='A short, plaintext description of the item',
            title='Description',
        ),
    ] = None
    labels: Annotated[
        Optional[Dict[str, Union[str, List[str], int]]],
        Field(
            description='Classification labels for the item',
            examples=[
                {
                    'behavior': 'ftp:bruteforce',
                    'classification': ['attack.T1110'],
                    'confidence': 3,
                    'label': 'VSFTPD Bruteforce',
                    'remediation': True,
                    'service': 'vsftpd',
                    'spoofable': 0,
                }
            ],
            title='Labels',
        ),
    ] = None
    path: Annotated[
        Optional[str],
        Field(
            description="Relative path to the item's YAML content",
            examples=['scenarios/crowdsecurity/vsftpd-bf.yaml'],
            title='Path',
        ),
    ] = None
    references: Annotated[
        Optional[List[str]],
        Field(
            description='List of references to external resources', title='References'
        ),
    ] = None
    version: Annotated[
        Optional[str],
        Field(
            description='Current version of the collection',
            examples=['0.2'],
            title='Version',
        ),
    ] = None
    versions: Annotated[
        Optional[Dict[str, VersionDetail]],
        Field(
            description="A dictionary where each key is a version number (e.g., '0.1', '0.2')",
            examples=[
                {
                    '0.1': {
                        'deprecated': False,
                        'digest': '3591247988014705cf3a7e42388f0c87f9b86d3141268d996c5820ceab6364e1',
                    },
                    '0.2': {
                        'deprecated': False,
                        'digest': 'd1ddf4797250c1899a93ce634e6366e5deaaaf7508135056d17e9b09998ddf91',
                    },
                }
            ],
            title='Versions',
        ),
    ] = None


class AllowlistGetItemsResponse(BaseModelSdk):
    id: Annotated[
        str,
        Field(
            description='ID of the allowlist entry',
            examples=['5f9d88b9e5c4f5b9a3d3e8b1'],
            title='Id',
        ),
    ]
    allowlist_id: Annotated[
        str,
        Field(
            description='ID of the allowlist',
            examples=['5f9d88b9e5c4f5b9a3d3e8b1'],
            title='Allowlist Id',
        ),
    ]
    description: Annotated[
        str,
        Field(
            description='Description of the allowlist entry',
            min_length=1,
            title='Description',
        ),
    ]
    scope: Annotated[AllowlistScope, Field(description='Scope of the allowlist entry')]
    value: Annotated[
        str, Field(description='Value of the allowlist entry', title='Value')
    ]
    created_at: Annotated[
        datetime,
        Field(description='Time the allowlist entry was created', title='Created At'),
    ]
    updated_at: Annotated[
        Optional[datetime],
        Field(description='Time the allowlist entry was updated', title='Updated At'),
    ] = None
    created_by: Annotated[
        SourceInfo, Field(description='The source user who created the allowlist entry')
    ]
    updated_by: Annotated[
        Optional[SourceInfo],
        Field(description='The source user who updated the allowlist entry'),
    ] = None
    expiration: Annotated[
        Optional[datetime],
        Field(description='Time the allowlist entry will expire', title='Expiration'),
    ] = None


class AllowlistGetResponse(BaseModelSdk):
    id: Annotated[
        str,
        Field(
            description='ID of the allowlist',
            examples=['5f9d88b9e5c4f5b9a3d3e8b1'],
            title='Id',
        ),
    ]
    organization_id: Annotated[
        str, Field(description='ID of the owner organization', title='Organization Id')
    ]
    name: Annotated[str, Field(description='Name of the allowlist', title='Name')]
    description: Annotated[
        Optional[str],
        Field(description='Description of the allowlist', title='Description'),
    ] = None
    created_at: Annotated[
        datetime,
        Field(description='Time the allowlist was created', title='Created At'),
    ]
    updated_at: Annotated[
        Optional[datetime],
        Field(description='Time the allowlist was updated', title='Updated At'),
    ] = None
    from_cti_query: Annotated[
        Optional[str],
        Field(
            description='CTI query from which the blocklist was created',
            title='From Cti Query',
        ),
    ] = None
    since: Annotated[
        Optional[str],
        Field(
            description='Since duration for the CTI query (eg. 5m, 2h, 7d). Max is 30 days',
            title='Since',
        ),
    ] = None
    total_items: Annotated[
        int, Field(description='Number of items in the allowlist', title='Total Items')
    ]
    subscribers: Annotated[
        Optional[List[AllowlistSubscribersCount]],
        Field(
            description='List of subscribers count by entity type', title='Subscribers'
        ),
    ] = []


class AllowlistItemUpdateResponse(BaseModelSdk):
    id: Annotated[
        str,
        Field(
            description='ID of the allowlist entry',
            examples=['5f9d88b9e5c4f5b9a3d3e8b1'],
            title='Id',
        ),
    ]
    allowlist_id: Annotated[
        str,
        Field(
            description='ID of the allowlist',
            examples=['5f9d88b9e5c4f5b9a3d3e8b1'],
            title='Allowlist Id',
        ),
    ]
    description: Annotated[
        str,
        Field(
            description='Description of the allowlist entry',
            min_length=1,
            title='Description',
        ),
    ]
    scope: Annotated[AllowlistScope, Field(description='Scope of the allowlist entry')]
    value: Annotated[
        str, Field(description='Value of the allowlist entry', title='Value')
    ]
    created_at: Annotated[
        datetime,
        Field(description='Time the allowlist entry was created', title='Created At'),
    ]
    updated_at: Annotated[
        datetime,
        Field(description='Time the allowlist entry was updated', title='Updated At'),
    ]
    created_by: Annotated[
        SourceInfo, Field(description='The source user who created the allowlist entry')
    ]
    updated_by: Annotated[
        SourceInfo, Field(description='The source user who updated the allowlist entry')
    ]
    expiration: Annotated[
        Optional[datetime],
        Field(description='Time the allowlist entry will expire', title='Expiration'),
    ] = None


class ComputedSavedMetrics(BaseModelSdk):
    log_lines: Annotated[
        Optional[List[RemediationMetrics]],
        Field(description='estimated log lines saved', title='Log Lines'),
    ] = []
    storage: Annotated[
        Optional[List[RemediationMetrics]],
        Field(description='estimated storage saved', title='Storage'),
    ] = []
    egress_traffic: Annotated[
        Optional[List[RemediationMetrics]],
        Field(description='estimated egress traffic saved', title='Egress Traffic'),
    ] = []


class PageTAnyCustomizedAllowlistGetItemsResponse(BaseModelSdk):
    items: Annotated[List[AllowlistGetItemsResponse], Field(title='Items')]
    total: Annotated[Optional[Total], Field(title='Total')] = None
    page: Annotated[Optional[Page], Field(title='Page')] = None
    size: Annotated[Optional[Size], Field(title='Size')] = None
    pages: Annotated[Optional[Pages], Field(title='Pages')] = None
    links: Links


class PageTAnyCustomizedAllowlistGetResponse(BaseModelSdk):
    items: Annotated[List[AllowlistGetResponse], Field(title='Items')]
    total: Annotated[Optional[Total], Field(title='Total')] = None
    page: Annotated[Optional[Page], Field(title='Page')] = None
    size: Annotated[Optional[Size], Field(title='Size')] = None
    pages: Annotated[Optional[Pages], Field(title='Pages')] = None
    links: Links


class PageTAnyCustomizedPublicBlocklistResponse(BaseModelSdk):
    items: Annotated[List[PublicBlocklistResponse], Field(title='Items')]
    total: Annotated[Optional[Total], Field(title='Total')] = None
    page: Annotated[Optional[Page], Field(title='Page')] = None
    size: Annotated[Optional[Size], Field(title='Size')] = None
    pages: Annotated[Optional[Pages], Field(title='Pages')] = None
    links: Links


class RawMetrics(BaseModelSdk):
    dropped: Annotated[
        Optional[List[RemediationMetrics]],
        Field(description='dropped metrics', title='Dropped'),
    ] = []
    processed: Annotated[
        Optional[List[RemediationMetrics]],
        Field(description='processed metrics', title='Processed'),
    ] = []


class Index(BaseModelSdk):
    appsec_configs: Annotated[
        Optional[Dict[str, AppsecConfigIndex]],
        Field(alias='appsec-configs', title='Appsec-Configs'),
    ] = None
    appsec_rules: Annotated[
        Optional[Dict[str, AppsecRuleIndex]],
        Field(alias='appsec-rules', title='Appsec-Rules'),
    ] = None
    collections: Annotated[
        Optional[Dict[str, CollectionIndex]], Field(title='Collections')
    ] = None
    contexts: Annotated[Optional[Dict[str, ContextIndex]], Field(title='Contexts')] = (
        None
    )
    parsers: Annotated[Optional[Dict[str, ParserIndex]], Field(title='Parsers')] = None
    postoverflows: Annotated[
        Optional[Dict[str, PostoverflowIndex]], Field(title='Postoverflows')
    ] = None
    scenarios: Annotated[
        Optional[Dict[str, ScenarioIndex]], Field(title='Scenarios')
    ] = None


class ComputedMetrics(BaseModelSdk):
    saved: Annotated[ComputedSavedMetrics, Field(description='estimated saved metrics')]
    dropped: Annotated[
        Optional[List[RemediationMetrics]],
        Field(description='estimated dropped metrics', title='Dropped'),
    ] = []
    prevented: Annotated[
        Optional[List[AttacksMetrics]],
        Field(description='prevented attacks metrics', title='Prevented'),
    ] = []


class GetRemediationMetricsResponse(BaseModelSdk):
    raw: Annotated[RawMetrics, Field(description='Raw metrics data')]
    computed: Annotated[ComputedMetrics, Field(description='Computed metrics data')]
