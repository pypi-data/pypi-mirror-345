# coding: utf-8

"""
    ANTENNEX Reverberation Chamber API

    HTTP API for ANTENNEX The Wireless Connector(tm)

    The version of the OpenAPI document: 3.3.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Optional, Union
from typing_extensions import Annotated
from antennex_client.models.fmcw_settings import FmcwSettings
from antennex_client.models.trp_calibration_types import TrpCalibrationTypes
from typing import Optional, Set
from typing_extensions import Self

### ADDED CONTENT ###
from antennex_client.models.sideband import Sideband
### END ADDED CONTENT ###
class Settings(BaseModel):
    """
    Contains the settings used for performing a calibration or measurement.
    """ # noqa: E501
    resolution: Optional[StrictInt] = Field(default=None, description="Amount of points/samples to collect from electronic test equipment for continuous stirring mode")
    continuous_stirring: Optional[StrictBool] = Field(default=None, description="Enable continuous stirring mode. If set to False, stepped stirring mode is used.", alias="continuousStirring")
    stirrer_steps0: Optional[Annotated[int, Field(le=65535, strict=True, ge=1)]] = Field(default=None, description="Amount of steps with stirrer 0.", alias="stirrerSteps0")
    stirrer_steps1: Optional[Annotated[int, Field(le=65535, strict=True, ge=1)]] = Field(default=None, description="Amount of steps with stirrer 1.", alias="stirrerSteps1")
    stirrer_speed0: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Speed for stirrer 0 (only applicable for continuous stirring mode) [rpm]", alias="stirrerSpeed0")
    stirrer_speed1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Speed for stirrer 1 (only applicable for continuous stirring mode) [rpm]", alias="stirrerSpeed1")
    stirrer_step_angle0: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Angle for each step for stirrer 0 (only applicable for stepped mode) [degrees]", alias="stirrerStepAngle0")
    stirrer_step_angle1: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="Angle for each step for stirrer 1 (only applicable for stepped mode) [degrees]", alias="stirrerStepAngle1")
    trp_calibration_type: Optional[TrpCalibrationTypes] = Field(default=None, alias="trpCalibrationType")
    frequency_start: Optional[Union[Annotated[float, Field(le=1.0E+12, strict=True, ge=400)], Annotated[int, Field(le=2147483647, strict=True, ge=400)]]] = Field(default=None, description="The start frequency of the acquisition [Hz].", alias="frequencyStart")
    frequency_end: Optional[Union[Annotated[float, Field(le=1.0E+12, strict=True, ge=400)], Annotated[int, Field(le=2147483647, strict=True, ge=400)]]] = Field(default=None, description="The start frequency of the acquisition [Hz].", alias="frequencyEnd")
    time_start: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The start time of the acquisition in [s].", alias="timeStart")
    time_end: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="The start time of the acquisition in [s].", alias="timeEnd")
    fmcw: Optional[FmcwSettings] = None
    __properties: ClassVar[List[str]] = ["resolution", "continuousStirring", "stirrerSteps0", "stirrerSteps1", "stirrerSpeed0", "stirrerSpeed1", "stirrerStepAngle0", "stirrerStepAngle1", "trpCalibrationType", "frequencyStart", "frequencyEnd", "timeStart", "timeEnd", "fmcw"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Settings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of fmcw
        if self.fmcw:
            _dict['fmcw'] = self.fmcw.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Settings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "resolution": obj.get("resolution"),
            "continuousStirring": obj.get("continuousStirring"),
            "stirrerSteps0": obj.get("stirrerSteps0"),
            "stirrerSteps1": obj.get("stirrerSteps1"),
            "stirrerSpeed0": obj.get("stirrerSpeed0"),
            "stirrerSpeed1": obj.get("stirrerSpeed1"),
            "stirrerStepAngle0": obj.get("stirrerStepAngle0"),
            "stirrerStepAngle1": obj.get("stirrerStepAngle1"),
            "trpCalibrationType": obj.get("trpCalibrationType"),
            "frequencyStart": obj.get("frequencyStart"),
            "frequencyEnd": obj.get("frequencyEnd"),
            "timeStart": obj.get("timeStart"),
            "timeEnd": obj.get("timeEnd"),
            "fmcw": FmcwSettings.from_dict(obj["fmcw"]) if obj.get("fmcw") is not None else None
        })
        return _obj


    ### ADDED CONTENT ###
    def set_frequency(self, start: float, end: float) -> None:
        """
        Sets the frequency range using the given start and end frequencies.

        Parameters:
            start: float
                The starting frequency in Hz
            end: float
                The ending frequency in Hz
        Returns:
            None
        """
        if not start <= end:
            raise ValueError("Start frequency must be less than or equal to end frequency")
        if not start > 0.0:
            raise ValueError("Start frequency must be greater than 0 Hz")
        self.frequency_start = start
        self.frequency_end = end

    def set_frequency_center_span(self, center: float, span: float) -> None:
        """
        Sets the frequency range using the given start and end frequencies.

        Parameters:
            start: float
                The starting frequency in Hz
            end: float
                The ending frequency in Hz
        Returns:
            None
        """
        if not center > 0.0:
            raise ValueError("Start frequency must be greater than 0 Hz")
        if not span >= 0.0:
            raise ValueError("Span must be greater than or equal to 0 Hz")
        if not span < center:
            raise ValueError("Start frequency for center and span must be above 0 Hz")
        self.frequency_start = center - span / 2
        self.frequency_end = center + span / 2


    def set_time(self, start: float, end: float) -> None:
        """
        Sets the time range using the given start and end times.

        Parameters:
            start: float
                The starting time in seconds
            end: float
                The ending time in seconds
        Returns:
            None
        """
        if not start <= end:
            raise ValueError("Start time must be less than or equal to end time")
        self.time_start = start
        self.time_end = end


    def set_fmcw_lo_frequency(self, frequency: float, sideband: Sideband = Sideband.UPPERSIDEBAND) -> None:
        """
        Sets the local oscillator (LO) frequency and sideband mode for the FMCW (Frequency
        Modulated Continuous Wave) settings.

        Args:
            frequency: The desired LO frequency in hertz.
            sideband: The sideband mode to be used for the LO frequency, either upper or
                lower sideband. Defaults to Sideband.UPPERSIDEBAND.

        Returns:
            None
        """
        if not frequency > 0:
            raise ValueError("LO frequency must be greater than 0 Hz")
        if self.fmcw is None:
            self.fmcw = FmcwSettings()
        self.fmcw.lo_frequency = frequency
        self.fmcw.sideband = sideband

