"""Functions for computing GW power spectra"""

import enum
import functools
import logging
import typing as tp

import matplotlib.pyplot as plt
import numba
from numba.extending import overload
import numpy as np

import pttools.type_hints as th
from pttools import bubble
from pttools import speedup
from . import const
from . import ssm

if tp.TYPE_CHECKING:
    from pttools.analysis.utils import FigAndAxes

logger = logging.getLogger(__name__)


@enum.unique
class NucType(str, enum.Enum):
    """Nucleation type"""
    EXPONENTIAL = "exponential"
    SIMULTANEOUS = "simultaneous"


#: Default nucleation type
DEFAULT_NUC_TYPE = NucType.EXPONENTIAL


class SSMSpectrum:
    """Gravitational wave simulation object"""
    def __init__(
            self,
            bubble: bubble.Bubble,
            y: np.ndarray = None,
            z_st_thresh: float = const.Z_ST_THRESH,
            nuc_type: NucType = DEFAULT_NUC_TYPE,
            nt: int = const.NTDEFAULT,
            n_z_lookup: int = const.N_Z_LOOKUP_DEFAULT,
            r_star: float = None,
            lifetime_multiplier: float = 1,
            compute: bool = True,
            label_latex: str = None,
            label_unicode: str = None):
        r"""
        :param bubble: the Bubble object
        :param y: $z = kR*$ array
        :param z_st_thresh: for $z$ values above z_sh_tresh, use approximation rather than doing the sine transform integral.
        :param nuc_type: nucleation type
        :param nt: number of points in the t array
        :param r_star: $r_*$
        :param lifetime_multiplier: used for computing the source lifetime factor
        :param compute: whether to compute the spectrum immediately
        """
        # Parameters
        self.bubble = bubble
        # self.de_method = de_method
        # self.method = method
        self.nuc_type = nuc_type
        self.y = const.Y_DEFAULT if y is None else y
        self.z_st_thresh = z_st_thresh
        self.nt = nt
        self.n_z_lookup = n_z_lookup
        self.r_star = r_star
        self.lifetime_multiplier = lifetime_multiplier
        label_suffix_latex = "" if r_star is None else f", r_*={r_star}$"
        label_suffix_unicode = "" if r_star is None else f", râŽ={r_star}"
        self.label_latex = self.bubble.label_latex[:-1] + label_suffix_latex if label_latex is None else label_latex
        self.label_unicode = self.bubble.label_unicode + label_suffix_unicode if label_unicode is None else label_unicode

        # Values generated by compute()
        # $|A(z)|^2$
        self.a2: tp.Optional[np.ndarray] = None
        #: $c_s({T}_\text{gw})$
        self.cs: tp.Optional[float] = None
        # Todo: fill the missing descriptions
        #: $P_v(q)$
        self.spec_den_v: tp.Optional[np.ndarray] = None
        #: ???
        self.spec_den_gw: tp.Optional[np.ndarray] = None
        #: $\mathcal{P}_{\tilde{v}}(q)$
        self.pow_v: tp.Optional[np.ndarray] = None
        #: $\mathcal{P}_{\text{gw}}(k)$
        self.pow_gw: tp.Optional[np.ndarray] = None
        self.z_lookup: tp.Optional[np.ndarray] = None

        if compute:
            self.compute()

    def compute(self):
        if not self.bubble.solved:
            self.bubble.solve()
        self.cs = np.sqrt(self.bubble.model.cs2(self.bubble.va_enthalpy_density, bubble.Phase.BROKEN))
        self.spec_den_v, self.a2 = spec_den_v(
            bub=self.bubble, z=self.y, a=1.,
            nuc_type=self.nuc_type, nt=self.nt, z_st_thresh=self.z_st_thresh, cs=self.cs, return_a2=True
        )
        self.pow_v = pow_spec(self.y, spec_den=self.spec_den_v)

        self.z_lookup = gen_lookup(y=self.y, cs=self.cs, n_z_lookup=self.n_z_lookup, eps=1e-8)
        sdv2 = spec_den_v(
            bub=self.bubble, z=self.z_lookup, a=1.,
            nuc_type=self.nuc_type, nt=self.nt, z_st_thresh=self.z_st_thresh, cs=self.cs
        )
        self.spec_den_gw, y = spec_den_gw_scaled(
            z_lookup=self.z_lookup, P_v_lookup=sdv2, y=self.y, cs=self.cs,
            source_lifetime_factor=self.source_lifetime_factor
        )
        self.pow_gw = pow_spec(self.y, spec_den=self.spec_den_gw)

    def label_latex(self) -> str:
        return self.bubble.label_latex

    def label_unicode(self) -> str:
        return self.bubble.label_unicode

    @functools.cached_property
    def source_lifetime_factor(self) -> float:
        r"""
        Source lifetime correction factor
        $$\frac{1}{1 + 2\nu} \left(1 - \left(1 + \frac{\Delta \eta}{\eta_*} \right) \right)^{-1-2\nu}$$
        where
        $$\frac{\Delta \eta}{\eta_*} = \lambda \frac{2 r_*}{\sqrt{K}}$$
        :giombi_2024_cs:`\ `, eq. 3.13
        """
        nu_gdh2024 = self.bubble.model.nu_gdh2024(self.bubble.va_enthalpy_density)
        ret = 1 / (1 + 2*nu_gdh2024)
        if self.r_star is not None and not np.isinf(self.lifetime_multiplier):
            ret *= 1 - (1 + self.lifetime_multiplier * 2 * self.r_star / np.sqrt(self.bubble.kinetic_energy_fraction))**(-1 - 2*nu_gdh2024)
        return ret

    # Plotting

    def plot(self, fig: plt.Figure = None, ax: plt.Axes = None, path: str = None, **kwargs) -> "FigAndAxes":
        from pttools.analysis.plot_spectrum import plot_spectrum
        return plot_spectrum(self, fig, ax, path, **kwargs)

    def plot_v(self, fig: plt.Figure = None, ax: plt.Axes = None, path: str = None, **kwargs) -> "FigAndAxes":
        from pttools.analysis.plot_spectrum import plot_spectrum_v
        return plot_spectrum_v(self, fig, ax, path, **kwargs)

    def plot_spec_den_gw(self, fig: plt.Figure = None, ax: plt.Axes = None, path: str = None, **kwargs) -> "FigAndAxes":
        from pttools.analysis.plot_spectrum import plot_spectrum_spec_den_gw
        return plot_spectrum_spec_den_gw(self, fig, ax, path, **kwargs)

    def plot_spec_den_v(self, fig: plt.Figure = None, ax: plt.Axes = None, path: str = None, **kwargs) -> "FigAndAxes":
        from pttools.analysis.plot_spectrum import plot_spectrum_spec_den_v
        return plot_spectrum_spec_den_v(self, fig, ax, path, **kwargs)

    def plot_multi(self, fig: plt.Figure = None, path: str = None, **kwargs) -> plt.Figure:
        from pttools.analysis.plot_spectrum import plot_spectrum_multi
        return plot_spectrum_multi(self, fig, path, **kwargs)


def convert_params(params: bubble.PhysicalParams) -> bubble.PhysicalParams:
    """Convert the physical parameters from a list to a tuple if necessary."""
    if isinstance(params, list):
        logger.warning("Specifying the model parameters as a list is deprecated. Please use a tuple instead.")
        return tuple(params)
    return params


@numba.njit
def gen_lookup(y: np.ndarray, cs: float, n_z_lookup: int = const.N_Z_LOOKUP_DEFAULT, eps: float = 0.) -> np.ndarray:
    """
    :param y: Input array
    :param cs: Speed of sound $c_s$
    :param n_z_lookup: Number of points for the generated lookup table
    :param eps: Seems to be needed for max(z) <= 100. E.g. 1e-8. Why?
    :return: Generated lookup array for z
    """
    z_minus_min, z_plus_max = lookup_limits(y, cs, eps)
    # The variable to integrate over in eq. 3.44 and 3.47
    return speedup.logspace(np.log10(z_minus_min), np.log10(z_plus_max), n_z_lookup)


@numba.njit
def lookup_limits(y: np.ndarray, cs: float, eps: float = 0.) -> tp.Tuple[float, float]:
    """Defined on p. 12 between eq. 3.44 and 3.45"""
    return y.min() * 0.5 * (1. - cs) / cs - eps, y.max() * 0.5 * (1. + cs) / cs + eps


@numba.njit
def nu(T: th.FloatOrArr, nuc_type: NucType = NucType.SIMULTANEOUS, a: float = 1.) -> th.FloatOrArr:
    r"""
    Bubble lifetime distribution function

    :gw_pt_ssm:`\ ` eq. 4.27 & 4.32

    :param T: dimensionless time
    :param nuc_type: nucleation type, simultaneous or exponential
    :return: bubble lifetime distribution $\nu$
    """
    if nuc_type == NucType.SIMULTANEOUS.value:
        return 0.5 * a * (a*T)**2 * np.exp(-(a*T)**3 / 6)
    if nuc_type == NucType.EXPONENTIAL.value:
        return a * np.exp(-a*T)
    # raise ValueError(f"Nucleation type not recognized: \"{nuc_type}\"")
    raise ValueError("Nucleation type not recognized")


# @numba.njit
def parse_params(params: bubble.PhysicalParams) -> tp.Tuple[float, float, NucType, bubble.NucArgs]:
    r"""
    Parse physical parameters from the tuple.

    :param params: tuple of physical parameters
    :return: $v_\text{wall}, \alpha$, nucleation type, nucleation arguments
    """
    v_wall = params[0]
    alpha = params[1]
    if len(params) > 2:
        nuc_type = params[2]
    else:
        nuc_type = DEFAULT_NUC_TYPE
    if len(params) > 3:
        nuc_args = params[3]
    else:
        nuc_args = const.DEFAULT_NUC_PARM

    return v_wall, alpha, nuc_type, nuc_args


def pow_spec(z: th.FloatOrArr, spec_den: th.FloatOrArr) -> th.FloatOrArr:
    r"""
    Power spectrum from spectral density at dimensionless wavenumber z.

    :gw_pt_ssm:`\ ` eq. 4.18, but without the factor of 2.

    :param z: dimensionless wavenumber $z$
    :param spec_den: spectral density
    :return: power spectrum
    """
    return z**3 / (2. * np.pi ** 2) * spec_den


def power_gw_scaled_bag(
        z: np.ndarray,
        params: bubble.PhysicalParams,
        npt: const.NptType = const.NPTDEFAULT,
        filename: str = None,
        skip: int = 1,
        method: ssm.Method = ssm.Method.E_CONSERVING,
        de_method: ssm.DE_Method = ssm.DE_Method.STANDARD,
        z_st_thresh: float = const.Z_ST_THRESH) -> np.ndarray:
    """
    Scaled GW power spectrum at array of z = kR* values, where R* is mean bubble centre
    separation and k is comoving wavenumber.  To convert to predicted spectrum,
    multiply by $(H_n R_*)(H_n \tau_v)$, where $H_n$ is the Hubble rate at the
    nucleation time, and $\tau_v$ is the lifetime of the shear stress source.

    Physical parameters

    - vw = params[0]       scalar  (required) [0 < vw < 1]
    - alpha = params[1]    scalar  (required) [0 < alpha_n < alpha_n_max(v_w)]
    - nuc_type = params[2] string  (optional) [exponential* | simultaneous]
    - nuc_args = params[3] tuple   (optional) default (1,)

    Steps:

    1. Getting velocity field spectral density
    2. Geeting gw spectral density
    3. turning SD into power

    :param z: array $z = qR_*$
    :param params: physical parameters, see the description above
    :param npt: number of points
    :param filename: path to load A2 values from
    :return: scaled GW power spectrum
    """
    if np.any(z <= 0.0):
        raise ValueError("z values must all be positive.")
    params = convert_params(params)

    bubble.check_physical_params(params)

    # Todo: unify this generation
    eps = 1e-8  # Seems to be needed for max(z) <= 100. Why?
    #    nx = len(z) - this can be too few for velocity PS convolutions
    nx = npt[2]
    xmax = max(z) * (0.5 * (1. + const.CS0) / const.CS0) + eps
    xmin = min(z) * (0.5 * (1. - const.CS0) / const.CS0) - eps

    x = np.logspace(np.log10(xmin), np.log10(xmax), nx)

    sd_v = spec_den_v_bag(x, params, npt, filename, skip, method, de_method, z_st_thresh)
    sd_gw, y = spec_den_gw_scaled(x, sd_v, z)
    return pow_spec(z, sd_gw)


def power_v_bag(
        z: np.ndarray,
        params: bubble.PhysicalParams,
        npt: const.NptType = const.NPTDEFAULT,
        filename: str = None,
        skip: int = 1,
        method: ssm.Method = ssm.Method.E_CONSERVING,
        de_method: ssm.DE_Method = ssm.DE_Method.STANDARD,
        z_st_thresh: float = const.Z_ST_THRESH) -> np.ndarray:
    """
    Power spectrum of the velocity field in the Sound Shell Model.

    - vw = params[0]       scalar
    - alpha = params[1]    scalar
    - nuc_type = params[2] string [exponential* | simultaneous]
    - nuc_args = params[3] tuple  default (1,)

    :param z: array $z = qR_*$
    :param params: physical parameters, see the description above
    :param npt: number of points
    :param filename: path to load A2 values from
    :param z_st_thresh: not used
    :return: power spectrum of the velocity field
    """
    bubble.check_physical_params(params)

    p_v = spec_den_v_bag(z, params, npt, filename, skip, method, de_method)
    return pow_spec(z, p_v)


@numba.njit(parallel=True, nogil=True)
def _spec_den_gw_scaled_core(
        z_lookup: np.ndarray,
        P_v_lookup: np.ndarray,
        y: np.ndarray,
        cs: float,
        Gamma: float,
        source_lifetime_factor: float,
        nz_int: int) -> tp.Tuple[np.ndarray, np.ndarray]:
    r""":gw_pt_ssm:`\ ` eq. 3.47 and 3.48
    The variable naming corresponds to the article.
    """
    if z_lookup.shape != P_v_lookup.shape:
        raise TypeError("z_lookup and P_v_lookup must be of the same shape.")

    # This trickery is required by Numba
    nz_int2 = z_lookup.size if nz_int is None else nz_int

    # Precompute shared intermediate results
    cs2: float = cs ** 2
    z_plus_factor = (1 + cs) / (2 * cs)
    z_minus_factor = (1 - cs) / (2 * cs)
    p_gw_factor = ((1 - cs2) / cs2) ** 2 / (4 * np.pi * cs)

    p_gw: np.ndarray = np.zeros_like(y)
    for i in numba.prange(y.size):
        # As defined on page 12 between eq. 3.44 and 3.45
        z_plus = y[i] * z_plus_factor
        z_minus = y[i] * z_minus_factor
        # Create a range of z to integrate over
        z = speedup.logspace(np.log10(z_minus), np.log10(z_plus), nz_int2)
        # The integrand in eq. 3.47
        integrand = \
            ((z - z_plus) ** 2 * (z - z_minus) ** 2) / (z * (z_plus + z_minus - z)) \
            * np.interp(z, z_lookup, P_v_lookup) \
            * np.interp((z_plus + z_minus - z), z_lookup, P_v_lookup)
        p_gw[i] = p_gw_factor / y[i] * np.trapezoid(integrand, z)

    # Eq. 3.48 has a factor of 3 Gamma^2
    # The P_v_lookup is 0.5 \tilde{P}_v, which gives a factor of (1/2)^2 = 1/4
    # Combined, these result in 3/4 Gamma^2
    return 0.75 * Gamma ** 2 * p_gw * source_lifetime_factor, y


def _spec_den_gw_scaled_y(
        z_lookup: np.ndarray,
        P_v_lookup: np.ndarray,
        y: np.ndarray,
        cs: float,
        Gamma: float,
        source_lifetime_factor: float,
        nz_int: int) -> tp.Tuple[np.ndarray, np.ndarray]:

    z_lookup_min, z_lookup_max = lookup_limits(y, cs)
    if z_lookup.max() < z_lookup_max or z_lookup.min() > z_lookup_min:
        raise ValueError("Range of z_lookup is not large enough.")

    return _spec_den_gw_scaled_core(z_lookup, P_v_lookup, y, cs, Gamma, source_lifetime_factor, nz_int)


def _spec_den_gw_scaled_no_y(
        z_lookup: np.ndarray,
        P_v_lookup: np.ndarray,
        y: None,
        cs: float,
        Gamma: float,
        source_lifetime_factor: float,
        nz_int: int) -> tp.Tuple[np.ndarray, np.ndarray]:
    # This process is the reverse of to gen_lookup()
    zmax = z_lookup.max() * 2. * cs / (1. + cs)
    zmin = z_lookup.min() * 2. * cs / (1. - cs)
    y = speedup.logspace(np.log10(zmin), np.log10(zmax), z_lookup.size)
    return _spec_den_gw_scaled_core(z_lookup, P_v_lookup, y, cs, Gamma, source_lifetime_factor, nz_int)


def spec_den_gw_scaled(
        z_lookup: np.ndarray,
        P_v_lookup: np.ndarray,
        y: np.ndarray = None,
        cs: float = const.CS0,
        Gamma: float = const.GAMMA,
        source_lifetime_factor: float = 1.,
        nz_int: int = None) -> tp.Union[tp.Tuple[np.ndarray, np.ndarray], th.NumbaFunc]:
    r"""
    Spectral density of scaled gravitational wave power

    :param z_lookup: Lookup table for the $z = qL_f$ values corresponding to P_v_lookup
    :param P_v_lookup: $\bar{U}_f^2 \tilde{P}_v (z)$,
        a lookup table for the spectral density of the Fourier transform of the velocity field,
        not the spectral density of plane wave coefficients, which is lower by a factor of 2.
    :param y: $y = kL_f = kR*$ corresponding to z_lookup. If not given, will be created from z_lookup.
    :param cs: Speed of sound (in the broken phase after the phase transition)
    :param Gamma: Mean adiabatic index $\Gamma = \frac{\bar{w}}{\bar{e}}$
    :return: $\hat{\mathcal{P}}$ Eq. 3.33 of Chloe's thesis, which should be ($3\Gamma \bar{U}_f$) Eq. 3.47
        Eq. 3.46 converted to the spectral density and divided by (H L_f)

    The factor of 3 comes from the Friedmann equation
    3H^2/(8pi G)
    """
    if isinstance(y, np.ndarray):
        return _spec_den_gw_scaled_y(z_lookup, P_v_lookup, y, cs, Gamma, source_lifetime_factor, nz_int)
    if y is None:
        return _spec_den_gw_scaled_no_y(z_lookup, P_v_lookup, y, cs, Gamma, source_lifetime_factor, nz_int)
    raise TypeError(f"Unknown type for z: {type(y)}")


@overload(spec_den_gw_scaled, jit_options={"nopython": True, "nogil": True})
def _spec_den_gw_scaled_numba(
        xlookup: np.ndarray,
        P_vlookup: np.ndarray,
        z: np.ndarray = None,
        cs: float = const.CS0) -> tp.Union[tp.Tuple[np.ndarray, np.ndarray], th.NumbaFunc]:
    if isinstance(z, numba.types.Array):
        return _spec_den_gw_scaled_y
    if isinstance(z, (numba.types.NoneType, numba.types.Omitted)):
        return _spec_den_gw_scaled_no_y
    raise TypeError(f"Unknown type for z: {type(z)}")


@numba.njit
def _qT_array(qRstar, Ttilde, b_R, vw):
    return qRstar * Ttilde / (b_R * vw)


@numba.njit
def _spec_den_v_core_loop(
        z_i: float, t_array: np.ndarray, b_R: float, vw: float,
        qT_lookup: np.ndarray, A2_lookup: np.ndarray, nuc_type: NucType, a: float, factor: float):
    qT = _qT_array(z_i, t_array, b_R, vw)
    A2_2d_array_z = np.interp(qT, qT_lookup, A2_lookup)
    array2 = t_array ** 6 * nu(t_array, nuc_type, a) * A2_2d_array_z
    D = np.trapezoid(array2, t_array)
    return D * factor


@numba.njit(parallel=True, nogil=True)
def _spec_den_v_core(
        a: float,
        A2_lookup: np.ndarray,
        log10tmin: float,
        log10tmax: float,
        nuc_type: NucType,
        nt: int,
        qT_lookup: np.ndarray,
        vw: float,
        z: np.ndarray):
    t_array = speedup.logspace(log10tmin, log10tmax, nt)
    b_R = (8. * np.pi) ** (1. / 3.)  # $\beta R_* = b_R v_w $

    # A2_2d_array = np.zeros((nz, nt))

    # array2 = np.zeros(nt)
    sd_v = np.zeros(z.size)  # array for spectral density of v
    factor = 1. / (b_R * vw) ** 6
    factor = 2 * factor  # because spectral density of v is 2 * P_v

    for i in numba.prange(z.size):
        sd_v[i] = _spec_den_v_core_loop(z[i], t_array, b_R, vw, qT_lookup, A2_lookup, nuc_type, a, factor)

    return sd_v


def spec_den_v(
        bub: bubble.Bubble,
        z: np.ndarray,
        a: float,
        nuc_type: NucType,
        nt: int = const.NPTDEFAULT[1],
        z_st_thresh: float = const.Z_ST_THRESH,
        cs: float = None,
        return_a2: bool = False):
    r"""The full spectral density of the velocity field

    This is twice the spectral density of the plane wave components of the velocity field

    :return: $P_{\tilde{v}} = 2 * P_v(q)$ of :gw_pt_ssm:`\ ` eq. 4.17
    """
    # z limits
    log10zmin = np.log10(np.min(z))
    log10zmax = np.log10(np.max(z))
    dlog10z = (log10zmax - log10zmin) / z.size

    # t limits
    tmin = const.T_TILDE_MIN
    tmax = const.T_TILDE_MAX
    log10tmin = np.log10(tmin)
    log10tmax = np.log10(tmax)

    qT_lookup = 10 ** np.arange(log10zmin + log10tmin, log10zmax + log10tmax, dlog10z)
    A2_lookup = ssm.a2_e_conserving(bub=bub, z=qT_lookup, cs=cs, z_st_thresh=z_st_thresh)[0]
    # if qT_lookup.size != A2_lookup.size:
    #     raise ValueError(f"Lookup sizes don't match: {qT_lookup.size} != {A2_lookup.size}")

    ret = _spec_den_v_core(
        a=a,
        A2_lookup=A2_lookup,
        log10tmin=log10tmin,
        log10tmax=log10tmax,
        nt=nt,
        nuc_type=nuc_type,
        qT_lookup=qT_lookup,
        vw=bub.v_wall,
        z=z
    )
    if return_a2:
        return ret, A2_lookup
    return ret


def spec_den_v_bag(
        z: np.ndarray,
        params: bubble.PhysicalParams,
        npt: const.NptType = const.NPTDEFAULT,
        filename: str = None,
        skip: int = 1,
        method: ssm.Method = ssm.Method.E_CONSERVING,
        de_method: ssm.DE_Method = ssm.DE_Method.STANDARD,
        z_st_thresh=const.Z_ST_THRESH):
    r"""
    Get dimensionless velocity spectral density $\bar{P}_v$.

    Gets fluid velocity profile from bubble toolbox or from file if specified.
    Convolves 1-bubble Fourier transform $|A(q T)|^2$ with bubble wall
    lifetime distribution $\nu(T \beta)$ specified by "nuc_type" and "nuc_args".

    :param z: array $z = qR_*$
    :param params: tuple of vw (scalar), alpha (scalar), nuc_type (string [exponential* | simultaneous]), nuc_args (tuple, default (1,))
    :param npt: number of points
    :return: dimensionless velocity spectral density $\bar{P}_v$
    """
    params = convert_params(params)
    bubble.check_physical_params(params)

    nz = z.size
    # nxi = npt[0]
    nt = npt[1]
    # nq = npt[2]

    # z limits
    log10zmin = np.log10(min(z))
    log10zmax = np.log10(max(z))
    dlog10z = (log10zmax - log10zmin) / nz

    # t limits
    tmin = const.T_TILDE_MIN
    tmax = const.T_TILDE_MAX
    log10tmin = np.log10(tmin)
    log10tmax = np.log10(tmax)

    qT_lookup = 10 ** np.arange(log10zmin + log10tmin, log10zmax + log10tmax, dlog10z)

    vw, alpha, nuc_type, nuc_args = parse_params(params)
    if filename is None:
        A2_lookup = ssm.a2_ssm_func_bag(
            z=qT_lookup, v_wall=vw, alpha=alpha,
            npt=npt, method=method, de_method=de_method, z_st_thresh=z_st_thresh
        )
    else:
        A2_lookup = ssm.a2_e_conserving_bag_file(
            z=qT_lookup, filename=filename, alpha=alpha,
            skip=skip, npt=npt, z_st_thresh=z_st_thresh
        )

    # if qT_lookup.size != A2_lookup.size:
    #     raise ValueError(f"Lookup sizes don't match: {qT_lookup.size} != {A2_lookup.size}")

    return _spec_den_v_core(
        a=nuc_args[0],
        A2_lookup=A2_lookup,
        log10tmin=log10tmin,
        log10tmax=log10tmax,
        nt=nt,
        nuc_type=nuc_type,
        qT_lookup=qT_lookup,
        vw=vw,
        z=z
    )
