# Copyright (c) 2023-2025 Arista Networks, Inc.
# Use of this source code is governed by the Apache License 2.0
# that can be found in the LICENSE file.
"""Factory functions used by PyAVD for ANTA."""

from __future__ import annotations

from logging import getLogger
from typing import TYPE_CHECKING, Any

from anta.catalog import AntaCatalog, AntaTestDefinition
from anta.models import AntaTest

from pyavd._eos_cli_config_gen.schema import EosCliConfigGen
from pyavd._utils import get_v2

from .constants import StructuredConfigKey
from .logs import LogMessage, TestLoggerAdapter
from .models import DeviceTestContext

if TYPE_CHECKING:
    from pyavd.api._anta import InputFactorySettings, MinimalStructuredConfig, TestSpec


LOGGER = getLogger(__name__)


def create_catalog(
    hostname: str,
    structured_config: dict[str, Any],
    structured_configs: dict[str, MinimalStructuredConfig],
    input_factory_settings: InputFactorySettings,
    test_specs: list[TestSpec],
) -> AntaCatalog:
    """Create an ANTA catalog for a device from the provided test specs."""
    device_context = DeviceTestContext(
        hostname=hostname,
        structured_config=EosCliConfigGen._load(structured_config),
        structured_configs=structured_configs,
        input_factory_settings=input_factory_settings,
    )
    tests: list[AntaTestDefinition] = []
    for test in test_specs:
        test_logger = TestLoggerAdapter.create(device=hostname, test=test.test_class.name, logger=LOGGER)
        test_definitions = create_test_definitions(test, device_context, test_logger)

        # Skip the test if we couldn't create the test definitions. Logging is done when creating the test definitions
        if test_definitions is None:
            continue

        # Tag the test with the device name for the final catalog and add metadata
        for test_def in test_definitions:
            test_def.inputs.filters = AntaTest.Input.Filters(tags={hostname})
            if test_def.inputs.result_overwrite is None:
                test_def.inputs.result_overwrite = AntaTest.Input.ResultOverwrite(custom_field="Generated by AVD")
            else:
                test_def.inputs.result_overwrite.custom_field = "Generated by AVD"

        tests.extend(test_definitions)

    # Sort by module and test name for consistent output
    tests.sort(key=lambda x: (x.test.__module__, x.test.name))
    return AntaCatalog(tests=tests)


def create_test_definitions(test_spec: TestSpec, device_context: DeviceTestContext, logger: TestLoggerAdapter) -> list[AntaTestDefinition] | None:
    """Create the AntaTestDefinition's from this TestSpec instance."""
    # Skip the test if the conditional keys are not present in the structured config
    if test_spec.conditional_keys and not all(get_v2(device_context.structured_config, key.value) for key in test_spec.conditional_keys):
        keys = StructuredConfigKey.to_string_list(test_spec.conditional_keys)
        logger.debug(LogMessage.INPUT_NO_DATA_MODEL, caller=", ".join(keys))
        return None

    # Create the AntaTest.Input instance from the input dict if available
    if test_spec.input_dict is not None:
        logger.debug(LogMessage.INPUT_RENDERING, caller="input dictionary")
        rendered_inputs = {}
        for input_field, structured_config_key in test_spec.input_dict.items():
            field_value = get_v2(device_context.structured_config, structured_config_key.value)
            if field_value is not None:
                rendered_inputs[input_field] = field_value
            else:
                logger.debug(LogMessage.INPUT_NO_DATA_MODEL, caller=structured_config_key.value)
                return None
        logger.debug(LogMessage.INPUT_RENDERED, inputs=rendered_inputs)
        inputs = test_spec.test_class.Input(**rendered_inputs)
        return [AntaTestDefinition(test=test_spec.test_class, inputs=inputs)]

    # Create the AntaTest.Input instance(s) from the input factory if available
    if test_spec.input_factory is not None:
        logger.debug(LogMessage.INPUT_RENDERING, caller="input factory")
        factory = test_spec.input_factory(device_context, logger)  # pylint: disable=not-callable
        results = factory.create()
        if results is None:
            logger.debug(LogMessage.INPUT_NONE_FOUND)
            return None
        return [AntaTestDefinition(test=test_spec.test_class, inputs=inputs) for inputs in results]

    # Otherwise AntaTestDefinition takes `inputs=None` if the test does not require any input
    return [AntaTestDefinition(test=test_spec.test_class, inputs=None)]
