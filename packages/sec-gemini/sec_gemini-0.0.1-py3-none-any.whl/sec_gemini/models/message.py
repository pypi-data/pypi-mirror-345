
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import orjson
from time import time
from uuid import uuid4
from base64 import b64encode, b64decode
from pydantic import BaseModel, Field
from typing import Optional, Any
from .enums import MimeType, Role, MessageType, ResponseStatus
from .enums import State
from .usage import Usage

ROOT_ID = "3713"

class Message(BaseModel):
    """
    Represents the content of the session both in request and response.
    """

    id: str = Field(default_factory=lambda: uuid4().hex[:12],
                    title="Message ID",
                    description="A unique identifier for the message - uuid4 int.")

    parent_id: str = Field(ROOT_ID,
                           title="Parent Message ID",
                           description="The ID of the parent message.")

    turn: str = Field(default_factory=lambda: uuid4().hex[:12],
                      title="Conversation Turn",
                      description="The turn identifier is used to group/message are part of the same conversation turn.")


    group: str = Field(default_factory=lambda: uuid4().hex,
                       title="Message Group",
                       description="The Group ID (UUID4) identify messages part of the same generation or action.")

    actor: str = Field("user", title="Actor",
                       description="The actor of the message - user or agent.")

    role: Role = Field(Role.USER,
                       title="Role",
                       description="The role of the messages author.")

    timestamp: int = Field(default_factory=lambda: int(time()),
                           title="Timestamp",
                           description="The Unix timestamp (in seconds) of when the message was created.")

    message_type: MessageType = Field(...,
                                      title="Message Type",
                                      description="The type of message - Generation, Tool Call, or Info.")

    message_sub_type: Optional[str] = Field(None,
                                            title="Message Sub Type",
                                            description="The sub type of the message - e.g. function name.")

    state: State = Field(State.START,
                         title="State",
                         description="The state the message belongs to.")

    content: Optional[str] = Field(None,
                                   title="Message Content",
                                   description="The content of the message encoded as utf-8 bytes.")

    mime_type: Optional[MimeType] = Field(default=MimeType.TEXT,
                                          title="Content Type",
                                          description="The content type of the content field.")

    status_code: int = Field(ResponseStatus.OK.value, title="Status Code",
                             description="The status code of the message. 2xx is Okay, 4xx is a client error, 5xx is a server error.")

    status_message: str = Field(ResponseStatus.OK.name, title="Status Message",
                                description="Explain status code reason.")

    usage: Optional[Usage] = Field(Usage(), title="Model Usage Statistics",
                                   description="Token counts when message was generated by model.")

    def to_json(self):
        "Returns the message as a dictionary."
        return orjson.dumps(self.model_dump())

    @staticmethod
    def from_json(data: dict|str) -> "Message":
        "Creates a message from a json dictionary."
        if isinstance(data, str):
            data = orjson.loads(data)
        return Message(**data)

    def set_message_type(self, message_type: MessageType) -> "Message":
        """
        Set the message type to a block message.
        """
        self.message_type = message_type
        self.set_content(message_type.value)
        return self

    def set_status(self, status: ResponseStatus) -> "Message":
        """
        Set the status code and message of the message.
        """
        self.status_code = status.value
        self.status_message = status.name
        return self

    def set_content(self, content: bytes | str,
                    mime_type: MimeType = MimeType.TEXT) -> "Message":
        """
        Set the content of the message while encoding bytes as base64.
        """
        if mime_type.value.startswith("text/"):
            assert isinstance(content, str), "Text mime type requires a string content."
            self.content = content
        else:
            self.mime_type = mime_type
            self.content = b64encode(content).decode("ascii")
        return self

    def get_content(self) -> bytes|str:
        """
        Decodes the content of the message either to bytes or utf-8 string
        depending of the mime type.
        """
        if not self.content:
            return ""

        # return text content as is
        if self.mime_type.value.startswith('text/'):
            return self.content
        else:
            # Decode the content if it is base64 encoded
            return b64decode(self.content.encode("ascii"))
