pseudo-Boolean proof version 2.0
f 105 0
* guessing intvars[varidx 2] = 0, decision stack is [ ]
* guessing intvars[varidx 0] = -3, decision stack is [ intvars[varidx 2] = 0 ]
* guessing intvars[varidx 1] = -2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -3 ]
* solution
solx i0e-3 i1e-2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-3 1 ~i1e-2 >= 1 ;
* guessing intvars[varidx 1] = -1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -3 ]
* solution
solx i0e-3 i1e-1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-3 1 ~i1e-1 >= 1 ;
* guessing intvars[varidx 1] = 0, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -3 ]
* solution
solx i0e-3 i1e0 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-3 1 ~i1e0 >= 1 ;
* guessing intvars[varidx 1] = 1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -3 ]
* solution
solx i0e-3 i1e1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-3 1 ~i1e1 >= 1 ;
* guessing intvars[varidx 1] = 2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -3 ]
* solution
solx i0e-3 i1e2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-3 1 ~i1e2 >= 1 ;
* guessing intvars[varidx 1] = 3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -3 ]
* solution
solx i0e-3 i1e3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-3 1 ~i1e3 >= 1 ;
* guessing intvars[varidx 1] = 4, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -3 ]
* solution
solx i0e-3 i1e4 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-3 1 ~i1e4 >= 1 ;
* guessing intvars[varidx 1] = 5, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -3 ]
* solution
solx i0e-3 i1e5 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-3 1 ~i1e5 >= 1 ;
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-3 >= 1 ;
del id 107
del id 109
del id 111
del id 113
del id 115
del id 117
del id 119
del id 121
* guessing intvars[varidx 0] = -2, decision stack is [ intvars[varidx 2] = 0 ]
* guessing intvars[varidx 1] = -3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -2 ]
* solution
solx i0e-2 i1e-3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-2 1 ~i1e-3 >= 1 ;
* guessing intvars[varidx 1] = -1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -2 ]
* solution
solx i0e-2 i1e-1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-2 1 ~i1e-1 >= 1 ;
* guessing intvars[varidx 1] = 0, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -2 ]
* solution
solx i0e-2 i1e0 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-2 1 ~i1e0 >= 1 ;
* guessing intvars[varidx 1] = 1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -2 ]
* solution
solx i0e-2 i1e1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-2 1 ~i1e1 >= 1 ;
* guessing intvars[varidx 1] = 2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -2 ]
* solution
solx i0e-2 i1e2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-2 1 ~i1e2 >= 1 ;
* guessing intvars[varidx 1] = 3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -2 ]
* solution
solx i0e-2 i1e3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-2 1 ~i1e3 >= 1 ;
* guessing intvars[varidx 1] = 4, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -2 ]
* solution
solx i0e-2 i1e4 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-2 1 ~i1e4 >= 1 ;
* guessing intvars[varidx 1] = 5, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -2 ]
* solution
solx i0e-2 i1e5 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-2 1 ~i1e5 >= 1 ;
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-2 >= 1 ;
del id 124
del id 126
del id 128
del id 130
del id 132
del id 134
del id 136
del id 138
* guessing intvars[varidx 0] = -1, decision stack is [ intvars[varidx 2] = 0 ]
* guessing intvars[varidx 1] = -3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -1 ]
* solution
solx i0e-1 i1e-3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-1 1 ~i1e-3 >= 1 ;
* guessing intvars[varidx 1] = -2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -1 ]
* solution
solx i0e-1 i1e-2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-1 1 ~i1e-2 >= 1 ;
* guessing intvars[varidx 1] = 0, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -1 ]
* solution
solx i0e-1 i1e0 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-1 1 ~i1e0 >= 1 ;
* guessing intvars[varidx 1] = 1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -1 ]
* solution
solx i0e-1 i1e1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-1 1 ~i1e1 >= 1 ;
* guessing intvars[varidx 1] = 2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -1 ]
* solution
solx i0e-1 i1e2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-1 1 ~i1e2 >= 1 ;
* guessing intvars[varidx 1] = 3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -1 ]
* solution
solx i0e-1 i1e3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-1 1 ~i1e3 >= 1 ;
* guessing intvars[varidx 1] = 4, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -1 ]
* solution
solx i0e-1 i1e4 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-1 1 ~i1e4 >= 1 ;
* guessing intvars[varidx 1] = 5, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = -1 ]
* solution
solx i0e-1 i1e5 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-1 1 ~i1e5 >= 1 ;
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e-1 >= 1 ;
del id 141
del id 143
del id 145
del id 147
del id 149
del id 151
del id 153
del id 155
* guessing intvars[varidx 0] = 0, decision stack is [ intvars[varidx 2] = 0 ]
* guessing intvars[varidx 1] = -3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 0 ]
* solution
solx i0e0 i1e-3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e0 1 ~i1e-3 >= 1 ;
* guessing intvars[varidx 1] = -2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 0 ]
* solution
solx i0e0 i1e-2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e0 1 ~i1e-2 >= 1 ;
* guessing intvars[varidx 1] = -1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 0 ]
* solution
solx i0e0 i1e-1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e0 1 ~i1e-1 >= 1 ;
* guessing intvars[varidx 1] = 1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 0 ]
* solution
solx i0e0 i1e1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e0 1 ~i1e1 >= 1 ;
* guessing intvars[varidx 1] = 2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 0 ]
* solution
solx i0e0 i1e2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e0 1 ~i1e2 >= 1 ;
* guessing intvars[varidx 1] = 3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 0 ]
* solution
solx i0e0 i1e3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e0 1 ~i1e3 >= 1 ;
* guessing intvars[varidx 1] = 4, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 0 ]
* solution
solx i0e0 i1e4 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e0 1 ~i1e4 >= 1 ;
* guessing intvars[varidx 1] = 5, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 0 ]
* solution
solx i0e0 i1e5 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e0 1 ~i1e5 >= 1 ;
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e0 >= 1 ;
del id 158
del id 160
del id 162
del id 164
del id 166
del id 168
del id 170
del id 172
* guessing intvars[varidx 0] = 1, decision stack is [ intvars[varidx 2] = 0 ]
* guessing intvars[varidx 1] = -3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 1 ]
* solution
solx i0e1 i1e-3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e1 1 ~i1e-3 >= 1 ;
* guessing intvars[varidx 1] = -2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 1 ]
* solution
solx i0e1 i1e-2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e1 1 ~i1e-2 >= 1 ;
* guessing intvars[varidx 1] = -1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 1 ]
* solution
solx i0e1 i1e-1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e1 1 ~i1e-1 >= 1 ;
* guessing intvars[varidx 1] = 0, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 1 ]
* solution
solx i0e1 i1e0 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e1 1 ~i1e0 >= 1 ;
* guessing intvars[varidx 1] = 2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 1 ]
* solution
solx i0e1 i1e2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e1 1 ~i1e2 >= 1 ;
* guessing intvars[varidx 1] = 3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 1 ]
* solution
solx i0e1 i1e3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e1 1 ~i1e3 >= 1 ;
* guessing intvars[varidx 1] = 4, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 1 ]
* solution
solx i0e1 i1e4 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e1 1 ~i1e4 >= 1 ;
* guessing intvars[varidx 1] = 5, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 1 ]
* solution
solx i0e1 i1e5 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e1 1 ~i1e5 >= 1 ;
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e1 >= 1 ;
del id 175
del id 177
del id 179
del id 181
del id 183
del id 185
del id 187
del id 189
* guessing intvars[varidx 0] = 2, decision stack is [ intvars[varidx 2] = 0 ]
* guessing intvars[varidx 1] = -3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 2 ]
* solution
solx i0e2 i1e-3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e2 1 ~i1e-3 >= 1 ;
* guessing intvars[varidx 1] = -2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 2 ]
* solution
solx i0e2 i1e-2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e2 1 ~i1e-2 >= 1 ;
* guessing intvars[varidx 1] = -1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 2 ]
* solution
solx i0e2 i1e-1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e2 1 ~i1e-1 >= 1 ;
* guessing intvars[varidx 1] = 0, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 2 ]
* solution
solx i0e2 i1e0 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e2 1 ~i1e0 >= 1 ;
* guessing intvars[varidx 1] = 1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 2 ]
* solution
solx i0e2 i1e1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e2 1 ~i1e1 >= 1 ;
* guessing intvars[varidx 1] = 3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 2 ]
* solution
solx i0e2 i1e3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e2 1 ~i1e3 >= 1 ;
* guessing intvars[varidx 1] = 4, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 2 ]
* solution
solx i0e2 i1e4 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e2 1 ~i1e4 >= 1 ;
* guessing intvars[varidx 1] = 5, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 2 ]
* solution
solx i0e2 i1e5 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e2 1 ~i1e5 >= 1 ;
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e2 >= 1 ;
del id 192
del id 194
del id 196
del id 198
del id 200
del id 202
del id 204
del id 206
* guessing intvars[varidx 0] = 3, decision stack is [ intvars[varidx 2] = 0 ]
* guessing intvars[varidx 1] = -3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 3 ]
* solution
solx i0e3 i1e-3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e3 1 ~i1e-3 >= 1 ;
* guessing intvars[varidx 1] = -2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 3 ]
* solution
solx i0e3 i1e-2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e3 1 ~i1e-2 >= 1 ;
* guessing intvars[varidx 1] = -1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 3 ]
* solution
solx i0e3 i1e-1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e3 1 ~i1e-1 >= 1 ;
* guessing intvars[varidx 1] = 0, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 3 ]
* solution
solx i0e3 i1e0 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e3 1 ~i1e0 >= 1 ;
* guessing intvars[varidx 1] = 1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 3 ]
* solution
solx i0e3 i1e1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e3 1 ~i1e1 >= 1 ;
* guessing intvars[varidx 1] = 2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 3 ]
* solution
solx i0e3 i1e2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e3 1 ~i1e2 >= 1 ;
* guessing intvars[varidx 1] = 4, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 3 ]
* solution
solx i0e3 i1e4 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e3 1 ~i1e4 >= 1 ;
* guessing intvars[varidx 1] = 5, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 3 ]
* solution
solx i0e3 i1e5 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e3 1 ~i1e5 >= 1 ;
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e3 >= 1 ;
del id 209
del id 211
del id 213
del id 215
del id 217
del id 219
del id 221
del id 223
* guessing intvars[varidx 0] = 4, decision stack is [ intvars[varidx 2] = 0 ]
* guessing intvars[varidx 1] = -3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 4 ]
* solution
solx i0e4 i1e-3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e4 1 ~i1e-3 >= 1 ;
* guessing intvars[varidx 1] = -2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 4 ]
* solution
solx i0e4 i1e-2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e4 1 ~i1e-2 >= 1 ;
* guessing intvars[varidx 1] = -1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 4 ]
* solution
solx i0e4 i1e-1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e4 1 ~i1e-1 >= 1 ;
* guessing intvars[varidx 1] = 0, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 4 ]
* solution
solx i0e4 i1e0 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e4 1 ~i1e0 >= 1 ;
* guessing intvars[varidx 1] = 1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 4 ]
* solution
solx i0e4 i1e1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e4 1 ~i1e1 >= 1 ;
* guessing intvars[varidx 1] = 2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 4 ]
* solution
solx i0e4 i1e2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e4 1 ~i1e2 >= 1 ;
* guessing intvars[varidx 1] = 3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 4 ]
* solution
solx i0e4 i1e3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e4 1 ~i1e3 >= 1 ;
* guessing intvars[varidx 1] = 5, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 4 ]
* solution
solx i0e4 i1e5 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e4 1 ~i1e5 >= 1 ;
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e4 >= 1 ;
del id 226
del id 228
del id 230
del id 232
del id 234
del id 236
del id 238
del id 240
* guessing intvars[varidx 0] = 5, decision stack is [ intvars[varidx 2] = 0 ]
* guessing intvars[varidx 1] = -3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 5 ]
* solution
solx i0e5 i1e-3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e5 1 ~i1e-3 >= 1 ;
* guessing intvars[varidx 1] = -2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 5 ]
* solution
solx i0e5 i1e-2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e5 1 ~i1e-2 >= 1 ;
* guessing intvars[varidx 1] = -1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 5 ]
* solution
solx i0e5 i1e-1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e5 1 ~i1e-1 >= 1 ;
* guessing intvars[varidx 1] = 0, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 5 ]
* solution
solx i0e5 i1e0 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e5 1 ~i1e0 >= 1 ;
* guessing intvars[varidx 1] = 1, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 5 ]
* solution
solx i0e5 i1e1 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e5 1 ~i1e1 >= 1 ;
* guessing intvars[varidx 1] = 2, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 5 ]
* solution
solx i0e5 i1e2 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e5 1 ~i1e2 >= 1 ;
* guessing intvars[varidx 1] = 3, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 5 ]
* solution
solx i0e5 i1e3 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e5 1 ~i1e3 >= 1 ;
* guessing intvars[varidx 1] = 4, decision stack is [ intvars[varidx 2] = 0 intvars[varidx 0] = 5 ]
* solution
solx i0e5 i1e4 ~i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e5 1 ~i1e4 >= 1 ;
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t 1 ~i0e5 >= 1 ;
del id 243
del id 245
del id 247
del id 249
del id 251
del id 253
del id 255
del id 257
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 i2t >= 1 ;
del id 122
del id 139
del id 156
del id 173
del id 190
del id 207
del id 224
del id 241
del id 258
* guessing intvars[varidx 2] = 1, decision stack is [ ]
* guessing intvars[varidx 0] = -3, decision stack is [ intvars[varidx 2] = 1 ]
* RUP on lit intvars[varidx 1] = -3 with reason from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/constraints/equals.cc:36 in PropagatorState (anonymous namespace)::enforce_equality(ProofLogger *const, const auto &, const auto &, const State &, InferenceTracker &, const optional<Literal> &) [v1:auto = gcs::SimpleIntegerVariableID, v2:auto = gcs::SimpleIntegerVariableID]
u 1 ~i0e-3 1 ~i2t 1 i1e-3 >= 1 ;
* solution
solx i0e-3 i1e-3 i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t 1 ~i0e-3 >= 1 ;
del id 260
* guessing intvars[varidx 0] = -2, decision stack is [ intvars[varidx 2] = 1 ]
* RUP on lit intvars[varidx 1] = -2 with reason from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/constraints/equals.cc:36 in PropagatorState (anonymous namespace)::enforce_equality(ProofLogger *const, const auto &, const auto &, const State &, InferenceTracker &, const optional<Literal> &) [v1:auto = gcs::SimpleIntegerVariableID, v2:auto = gcs::SimpleIntegerVariableID]
u 1 ~i0e-2 1 ~i2t 1 i1e-2 >= 1 ;
* solution
solx i0e-2 i1e-2 i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t 1 ~i0e-2 >= 1 ;
del id 263
* guessing intvars[varidx 0] = -1, decision stack is [ intvars[varidx 2] = 1 ]
* RUP on lit intvars[varidx 1] = -1 with reason from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/constraints/equals.cc:36 in PropagatorState (anonymous namespace)::enforce_equality(ProofLogger *const, const auto &, const auto &, const State &, InferenceTracker &, const optional<Literal> &) [v1:auto = gcs::SimpleIntegerVariableID, v2:auto = gcs::SimpleIntegerVariableID]
u 1 ~i0e-1 1 ~i2t 1 i1e-1 >= 1 ;
* solution
solx i0e-1 i1e-1 i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t 1 ~i0e-1 >= 1 ;
del id 266
* guessing intvars[varidx 0] = 0, decision stack is [ intvars[varidx 2] = 1 ]
* RUP on lit intvars[varidx 1] = 0 with reason from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/constraints/equals.cc:36 in PropagatorState (anonymous namespace)::enforce_equality(ProofLogger *const, const auto &, const auto &, const State &, InferenceTracker &, const optional<Literal> &) [v1:auto = gcs::SimpleIntegerVariableID, v2:auto = gcs::SimpleIntegerVariableID]
u 1 ~i0e0 1 ~i2t 1 i1e0 >= 1 ;
* solution
solx i0e0 i1e0 i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t 1 ~i0e0 >= 1 ;
del id 269
* guessing intvars[varidx 0] = 1, decision stack is [ intvars[varidx 2] = 1 ]
* RUP on lit intvars[varidx 1] = 1 with reason from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/constraints/equals.cc:36 in PropagatorState (anonymous namespace)::enforce_equality(ProofLogger *const, const auto &, const auto &, const State &, InferenceTracker &, const optional<Literal> &) [v1:auto = gcs::SimpleIntegerVariableID, v2:auto = gcs::SimpleIntegerVariableID]
u 1 ~i0e1 1 ~i2t 1 i1e1 >= 1 ;
* solution
solx i0e1 i1e1 i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t 1 ~i0e1 >= 1 ;
del id 272
* guessing intvars[varidx 0] = 2, decision stack is [ intvars[varidx 2] = 1 ]
* RUP on lit intvars[varidx 1] = 2 with reason from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/constraints/equals.cc:36 in PropagatorState (anonymous namespace)::enforce_equality(ProofLogger *const, const auto &, const auto &, const State &, InferenceTracker &, const optional<Literal> &) [v1:auto = gcs::SimpleIntegerVariableID, v2:auto = gcs::SimpleIntegerVariableID]
u 1 ~i0e2 1 ~i2t 1 i1e2 >= 1 ;
* solution
solx i0e2 i1e2 i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t 1 ~i0e2 >= 1 ;
del id 275
* guessing intvars[varidx 0] = 3, decision stack is [ intvars[varidx 2] = 1 ]
* RUP on lit intvars[varidx 1] = 3 with reason from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/constraints/equals.cc:36 in PropagatorState (anonymous namespace)::enforce_equality(ProofLogger *const, const auto &, const auto &, const State &, InferenceTracker &, const optional<Literal> &) [v1:auto = gcs::SimpleIntegerVariableID, v2:auto = gcs::SimpleIntegerVariableID]
u 1 ~i0e3 1 ~i2t 1 i1e3 >= 1 ;
* solution
solx i0e3 i1e3 i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t 1 ~i0e3 >= 1 ;
del id 278
* guessing intvars[varidx 0] = 4, decision stack is [ intvars[varidx 2] = 1 ]
* RUP on lit intvars[varidx 1] = 4 with reason from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/constraints/equals.cc:36 in PropagatorState (anonymous namespace)::enforce_equality(ProofLogger *const, const auto &, const auto &, const State &, InferenceTracker &, const optional<Literal> &) [v1:auto = gcs::SimpleIntegerVariableID, v2:auto = gcs::SimpleIntegerVariableID]
u 1 ~i0e4 1 ~i2t 1 i1e4 >= 1 ;
* solution
solx i0e4 i1e4 i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t 1 ~i0e4 >= 1 ;
del id 281
* guessing intvars[varidx 0] = 5, decision stack is [ intvars[varidx 2] = 1 ]
* RUP on lit intvars[varidx 1] = 5 with reason from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/constraints/equals.cc:36 in PropagatorState (anonymous namespace)::enforce_equality(ProofLogger *const, const auto &, const auto &, const State &, InferenceTracker &, const optional<Literal> &) [v1:auto = gcs::SimpleIntegerVariableID, v2:auto = gcs::SimpleIntegerVariableID]
u 1 ~i0e5 1 ~i2t 1 i1e5 >= 1 ;
* solution
solx i0e5 i1e5 i2t
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t 1 ~i0e5 >= 1 ;
del id 284
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u 1 ~i2t >= 1 ;
del id 262
del id 265
del id 268
del id 271
del id 274
del id 277
del id 280
del id 283
del id 286
* backtracking
* emit rup proof line from /Users/matthewmcilree/PhD_Code/glasgow-constraint-solver/gcs/innards/proofs/proof_logger.cc:149 in void gcs::innards::ProofLogger::backtrack(const State &)
u >= 1 ;
del id 259
del id 287
output NONE
conclusion SAT
end pseudo-Boolean proof
