# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _analyses
else:
    import _analyses

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import weakref

class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _analyses.delete_SwigPyIterator

    def value(self):
        return _analyses.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _analyses.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _analyses.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _analyses.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _analyses.SwigPyIterator_equal(self, x)

    def copy(self):
        return _analyses.SwigPyIterator_copy(self)

    def next(self):
        return _analyses.SwigPyIterator_next(self)

    def __next__(self):
        return _analyses.SwigPyIterator___next__(self)

    def previous(self):
        return _analyses.SwigPyIterator_previous(self)

    def advance(self, n):
        return _analyses.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _analyses.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _analyses.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _analyses.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _analyses.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _analyses.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _analyses.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _analyses:
_analyses.SwigPyIterator_swigregister(SwigPyIterator)
import opensim.actuators
import opensim.simulation
import opensim.common
import opensim.simbody
class Kinematics(opensim.simulation.Analysis):
    r"""
    A class for recording the kinematics of the generalized coordinates
    of a model during a simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.Kinematics_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.Kinematics_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.Kinematics_getClassName()

    def clone(self):
        return _analyses.Kinematics_clone(self)

    def getConcreteClassName(self):
        return _analyses.Kinematics_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.Kinematics_swiginit(self, _analyses.new_Kinematics(*args))
    __swig_destroy__ = _analyses.delete_Kinematics

    def setStorageCapacityIncrements(self, aIncrement):
        return _analyses.Kinematics_setStorageCapacityIncrements(self, aIncrement)

    def getAccelerationStorage(self):
        return _analyses.Kinematics_getAccelerationStorage(self)

    def getVelocityStorage(self):
        return _analyses.Kinematics_getVelocityStorage(self)

    def getPositionStorage(self):
        return _analyses.Kinematics_getPositionStorage(self)

    def setModel(self, aModel):
        return _analyses.Kinematics_setModel(self, aModel)

    def setRecordAccelerations(self, aRecordAccelerations):
        return _analyses.Kinematics_setRecordAccelerations(self, aRecordAccelerations)

    def begin(self, s):
        return _analyses.Kinematics_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.Kinematics_step(self, s, setNumber)

    def end(self, s):
        return _analyses.Kinematics_end(self, s)

    def printResults(self, *args):
        return _analyses.Kinematics_printResults(self, *args)

# Register Kinematics in _analyses:
_analyses.Kinematics_swigregister(Kinematics)
class Actuation(opensim.simulation.Analysis):
    r"""
    A class for recording the basic actuator information for a model
    during a simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.Actuation_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.Actuation_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.Actuation_getClassName()

    def clone(self):
        return _analyses.Actuation_clone(self)

    def getConcreteClassName(self):
        return _analyses.Actuation_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.Actuation_swiginit(self, _analyses.new_Actuation(*args))
    __swig_destroy__ = _analyses.delete_Actuation

    def setStorageCapacityIncrements(self, aIncrement):
        return _analyses.Actuation_setStorageCapacityIncrements(self, aIncrement)

    def getForceStorage(self):
        return _analyses.Actuation_getForceStorage(self)

    def getSpeedStorage(self):
        return _analyses.Actuation_getSpeedStorage(self)

    def getPowerStorage(self):
        return _analyses.Actuation_getPowerStorage(self)

    def setModel(self, aModel):
        return _analyses.Actuation_setModel(self, aModel)

    def begin(self, s):
        return _analyses.Actuation_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.Actuation_step(self, s, setNumber)

    def end(self, s):
        return _analyses.Actuation_end(self, s)

    def printResults(self, *args):
        return _analyses.Actuation_printResults(self, *args)

# Register Actuation in _analyses:
_analyses.Actuation_swigregister(Actuation)
class MuscleAnalysis(opensim.simulation.Analysis):
    r"""
    A class for recording and computing basic quantities (length, shortening
    velocity, tendon length, ...) for muscles during a simulation.

    Author: Ajay Seth, Matthew Millard, Katherine Holzbaur, Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.MuscleAnalysis_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.MuscleAnalysis_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.MuscleAnalysis_getClassName()

    def clone(self):
        return _analyses.MuscleAnalysis_clone(self)

    def getConcreteClassName(self):
        return _analyses.MuscleAnalysis_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.MuscleAnalysis_swiginit(self, _analyses.new_MuscleAnalysis(*args))
    __swig_destroy__ = _analyses.delete_MuscleAnalysis

    def setModel(self, aModel):
        return _analyses.MuscleAnalysis_setModel(self, aModel)

    def setStorageCapacityIncrements(self, aIncrement):
        return _analyses.MuscleAnalysis_setStorageCapacityIncrements(self, aIncrement)

    def getPennationAngleStorage(self):
        return _analyses.MuscleAnalysis_getPennationAngleStorage(self)

    def getMuscleTendonLengthStorage(self):
        return _analyses.MuscleAnalysis_getMuscleTendonLengthStorage(self)

    def getFiberLengthStorage(self):
        return _analyses.MuscleAnalysis_getFiberLengthStorage(self)

    def getNormalizedFiberLengthStorage(self):
        return _analyses.MuscleAnalysis_getNormalizedFiberLengthStorage(self)

    def getTendonLengthStorage(self):
        return _analyses.MuscleAnalysis_getTendonLengthStorage(self)

    def getFiberVelocityStorage(self):
        return _analyses.MuscleAnalysis_getFiberVelocityStorage(self)

    def getNormalizedFiberVelocityStorage(self):
        return _analyses.MuscleAnalysis_getNormalizedFiberVelocityStorage(self)

    def getPennationAngularVelocityStorage(self):
        return _analyses.MuscleAnalysis_getPennationAngularVelocityStorage(self)

    def getForceStorage(self):
        return _analyses.MuscleAnalysis_getForceStorage(self)

    def getFiberForceStorage(self):
        return _analyses.MuscleAnalysis_getFiberForceStorage(self)

    def getActiveFiberForceStorage(self):
        return _analyses.MuscleAnalysis_getActiveFiberForceStorage(self)

    def getPassiveFiberForceStorage(self):
        return _analyses.MuscleAnalysis_getPassiveFiberForceStorage(self)

    def getActiveFiberForceAlongTendonStorage(self):
        return _analyses.MuscleAnalysis_getActiveFiberForceAlongTendonStorage(self)

    def getPassiveFiberForceAlongTendonStorage(self):
        return _analyses.MuscleAnalysis_getPassiveFiberForceAlongTendonStorage(self)

    def getFiberActivePowerStorage(self):
        return _analyses.MuscleAnalysis_getFiberActivePowerStorage(self)

    def getFiberPassivePowerStorage(self):
        return _analyses.MuscleAnalysis_getFiberPassivePowerStorage(self)

    def getTendonPowerStorage(self):
        return _analyses.MuscleAnalysis_getTendonPowerStorage(self)

    def getMusclePowerStorage(self):
        return _analyses.MuscleAnalysis_getMusclePowerStorage(self)

    def setMuscles(self, aMuscles):
        return _analyses.MuscleAnalysis_setMuscles(self, aMuscles)

    def setCoordinates(self, aCoordinates):
        return _analyses.MuscleAnalysis_setCoordinates(self, aCoordinates)

    def setComputeMoments(self, aTrueFalse):
        return _analyses.MuscleAnalysis_setComputeMoments(self, aTrueFalse)

    def getComputeMoments(self):
        return _analyses.MuscleAnalysis_getComputeMoments(self)

    def begin(self, s):
        return _analyses.MuscleAnalysis_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.MuscleAnalysis_step(self, s, setNumber)

    def end(self, s):
        return _analyses.MuscleAnalysis_end(self, s)

    def printResults(self, *args):
        return _analyses.MuscleAnalysis_printResults(self, *args)

    def allocateStorageObjects(self):
        r"""
        Intended for use only by GUI that holds one MuscleAnalysis and keeps changing attributes to generate various plots
        For all other use cases, the code handles the allocation/deallocation of resources internally.
        """
        return _analyses.MuscleAnalysis_allocateStorageObjects(self)

# Register MuscleAnalysis in _analyses:
_analyses.MuscleAnalysis_swigregister(MuscleAnalysis)
class InverseDynamics(opensim.simulation.Analysis):
    r"""
     Conditional comment: *
    A class for performing and recording Inverse Dynamics forces/moments
    on a motion trajectory.

    Author: Eran
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.InverseDynamics_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.InverseDynamics_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.InverseDynamics_getClassName()

    def clone(self):
        return _analyses.InverseDynamics_clone(self)

    def getConcreteClassName(self):
        return _analyses.InverseDynamics_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.InverseDynamics_swiginit(self, _analyses.new_InverseDynamics(*args))
    __swig_destroy__ = _analyses.delete_InverseDynamics

    def setStorageCapacityIncrements(self, aIncrement):
        return _analyses.InverseDynamics_setStorageCapacityIncrements(self, aIncrement)

    def getStorage(self):
        return _analyses.InverseDynamics_getStorage(self)

    def getUseModelForceSet(self):
        return _analyses.InverseDynamics_getUseModelForceSet(self)

    def setUseModelForceSet(self, aUseModelForceSet):
        return _analyses.InverseDynamics_setUseModelForceSet(self, aUseModelForceSet)

    def setModel(self, aModel):
        return _analyses.InverseDynamics_setModel(self, aModel)

    def printResults(self, *args):
        return _analyses.InverseDynamics_printResults(self, *args)

# Register InverseDynamics in _analyses:
_analyses.InverseDynamics_swigregister(InverseDynamics)
class StaticOptimization(opensim.simulation.Analysis):
    r"""
    This class implements static optimization to compute Muscle Forces and
    activations.

    Author: Jeff Reinbolt
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.StaticOptimization_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.StaticOptimization_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.StaticOptimization_getClassName()

    def clone(self):
        return _analyses.StaticOptimization_clone(self)

    def getConcreteClassName(self):
        return _analyses.StaticOptimization_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.StaticOptimization_swiginit(self, _analyses.new_StaticOptimization(*args))
    __swig_destroy__ = _analyses.delete_StaticOptimization

    def setStorageCapacityIncrements(self, aIncrement):
        return _analyses.StaticOptimization_setStorageCapacityIncrements(self, aIncrement)

    def getActivationStorage(self):
        return _analyses.StaticOptimization_getActivationStorage(self)

    def getForceStorage(self):
        return _analyses.StaticOptimization_getForceStorage(self)

    def getUseModelForceSet(self):
        return _analyses.StaticOptimization_getUseModelForceSet(self)

    def setUseModelForceSet(self, aUseModelActuatorSet):
        return _analyses.StaticOptimization_setUseModelForceSet(self, aUseModelActuatorSet)

    def setModel(self, aModel):
        return _analyses.StaticOptimization_setModel(self, aModel)

    def setActivationExponent(self, aExponent):
        return _analyses.StaticOptimization_setActivationExponent(self, aExponent)

    def getActivationExponent(self):
        return _analyses.StaticOptimization_getActivationExponent(self)

    def setUseMusclePhysiology(self, useIt):
        return _analyses.StaticOptimization_setUseMusclePhysiology(self, useIt)

    def getUseMusclePhysiology(self):
        return _analyses.StaticOptimization_getUseMusclePhysiology(self)

    def setConvergenceCriterion(self, tolerance):
        return _analyses.StaticOptimization_setConvergenceCriterion(self, tolerance)

    def getConvergenceCriterion(self):
        return _analyses.StaticOptimization_getConvergenceCriterion(self)

    def setMaxIterations(self, maxIt):
        return _analyses.StaticOptimization_setMaxIterations(self, maxIt)

    def getMaxIterations(self):
        return _analyses.StaticOptimization_getMaxIterations(self)

    def begin(self, s):
        return _analyses.StaticOptimization_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.StaticOptimization_step(self, s, setNumber)

    def end(self, s):
        return _analyses.StaticOptimization_end(self, s)

    def printResults(self, *args):
        return _analyses.StaticOptimization_printResults(self, *args)

# Register StaticOptimization in _analyses:
_analyses.StaticOptimization_swigregister(StaticOptimization)
class ForceReporter(opensim.simulation.Analysis):
    r"""
    A class for recording the Forces applied to a model
    during a simulation.

    Author: Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.ForceReporter_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.ForceReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.ForceReporter_getClassName()

    def clone(self):
        return _analyses.ForceReporter_clone(self)

    def getConcreteClassName(self):
        return _analyses.ForceReporter_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.ForceReporter_swiginit(self, _analyses.new_ForceReporter(*args))
    __swig_destroy__ = _analyses.delete_ForceReporter

    def getForceStorage(self):
        return _analyses.ForceReporter_getForceStorage(self)

    def updForceStorage(self):
        return _analyses.ForceReporter_updForceStorage(self)

    def getForcesTable(self):
        r""" Get forces table."""
        return _analyses.ForceReporter_getForcesTable(self)

    def setModel(self, aModel):
        return _analyses.ForceReporter_setModel(self, aModel)

    def includeConstraintForces(self, flag):
        return _analyses.ForceReporter_includeConstraintForces(self, flag)

    def begin(self, s):
        return _analyses.ForceReporter_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.ForceReporter_step(self, s, setNumber)

    def end(self, s):
        return _analyses.ForceReporter_end(self, s)

    def printResults(self, *args):
        return _analyses.ForceReporter_printResults(self, *args)

# Register ForceReporter in _analyses:
_analyses.ForceReporter_swigregister(ForceReporter)
class PointKinematics(opensim.simulation.Analysis):
    r"""
    A class for recording the kinematics of a point on a body
    of a model during a simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.PointKinematics_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.PointKinematics_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.PointKinematics_getClassName()

    def clone(self):
        return _analyses.PointKinematics_clone(self)

    def getConcreteClassName(self):
        return _analyses.PointKinematics_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.PointKinematics_swiginit(self, _analyses.new_PointKinematics(*args))
    __swig_destroy__ = _analyses.delete_PointKinematics

    def setBodyPoint(self, aBody, aPoint):
        return _analyses.PointKinematics_setBodyPoint(self, aBody, aPoint)

    def setBody(self, aBody):
        return _analyses.PointKinematics_setBody(self, aBody)

    def setRelativeToBody(self, aBody):
        return _analyses.PointKinematics_setRelativeToBody(self, aBody)

    def getBody(self):
        return _analyses.PointKinematics_getBody(self)

    def getRelativeToBody(self):
        return _analyses.PointKinematics_getRelativeToBody(self)

    def setPoint(self, aPoint):
        return _analyses.PointKinematics_setPoint(self, aPoint)

    def getPoint(self, rPoint):
        return _analyses.PointKinematics_getPoint(self, rPoint)

    def setPointName(self, aName):
        return _analyses.PointKinematics_setPointName(self, aName)

    def getPointName(self):
        return _analyses.PointKinematics_getPointName(self)

    def setModel(self, aModel):
        return _analyses.PointKinematics_setModel(self, aModel)

    def setStorageCapacityIncrements(self, aIncrement):
        return _analyses.PointKinematics_setStorageCapacityIncrements(self, aIncrement)

    def getAccelerationStorage(self):
        return _analyses.PointKinematics_getAccelerationStorage(self)

    def getVelocityStorage(self):
        return _analyses.PointKinematics_getVelocityStorage(self)

    def getPositionStorage(self):
        return _analyses.PointKinematics_getPositionStorage(self)

    def begin(self, s):
        return _analyses.PointKinematics_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.PointKinematics_step(self, s, setNumber)

    def end(self, s):
        return _analyses.PointKinematics_end(self, s)

    def printResults(self, *args):
        return _analyses.PointKinematics_printResults(self, *args)

# Register PointKinematics in _analyses:
_analyses.PointKinematics_swigregister(PointKinematics)
cvar = _analyses.cvar
PointKinematicsNAME_LENGTH = cvar.PointKinematicsNAME_LENGTH
PointKinematicsBUFFER_LENGTH = cvar.PointKinematicsBUFFER_LENGTH
PointKinematics.NAME_LENGTH = _analyses.cvar.PointKinematics_NAME_LENGTH
PointKinematics.BUFFER_LENGTH = _analyses.cvar.PointKinematics_BUFFER_LENGTH

class BodyKinematics(opensim.simulation.Analysis):
    r"""
    A class for recording the kinematics of the bodies
    of a model during a simulation.

    Author: Frank C. Anderson
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.BodyKinematics_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.BodyKinematics_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.BodyKinematics_getClassName()

    def clone(self):
        return _analyses.BodyKinematics_clone(self)

    def getConcreteClassName(self):
        return _analyses.BodyKinematics_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.BodyKinematics_swiginit(self, _analyses.new_BodyKinematics(*args))
    __swig_destroy__ = _analyses.delete_BodyKinematics

    def setStorageCapacityIncrements(self, aIncrement):
        return _analyses.BodyKinematics_setStorageCapacityIncrements(self, aIncrement)

    def getAccelerationStorage(self):
        return _analyses.BodyKinematics_getAccelerationStorage(self)

    def getVelocityStorage(self):
        return _analyses.BodyKinematics_getVelocityStorage(self)

    def getPositionStorage(self):
        return _analyses.BodyKinematics_getPositionStorage(self)

    def setExpressResultsInLocalFrame(self, aTrueFalse):
        return _analyses.BodyKinematics_setExpressResultsInLocalFrame(self, aTrueFalse)

    def getExpressResultsInLocalFrame(self):
        return _analyses.BodyKinematics_getExpressResultsInLocalFrame(self)

    def setRecordCenterOfMass(self, aTrueFalse):
        return _analyses.BodyKinematics_setRecordCenterOfMass(self, aTrueFalse)

    def setBodiesToRecord(self, listOfBodies):
        return _analyses.BodyKinematics_setBodiesToRecord(self, listOfBodies)

    def setModel(self, aModel):
        return _analyses.BodyKinematics_setModel(self, aModel)

    def begin(self, s):
        return _analyses.BodyKinematics_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.BodyKinematics_step(self, s, setNumber)

    def end(self, s):
        return _analyses.BodyKinematics_end(self, s)

    def printResults(self, *args):
        return _analyses.BodyKinematics_printResults(self, *args)

# Register BodyKinematics in _analyses:
_analyses.BodyKinematics_swigregister(BodyKinematics)
class JointReaction(opensim.simulation.Analysis):
    r"""
    An analysis for reporting the joint reaction loads from a model. For a given
    joint, the reaction load is calculated as the forces and moments required to
    constrain the body motions to satisfy the joint as if the joint did not
    exist.

    The reaction load acts at the joint center (mobilizer frame) of both the
    parent and child bodies and either force can be reported and expressed in
    any specified frame. The default behavior is the force on the child
    expressed in the ground frame.

    Author: Matt DeMers, Ajay Seth
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.JointReaction_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.JointReaction_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.JointReaction_getClassName()

    def clone(self):
        return _analyses.JointReaction_clone(self)

    def getConcreteClassName(self):
        return _analyses.JointReaction_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.JointReaction_swiginit(self, _analyses.new_JointReaction(*args))
    __swig_destroy__ = _analyses.delete_JointReaction

    def setModel(self, aModel):
        return _analyses.JointReaction_setModel(self, aModel)

    def getForcesFileName(self):
        r""" Public accessors for the forcesFileName property"""
        return _analyses.JointReaction_getForcesFileName(self)

    def setForcesFileName(self, newForcesFile):
        return _analyses.JointReaction_setForcesFileName(self, newForcesFile)

    def getJointNames(self):
        r""" Public accessors for the JointNames property"""
        return _analyses.JointReaction_getJointNames(self)

    def setJointNames(self, jointNames):
        return _analyses.JointReaction_setJointNames(self, jointNames)

    def getOnBody(self):
        r""" Public accessors for the onBody property"""
        return _analyses.JointReaction_getOnBody(self)

    def setOnBody(self, onBody):
        return _analyses.JointReaction_setOnBody(self, onBody)

    def getInFrame(self):
        r""" Public accessors for the inFrame property"""
        return _analyses.JointReaction_getInFrame(self)

    def setInFrame(self, inFrame):
        return _analyses.JointReaction_setInFrame(self, inFrame)

    def begin(self, s):
        return _analyses.JointReaction_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.JointReaction_step(self, s, setNumber)

    def end(self, s):
        return _analyses.JointReaction_end(self, s)

    def printResults(self, *args):
        return _analyses.JointReaction_printResults(self, *args)

# Register JointReaction in _analyses:
_analyses.JointReaction_swigregister(JointReaction)
class StatesReporter(opensim.simulation.Analysis):
    r"""
    A class for recording the states of a model
    during a simulation.

    Author: Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.StatesReporter_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.StatesReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.StatesReporter_getClassName()

    def clone(self):
        return _analyses.StatesReporter_clone(self)

    def getConcreteClassName(self):
        return _analyses.StatesReporter_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.StatesReporter_swiginit(self, _analyses.new_StatesReporter(*args))
    __swig_destroy__ = _analyses.delete_StatesReporter

    def getStatesStorage(self):
        return _analyses.StatesReporter_getStatesStorage(self)

    def updStatesStorage(self):
        return _analyses.StatesReporter_updStatesStorage(self)

    def begin(self, s):
        return _analyses.StatesReporter_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.StatesReporter_step(self, s, setNumber)

    def end(self, s):
        return _analyses.StatesReporter_end(self, s)

    def printResults(self, *args):
        return _analyses.StatesReporter_printResults(self, *args)

# Register StatesReporter in _analyses:
_analyses.StatesReporter_swigregister(StatesReporter)
class InducedAccelerations(opensim.simulation.Analysis):
    r"""
    A class to perform an Induced Accelerations analysis using a constraint-
    method of replacing external (contact) forces in order to determine
    the contributions of actuators to external reaction forces and thus
    model accelerations including that of the center-of-mass.
    The analysis reports the contributions of all forces to user identified
    accelerations of coordinates, bodies and/or center-of-mass.

    Induced Accelerations can apply any OpenSim::Constraint that implements
    setContactPointForInducedAccelerations() to replace external forces, which
    are precisely the same external forces (ExternalLoads file) applied
    during the forward dynamics simulation being analyzed.

    The ConstraintSet supplied must have the same number constraints as
    external forces AND apply to the same bodies with respect to ground.

    Author: Ajay Seth
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.InducedAccelerations_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.InducedAccelerations_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.InducedAccelerations_getClassName()

    def clone(self):
        return _analyses.InducedAccelerations_clone(self)

    def getConcreteClassName(self):
        return _analyses.InducedAccelerations_getConcreteClassName(self)

    def __init__(self, *args):
        r"""
        *Overload 1:*

        Construct an InducedAccelerations instance with a Model.

        :type aModel: :py:class:`Model`, optional
        :param aModel: Model for which the analysis is to be run.

        |

        *Overload 2:*

        Construct InducedAccelerations from file.

        :type aFileName: string
        :param aFileName: File name of the document.

        |

        *Overload 3:*

        Copy constructor.
        """
        _analyses.InducedAccelerations_swiginit(self, _analyses.new_InducedAccelerations(*args))
    __swig_destroy__ = _analyses.delete_InducedAccelerations

    def setModel(self, aModel):
        return _analyses.InducedAccelerations_setModel(self, aModel)

    def initialize(self, s):
        return _analyses.InducedAccelerations_initialize(self, s)

    def begin(self, s):
        return _analyses.InducedAccelerations_begin(self, s)

    def step(self, s, stepNumber):
        return _analyses.InducedAccelerations_step(self, s, stepNumber)

    def end(self, s):
        return _analyses.InducedAccelerations_end(self, s)

    def printResults(self, *args):
        return _analyses.InducedAccelerations_printResults(self, *args)

    def addContactConstraintFromExternalForce(self, externalForce):
        return _analyses.InducedAccelerations_addContactConstraintFromExternalForce(self, externalForce)

    def applyContactConstraintAccordingToExternalForces(self, s):
        return _analyses.InducedAccelerations_applyContactConstraintAccordingToExternalForces(self, s)

# Register InducedAccelerations in _analyses:
_analyses.InducedAccelerations_swigregister(InducedAccelerations)
class ProbeReporter(opensim.simulation.Analysis):
    r"""
    A class for reporting the outputs of all model-connected Probes to file during
    a simulation. This analysis will, at each 'step_interval', cycle through all
    model Probes and retrieve the SimTK::Vector of probe outputs via getProbeOutputs(s)
    and store them into a Storage object, which will get recorded to a file at the
    termination of the simulation. The column labels for each Probe output will
    come from the overridden method Array<string> getProbeOutputLabels() from the specific
    Probe subclass. A schematic of the ProbeReporter functionality is shown below
    (diagram below assumes a single probe, but ProbeReporter will cycle through every
    Probe in the Model):

                                    DEVELOPER NEEDS TO IMPLEMENT
                                    THIS INSIDE THE CHILD PROBE
                                    ============================
                                    |  SimTK::Vector           |
                              |---> |  computeProbeOutputs(s)  | ----|
                              |     ============================     |
      ===================     |                                      |     ==========================
      |  ProbeReporter  | -----                                      ----> |  Output to file        |
      |  Analysis       | -----                                      ----> |  at end of simulation  |
      ===================     |                                      |     ==========================
                              |     ============================     |
                              |---> |  Array<string>           | ----|
                                    |  getProbeOutputLabels()  |
                                    ============================
                                    DEVELOPER NEEDS TO IMPLEMENT
                                    THIS INSIDE THE CHILD PROBE



    Author: Tim Dorn
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.ProbeReporter_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.ProbeReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.ProbeReporter_getClassName()

    def clone(self):
        return _analyses.ProbeReporter_clone(self)

    def getConcreteClassName(self):
        return _analyses.ProbeReporter_getConcreteClassName(self)

    def __init__(self, *args):
        _analyses.ProbeReporter_swiginit(self, _analyses.new_ProbeReporter(*args))
    __swig_destroy__ = _analyses.delete_ProbeReporter

    def getProbeStorage(self):
        return _analyses.ProbeReporter_getProbeStorage(self)

    def updProbeStorage(self):
        return _analyses.ProbeReporter_updProbeStorage(self)

    def setModel(self, aModel):
        return _analyses.ProbeReporter_setModel(self, aModel)

    def begin(self, s):
        return _analyses.ProbeReporter_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.ProbeReporter_step(self, s, setNumber)

    def end(self, s):
        return _analyses.ProbeReporter_end(self, s)

    def disableIntegrationOnlyProbes(self):
        return _analyses.ProbeReporter_disableIntegrationOnlyProbes(self)

    def printResults(self, *args):
        return _analyses.ProbeReporter_printResults(self, *args)

# Register ProbeReporter in _analyses:
_analyses.ProbeReporter_swigregister(ProbeReporter)
class OutputReporter(opensim.simulation.Analysis):
    r"""
    The OutputReporter Analysis is a wrapper for a TableReporter. It generates
    and writes TimeSeriesTables of Output values according to the names listed
    as properties of the Analysis. OutputReporter enables the AnalyzeTool to
    report on Outputs via the Analysis interface but backed by a TableReporter.
    The OutputReporter currently only supports Outputs of type: double, Vec3
    and SpatialVec. The OutputReporter will automatically write multiple files-
    a file for each supported Output type:
      - `<results-file-name>.sto` (as doubles),
      - `<results-file-name>Vec3.sto`, and
      - `<results-file-name>SpatialVec.sto`.

    Output paths can be absolute (e.g., `/joint/slider/tx|value`) or relative
    to the model (by leaving off the first slash; `joint/slider/tx|value`).
    For outputs on the model itself, you can use `|com_position`, etc. As
    explained for AbstractInput, the vertical bar denotes the output name.

    Note that the internal tables are reset at the beginning of a simulation or
    AnalyzeTool::run() and does not append results to previous tables.
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.OutputReporter_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.OutputReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.OutputReporter_getClassName()

    def clone(self):
        return _analyses.OutputReporter_clone(self)

    def getConcreteClassName(self):
        return _analyses.OutputReporter_getConcreteClassName(self)

    def copyProperty_output_paths(self, source):
        return _analyses.OutputReporter_copyProperty_output_paths(self, source)

    def get_output_paths(self, i):
        return _analyses.OutputReporter_get_output_paths(self, i)

    def upd_output_paths(self, i):
        return _analyses.OutputReporter_upd_output_paths(self, i)

    def set_output_paths(self, i, value):
        return _analyses.OutputReporter_set_output_paths(self, i, value)

    def append_output_paths(self, value):
        return _analyses.OutputReporter_append_output_paths(self, value)

    def constructProperty_output_paths(self):
        return _analyses.OutputReporter_constructProperty_output_paths(self)

    def __init__(self, *args):
        _analyses.OutputReporter_swiginit(self, _analyses.new_OutputReporter(*args))
    __swig_destroy__ = _analyses.delete_OutputReporter

# Register OutputReporter in _analyses:
_analyses.OutputReporter_swigregister(OutputReporter)
class IMUDataReporter(opensim.simulation.Analysis):
    r"""
    A class for recording the readings off an IMU object placed on a model
    during a simulation.

    If using this reporter to compute IMU accelerometer signals based on kinematic
    information only (i.e., a solution from the InverseKinematicsTool), then
    set the property `compute_accelerations_without_forces` to true. This property
    will apply forces to the model corresponding to the kinematics that you
    provide as input so that the correct accelerations are computed. The input
    kinematics are splined and then prescribed to the model (via the
    PositionMotion class), and the applied forces are based on derivatives of
    these splines; therefore, you should ensure that the input kinematics produce
    the correct derivatives when splined. It is recommended that you don't not
    compute any quantities near the beginning or end of the time range in your
    data, since spline derivatives can be inaccurate in these regions.

    Author: Ayman Habib
    Version: 1.0
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def safeDownCast(obj):
        return _analyses.IMUDataReporter_safeDownCast(obj)

    def assign(self, aObject):
        return _analyses.IMUDataReporter_assign(self, aObject)

    @staticmethod
    def getClassName():
        return _analyses.IMUDataReporter_getClassName()

    def clone(self):
        return _analyses.IMUDataReporter_clone(self)

    def getConcreteClassName(self):
        return _analyses.IMUDataReporter_getConcreteClassName(self)

    def copyProperty_report_orientations(self, source):
        return _analyses.IMUDataReporter_copyProperty_report_orientations(self, source)

    def append_report_orientations(self, value):
        return _analyses.IMUDataReporter_append_report_orientations(self, value)

    def constructProperty_report_orientations(self, initValue):
        return _analyses.IMUDataReporter_constructProperty_report_orientations(self, initValue)

    def get_report_orientations(self, *args):
        return _analyses.IMUDataReporter_get_report_orientations(self, *args)

    def upd_report_orientations(self, *args):
        return _analyses.IMUDataReporter_upd_report_orientations(self, *args)

    def set_report_orientations(self, *args):
        return _analyses.IMUDataReporter_set_report_orientations(self, *args)

    def copyProperty_report_gyroscope_signals(self, source):
        return _analyses.IMUDataReporter_copyProperty_report_gyroscope_signals(self, source)

    def append_report_gyroscope_signals(self, value):
        return _analyses.IMUDataReporter_append_report_gyroscope_signals(self, value)

    def constructProperty_report_gyroscope_signals(self, initValue):
        return _analyses.IMUDataReporter_constructProperty_report_gyroscope_signals(self, initValue)

    def get_report_gyroscope_signals(self, *args):
        return _analyses.IMUDataReporter_get_report_gyroscope_signals(self, *args)

    def upd_report_gyroscope_signals(self, *args):
        return _analyses.IMUDataReporter_upd_report_gyroscope_signals(self, *args)

    def set_report_gyroscope_signals(self, *args):
        return _analyses.IMUDataReporter_set_report_gyroscope_signals(self, *args)

    def copyProperty_report_accelerometer_signals(self, source):
        return _analyses.IMUDataReporter_copyProperty_report_accelerometer_signals(self, source)

    def append_report_accelerometer_signals(self, value):
        return _analyses.IMUDataReporter_append_report_accelerometer_signals(self, value)

    def constructProperty_report_accelerometer_signals(self, initValue):
        return _analyses.IMUDataReporter_constructProperty_report_accelerometer_signals(self, initValue)

    def get_report_accelerometer_signals(self, *args):
        return _analyses.IMUDataReporter_get_report_accelerometer_signals(self, *args)

    def upd_report_accelerometer_signals(self, *args):
        return _analyses.IMUDataReporter_upd_report_accelerometer_signals(self, *args)

    def set_report_accelerometer_signals(self, *args):
        return _analyses.IMUDataReporter_set_report_accelerometer_signals(self, *args)

    def copyProperty_compute_accelerations_without_forces(self, source):
        return _analyses.IMUDataReporter_copyProperty_compute_accelerations_without_forces(self, source)

    def append_compute_accelerations_without_forces(self, value):
        return _analyses.IMUDataReporter_append_compute_accelerations_without_forces(self, value)

    def constructProperty_compute_accelerations_without_forces(self, initValue):
        return _analyses.IMUDataReporter_constructProperty_compute_accelerations_without_forces(self, initValue)

    def get_compute_accelerations_without_forces(self, *args):
        return _analyses.IMUDataReporter_get_compute_accelerations_without_forces(self, *args)

    def upd_compute_accelerations_without_forces(self, *args):
        return _analyses.IMUDataReporter_upd_compute_accelerations_without_forces(self, *args)

    def set_compute_accelerations_without_forces(self, *args):
        return _analyses.IMUDataReporter_set_compute_accelerations_without_forces(self, *args)

    def copyProperty_frame_paths(self, source):
        return _analyses.IMUDataReporter_copyProperty_frame_paths(self, source)

    def get_frame_paths(self, i):
        return _analyses.IMUDataReporter_get_frame_paths(self, i)

    def upd_frame_paths(self, i):
        return _analyses.IMUDataReporter_upd_frame_paths(self, i)

    def set_frame_paths(self, i, value):
        return _analyses.IMUDataReporter_set_frame_paths(self, i, value)

    def append_frame_paths(self, value):
        return _analyses.IMUDataReporter_append_frame_paths(self, value)

    def constructProperty_frame_paths(self):
        return _analyses.IMUDataReporter_constructProperty_frame_paths(self)

    def __init__(self, *args):
        _analyses.IMUDataReporter_swiginit(self, _analyses.new_IMUDataReporter(*args))
    __swig_destroy__ = _analyses.delete_IMUDataReporter

    def setNull(self):
        return _analyses.IMUDataReporter_setNull(self)

    def getOrientationsTable(self):
        return _analyses.IMUDataReporter_getOrientationsTable(self)

    def getGyroscopeSignalsTable(self):
        return _analyses.IMUDataReporter_getGyroscopeSignalsTable(self)

    def getAccelerometerSignalsTable(self):
        return _analyses.IMUDataReporter_getAccelerometerSignalsTable(self)

    def begin(self, s):
        return _analyses.IMUDataReporter_begin(self, s)

    def step(self, s, setNumber):
        return _analyses.IMUDataReporter_step(self, s, setNumber)

    def end(self, s):
        return _analyses.IMUDataReporter_end(self, s)

    def printResults(self, *args):
        return _analyses.IMUDataReporter_printResults(self, *args)

# Register IMUDataReporter in _analyses:
_analyses.IMUDataReporter_swigregister(IMUDataReporter)

