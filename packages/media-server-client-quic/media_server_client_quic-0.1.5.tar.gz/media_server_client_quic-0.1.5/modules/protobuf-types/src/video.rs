// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProtobufDecodedFrame {
    #[prost(int64, tag = "1")]
    pub ticket: i64,
    #[prost(uint64, tag = "2")]
    pub device_ptr: u64,
    #[prost(uint64, tag = "3")]
    pub size: u64,
    #[prost(uint64, tag = "4")]
    pub pitch: u64,
    #[prost(uint64, tag = "5")]
    pub width: u64,
    #[prost(uint64, tag = "6")]
    pub height: u64,
    #[prost(enumeration = "PixelFormat", tag = "7")]
    pub pixel_format: i32,
    /// Made optional
    #[prost(map = "string, string", tag = "8")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(uint64, tag = "9")]
    pub stream_id: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BoundingBox {
    #[prost(float, tag = "1")]
    pub x: f32,
    #[prost(float, tag = "2")]
    pub y: f32,
    #[prost(float, tag = "3")]
    pub width: f32,
    #[prost(float, tag = "4")]
    pub height: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Detection {
    #[prost(message, optional, tag = "1")]
    pub bbox: ::core::option::Option<BoundingBox>,
    #[prost(string, tag = "2")]
    pub class_name: ::prost::alloc::string::String,
    #[prost(float, tag = "3")]
    pub confidence: f32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SegmentationMask {
    /// RLE or binary mask data
    #[prost(bytes = "vec", tag = "1")]
    pub mask_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub width: u32,
    #[prost(uint32, tag = "3")]
    pub height: u32,
    #[prost(int32, tag = "4")]
    pub class_id: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnalysisResult {
    /// Corresponds to frame ticket
    #[prost(int64, tag = "1")]
    pub ticket: i64,
    /// Corresponds to stream ID
    #[prost(uint64, tag = "2")]
    pub stream_id: u64,
    #[prost(message, repeated, tag = "3")]
    pub detections: ::prost::alloc::vec::Vec<Detection>,
    #[prost(message, repeated, tag = "4")]
    pub masks: ::prost::alloc::vec::Vec<SegmentationMask>,
    /// Time taken to process in milliseconds
    #[prost(double, tag = "5")]
    pub processing_time: f64,
    #[prost(map = "string, string", tag = "6")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PixelFormat {
    Unspecified = 0,
    Rgb = 1,
    Bgr = 2,
    Nv12 = 3,
    P016 = 4,
    Nv21 = 5,
    Yuv = 6,
    Yuv420 = 7,
    Yuv422 = 8,
    Yuv444 = 9,
    Yuv44416bit = 10,
    Ycbcr = 11,
    Tcbcr420 = 12,
    Tcbcr422 = 13,
    Tcbcr444 = 14,
    Cbycr422 = 15,
    Hsv = 16,
    Hls = 17,
    Lab = 18,
    Ycc = 19,
    Luv = 20,
    Xyz = 21,
}
impl PixelFormat {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PIXEL_FORMAT_UNSPECIFIED",
            Self::Rgb => "RGB",
            Self::Bgr => "BGR",
            Self::Nv12 => "NV12",
            Self::P016 => "P016",
            Self::Nv21 => "NV21",
            Self::Yuv => "YUV",
            Self::Yuv420 => "YUV420",
            Self::Yuv422 => "YUV422",
            Self::Yuv444 => "YUV444",
            Self::Yuv44416bit => "YUV444_16BIT",
            Self::Ycbcr => "YCBCR",
            Self::Tcbcr420 => "TCBCR420",
            Self::Tcbcr422 => "TCBCR422",
            Self::Tcbcr444 => "TCBCR444",
            Self::Cbycr422 => "CBYCR422",
            Self::Hsv => "HSV",
            Self::Hls => "HLS",
            Self::Lab => "LAB",
            Self::Ycc => "YCC",
            Self::Luv => "LUV",
            Self::Xyz => "XYZ",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PIXEL_FORMAT_UNSPECIFIED" => Some(Self::Unspecified),
            "RGB" => Some(Self::Rgb),
            "BGR" => Some(Self::Bgr),
            "NV12" => Some(Self::Nv12),
            "P016" => Some(Self::P016),
            "NV21" => Some(Self::Nv21),
            "YUV" => Some(Self::Yuv),
            "YUV420" => Some(Self::Yuv420),
            "YUV422" => Some(Self::Yuv422),
            "YUV444" => Some(Self::Yuv444),
            "YUV444_16BIT" => Some(Self::Yuv44416bit),
            "YCBCR" => Some(Self::Ycbcr),
            "TCBCR420" => Some(Self::Tcbcr420),
            "TCBCR422" => Some(Self::Tcbcr422),
            "TCBCR444" => Some(Self::Tcbcr444),
            "CBYCR422" => Some(Self::Cbycr422),
            "HSV" => Some(Self::Hsv),
            "HLS" => Some(Self::Hls),
            "LAB" => Some(Self::Lab),
            "YCC" => Some(Self::Ycc),
            "LUV" => Some(Self::Luv),
            "XYZ" => Some(Self::Xyz),
            _ => None,
        }
    }
}
