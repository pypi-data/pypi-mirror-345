# coding: utf-8

"""
    ANTENNEX Reverberation Chamber API

    HTTP API for ANTENNEX The Wireless Connector(tm)
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictStr
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated

from .default_api import DefaultApi

from antennex_client.models.acquisition_mode import AcquisitionMode
from antennex_client.models.acquisition_types import AcquisitionTypes
from antennex_client.models.machine_mode import MachineMode
from antennex_client.models.settings import Settings
from antennex_client.exceptions import NotFoundException


class AntennexApi(DefaultApi):
    """This is the entrypoint for the DefaultApi API.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        super().__init__(api_client)

    def is_version_greater_than(self, minimum_version: Union[str, List[int]]) -> bool:
        """Check if the measurement service version is greater than the specified version"""
        if isinstance(minimum_version, str):
            minimum_version = [int(x) for x in minimum_version.split('.')]
        measurement_service_version: str = super().get_version()
        if measurement_service_version == "unknown":
            return True # Exception for engineering
        version_parts = [int(x) for x in measurement_service_version.split("-", maxsplit=1)[0].split(".")]
        for i in range(len(minimum_version)):
            if len(version_parts) <= i:
                # Assume version_parts effectively zero
                if minimum_version[i] != 0:
                    return False
            elif version_parts[i] > minimum_version[i]:
                return True
            elif version_parts[i] < minimum_version[i]:
                return False
        return True

    @validate_call
    def acquire(
        self,
        acquisition_type: Annotated[AcquisitionTypes, Field(description="Type of the acquisition")],
        settings: Annotated[Settings, Field(description="Settings used for the specific acquisition. The semantics of this call are the same as for setSettings, except they apply to this measurement only. Any configured settings will be overridden by the settings supplied here. If a settings is not supplied, then the currently configured setting will be used. If an empty settings object is provided (meaning: \"{}\"), then the settings configured with setSettings are used.")]=None,
        wait: Annotated[Optional[StrictBool], Field(description="Wait for entire acquisition to complete. The functions always waits for the acquisition to be fully started.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> None:
        """Perform an acquisition

        Start an acquisition of the specified acquisition type.  When wait=true is provided the operation will return only when it's completed. In such cases, it's recommended that the HTTP timeout is set long enough for the entire operation such that the client doesn't time out.

        :param acquisition_type: Type of the acquisition (required)
        :type acquisition_type: AcquisitionTypes
        :param settings: Settings used for the specific acquisition. The semantics of this call are the same as for setSettings, except they apply to this measurement only. Any configured settings will be overridden by the settings supplied here. If a settings is not supplied, then the currently configured setting will be used. If an empty settings object is provided (meaning: \"{}\"), then the settings configured with setSettings are used. (required)
        :type settings: Settings
        :param wait: Wait for entire acquisition to complete. The functions always waits for the acquisition to be fully started.
        :type wait: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        # Start with empty settings, so it keeps the server configuration
        if settings is None:
            settings = Settings()

        super().acquire(
            acquisition_type=acquisition_type,
            settings=settings,
            wait=wait,
            _request_timeout=_request_timeout,
        )

    @validate_call
    def set_machine_mode(
        self,
        machine_mode: Union[MachineMode,
                            AcquisitionMode,
                            str],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
    ) -> None:
        """Sets current Machine mode

        Sets the acquisition and analysis mode of the system.

        :param machine_mode: The mode to set, which can be one of the following:
                     - MachineMode: An instance of MachineMode.
                     - AcquisitionMode: An instance of AcquisitionMode, which will
                       be automatically converted to MachineMode.
                     - str: A string representation of an AcquisitionMode enum value. It is matched case-sensitively.
        :type machine_mode: MachineMode | AcquisitionMode | str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :return: Returns the result object.
        """ # noqa: E501

        # Can supply an AcqusitionMode and this will convert it to the expected data type
        if isinstance(machine_mode, AcquisitionMode):
            machine_mode = MachineMode(mode=machine_mode)
        if isinstance(machine_mode, str):
            mode = AcquisitionMode(machine_mode)
            machine_mode = MachineMode(mode=mode)

        try:
            super().set_machine_mode(
                machine_mode=machine_mode,
                _request_timeout=_request_timeout,
            )
        except NotFoundException as e:
            # Measurement service 3.2 does not support this call.
            # It does only support Spectrum mode, so we allow setting spectrum mode and then ignoring the 404 error.
            if machine_mode.mode == AcquisitionMode.SPECTRUM:
                if not self.is_version_greater_than("3.3"):
                    return
            raise e
