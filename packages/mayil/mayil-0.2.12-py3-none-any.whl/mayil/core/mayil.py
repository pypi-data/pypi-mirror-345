# Generated by AI, edited by Human

class Mayil:
    def __init__(self):
        self.body_content = []
        self._styles = """
        <style>
            /* Professional font stack with fallbacks for maximum compatibility */
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 
                           Helvetica, Arial, sans-serif, 'Apple Color Emoji', 
                           'Segoe UI Emoji', 'Segoe UI Symbol';
                line-height: 1.6;
                color: #2c3e50;
                margin: 0;
                padding: 20px;
                background-color: #ffffff;
            }
            
            .header {
                font-size: 26px;
                font-weight: 300; /* Light weight for modern look */
                margin-bottom: 20px;
                color: #1a1a1a;
                letter-spacing: -0.5px;
            }

            .subheader {
                font-size: 22px;
                font-weight: 300; /* Light weight for modern look */
                margin-bottom: 20px;
                color: #1a1a1a;
                letter-spacing: -0.5px;
            }
            
            .text {
                font-size: 16px;
                line-height: 1.6;
                margin-bottom: 15px;
                color: #2c3e50;
                font-weight: 400;
            }
            
            /* Container for better email client compatibility */
            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 20px;
                width: 100%;
            }

            /* Column styles */
            .columns {
                width: 100%;
                margin-bottom: 20px;
            }

            .column {
                padding: 0 10px;
                vertical-align: top;
            }

            /* Wrapper to contain floating elements */
            .clearfix::after {
                content: "";
                clear: both;
                display: table;
            }
        </style>
        """

    def title(self, text, center=False):
        """Add a title to the email body. Similar to header but with larger font size.
        
        Args:
            text (str): The title text
            center (bool): Whether to center the title on the page. Defaults to False
        """
        style = "font-size: 32px; font-weight: 300;"
        if center:
            style += " text-align: center;"
        self.body_content.append(f'<h1 class="header" style="{style}">{text}</h1>')
        return self

    def header(self, text):
        """Add a subheader to the email body."""
        self.body_content.append(f'<h2 class="header">{text}</h2>')
        return self

    def subheader(self, text):
        """Add a header to the email body."""
        self.body_content.append(f'<h1 class="subheader">{text}</h1>')
        return self

    def text(self, text, justify=False, italic=False, bold=False, underline=False, font_size=None):
        """Add text to the email body.
        
        Args:
            text (str): The text content
            justify (bool): Whether to justify the text. Defaults to False
            italic (bool): Whether to italicize the text. Defaults to False
            bold (bool): Whether to bold the text. Defaults to False 
            underline (bool): Whether to underline the text. Defaults to False
            font_size (int): Custom font size in pixels. Defaults to None
        """
        formatted_text = text.replace('\n', '<br>')
        style = []
        
        if justify:
            style.append("text-align: justify;")
        if italic:
            style.append("font-style: italic;")
        if bold:
            style.append("font-weight: bold;")
        if underline:
            style.append("text-decoration: underline;")
        if font_size:
            style.append(f"font-size: {font_size}px;")
            
        style.append("clear: both;")
        style_str = " ".join(style)
        
        self.body_content.append(f'<p class="text" style="{style_str}">{formatted_text}</p>')
        return self

    def caption(self, text, italic=False):
        """Add a caption text with smaller font size and lighter color."""
        style = "font-size: 14px; color: #666666; clear: both;"
        if italic:
            style += " font-style: italic;"
        self.body_content.append(f'<p class="text" style="{style}">{text}</p>')
        return self

    def metric(self, label, value, color="#000000"):
        """Add a metric display with label and value."""
        metric_html = f"""
        <div style="width: 100%; margin-bottom: 20px; clear: both;">
            <div style="display: inline-block; border-radius: 4px; padding: 15px; box-shadow: 0 4px 4px rgba(0,0,0,0.03); min-width: 120px; text-align: center;">
                <div style="font-size: 14px; color: #666; font-weight: 300;">{label}</div>
                <div style="font-size: 24px; color: {color}; font-weight: 700;">{value}</div>
            </div>
        </div>"""
        self.body_content.append(metric_html)
        return self

    def sticky_note(self, title, text, color="yellow", justify=False):
        """Add a sticky note component with title and text.
        
        Args:
            title (str): Title text for the sticky note
            text (str): Main text content (supports multiline)
            color (str): Color of sticky note - can be 'yellow', 'green', 'blue', 'red', 'white',
                        'violet', 'orange', 'darkgreen' or a hex color code. Defaults to 'yellow'
            justify (bool): Whether to justify the text content, defaults to False
        """
        # Convert named colors to sticky note hex colors
        color_map = {
            "yellow": "#FFEE8C",
            "green": "#e8f5e9",
            "blue": "#e3f2fd", 
            "red": "#ffebee",
            "white": "#ffffff",
            "violet": "#f3e5f5",
            "orange": "#fff3e0",
            "darkgreen": "#e8f5e9"
        }
        bg_color = color_map.get(color.lower(), color)  # Use hex if not in map
        formatted_text = text.replace('\n', '<br>')
        text_style = "text-align: justify;" if justify else ""
        sticky_html = f"""
        <div class="clearfix">
            <div style="
                background-color: {bg_color};
                padding: 15px;
                margin: 20px 0;
                border-radius: 2px;
                min-width: 200px;
                max-width: 200px;
                min-height: 200px;
                display: inline-block;
                position: relative;
                box-shadow: 2px 8px 8px rgba(0,0,0,0.1);
                transform: rotate(0.5deg);">
                <div style="font-size: 18px; font-weight: 500; margin-bottom: 10px; color: #424242;">{title}</div>
                <div style="font-size: 14px; color: #616161; white-space: pre-wrap; {text_style}">{formatted_text}</div>
            </div>
        </div>
        """
        self.body_content.append(sticky_html)
        return self

    def divider(self):
        """Add a light grey dotted divider line."""
        divider_html = '<hr style="clear: both; border: none; border-top: 2px dotted #e0e0e0; margin: 20px 0; border-spacing: 10px;">'
        self.body_content.append(divider_html)
        return self

    
    def columns(self, n_cols):
        """Create a specified number of columns for horizontal layout.
        
        Args:
            n_cols (int): Number of columns (max 4)
            
        Returns:
            list: List of Column objects that can be used in with statements
        """
        if not 1 <= n_cols <= 4:
            raise ValueError("Number of columns must be between 1 and 4")
            
        # Calculate width percentage for each column with some gap
        col_width = (100 - ((n_cols - 1) * 2)) / n_cols
        
        # Create column wrapper div
        wrapper_id = f"col_wrapper_{len(self.body_content)}"
        wrapper_html = f"""
        <div id="{wrapper_id}" style="display: flex; flex-direction: row; flex-wrap: nowrap; justify-content: space-between; align-items: stretch; width: 100%; margin: 10px 0; gap: 20px;">
        """
        self.body_content.append(wrapper_html)
        
        class Column:
            def __init__(self, mayil_instance, wrapper_id):
                self.mayil = mayil_instance
                self.wrapper_id = wrapper_id
                self.original_content = mayil_instance.body_content.copy()
                
            def __enter__(self):
                # Store the current content length to track new additions
                self.start_len = len(self.mayil.body_content)
                return self
                
            def __exit__(self, exc_type, exc_val, exc_tb):
                # Wrap all content added during the context in a column div
                end_len = len(self.mayil.body_content)
                new_content = self.mayil.body_content[self.start_len:]
                self.mayil.body_content = self.mayil.body_content[:self.start_len]
                
                column_html = f"""
                <div style="flex: 1 1 {col_width}%; width: {col_width}%; min-width: 0; display: inline-block; vertical-align: top;">
                    {''.join(new_content)}
                </div>
                """
                self.mayil.body_content.append(column_html)

        # Create column objects
        columns = [Column(self, wrapper_id) for _ in range(n_cols)]
        
        # Add closing wrapper div to contain the flex layout
        self.body_content.append("</div>")
        
        # Add a div to clear any floats
        self.body_content.append('<div style="clear: both;"></div>')
        
        return columns

    def table(self, df, align='left', use_container_width=True):
        """Add a styled DataFrame to the email.
        
        Args:
            df: pandas DataFrame to display
            align (str): Alignment of table content - 'left', 'center', or 'right'. Default is 'left'
            use_container_width (bool): Whether the table should take up full container width. Defaults to True.
        """
        # Validate alignment parameter
        valid_alignments = ['left', 'center', 'right']
        if align not in valid_alignments:
            raise ValueError(f"align must be one of {valid_alignments}")
            
        # Limit to 100 rows
        if len(df) > 100:
            df = df.head(100)
            
        # Convert DataFrame to HTML with styling
        border_style = "1px solid #e5e7eb"
        column_border = "1px solid #f3f4f6"
        
        # Generate HTML manually for better email compatibility
        table_width = "100%" if use_container_width else "auto"
        container_width = "100%" if use_container_width else "fit-content"
        container_margin = "0 auto" if use_container_width else "0"
        
        # Start building the table HTML
        html = f'<div style="width: {container_width}; margin: {container_margin}; padding: 0;">\n'
        html += f'<table cellspacing="0" cellpadding="0" border="0" width="{table_width}" style="border-collapse: separate; border-spacing: 0; width: {table_width}; margin: 16px 0; border-radius: 8px; overflow: hidden; font-size: 14px; border: {border_style}; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);">\n'
        
        # Headers
        html += '<thead>\n<tr>\n'
        for col in df.columns:
            html += f'<th bgcolor="#f9fafb" style="background-color: #f9fafb; font-weight: 600; text-align: {align}; padding: 8px; border-bottom: {border_style}; border-right: {column_border};">{col}</th>\n'
        html += '</tr>\n</thead>\n'
        
        # Body
        html += '<tbody>\n'
        for _, row in df.iterrows():
            html += '<tr>\n'
            for val in row:
                html += f'<td style="padding: 8px; text-align: {align}; border-bottom: {border_style}; border-right: {column_border};">{val}</td>\n'
            html += '</tr>\n'
        html += '</tbody>\n'
        
        html += '</table>\n</div>'
        
        self.body_content.append(html)
        return self

    def ftable(self, df, conditions=None, cell_colors=None, text_colors=None, align='left', use_container_width=True):
        """Add a formatted table with conditional coloring based on column values.
        
        Args:
            df (pandas.DataFrame): The dataframe to display
            conditions (dict): Dictionary mapping column names to list of conditions.
                Each condition should be a tuple of (lambda function, color).
                Example: {
                    'Score': [
                        (lambda x: x < 50, '#ff0000'),  # Red if < 50
                        (lambda x: 50 <= x <= 100, '#0000ff'), # Blue if 50-100
                        (lambda x: x > 100, '#00ff00') # Green if > 100
                    ],
                    'Date': [
                        (lambda x: x < pd.Timestamp('2024-01-01'), '#ff0000'), # Red if before 2024
                        (lambda x: x >= pd.Timestamp('2024-01-01'), '#00ff00') # Green if 2024 or later
                    ],
                    'Status': [
                        (lambda x: x.lower() == 'active', '#00ff00'), # Green if active
                        (lambda x: x.lower() == 'inactive', '#ff0000') # Red if inactive
                    ]
                }
            cell_colors (dict or bool): If dict, same format as conditions but for cell background colors with low opacity.
                                       If bool (legacy), True applies conditions as background colors, False as text colors.
            text_colors (dict or bool): If dict, same format as conditions but for text colors.
                                       If bool (legacy), True applies conditions as text colors, False as background colors.
            align (str): Text alignment - 'left', 'center', or 'right'
            use_container_width (bool): Whether the table should take up full container width. Defaults to True.
            
        Returns:
            Mayil: The Mayil instance for method chaining
        """
        # Create a copy to avoid modifying original
        styled_df = df.copy()
        
        # Create dictionaries for cell and text styling
        cell_style_map = {}
        text_style_map = {}
        
        # Helper function to apply conditions
        def apply_conditions(conditions_dict, target_map, opacity=None):
            if not conditions_dict:
                return
                
            for col, rules in conditions_dict.items():
                if col in df.columns and isinstance(rules, list):
                    # Initialize style map entry for this column
                    if col not in target_map:
                        target_map[col] = {}
                    
                    for rule in rules:
                        try:
                            condition_func, color = rule
                            
                            # Convert color to rgba if opacity specified
                            if opacity and color.startswith('#'):
                                r = int(color[1:3], 16)
                                g = int(color[3:5], 16)
                                b = int(color[5:7], 16)
                                color = f'rgba({r},{g},{b},{opacity})'
                            
                            # Apply the condition function to the column
                            for idx, value in df[col].items():
                                if condition_func(value):
                                    if idx not in target_map[col]:
                                        target_map[col][idx] = color
                        except (ValueError, TypeError) as e:
                            print(f"Warning: Invalid condition format for column '{col}': {rule}")
                            continue
        
        # Apply conditions to the style maps
        apply_conditions(cell_colors, cell_style_map, opacity='0.1')
        apply_conditions(text_colors, text_style_map)
        
        # Setup table parameters
        border_style = "1px solid #e5e7eb"
        table_width = "100%" if use_container_width else "auto"
        container_width = "100%" if use_container_width else "fit-content"
        container_margin = "0 auto" if use_container_width else "0"
        
        # Start building the HTML table with email-friendly attributes
        html = f'<div style="width: {container_width}; margin: {container_margin}; padding: 0;">\n'
        html += f'<table cellspacing="0" cellpadding="0" border="0" width="{table_width}" style="border-collapse: separate; border-spacing: 0; width: {table_width}; margin: 16px 0; border-radius: 8px; overflow: hidden; font-size: 14px; border: {border_style}; box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);">\n'
        
        # Headers
        html += '<thead>\n<tr>\n'
        for col in styled_df.columns:
            html += f'<th bgcolor="#f9fafb" style="background-color: #f9fafb; font-weight: 600; text-align: {align}; padding: 8px; border-bottom: {border_style}; border-right: {border_style};">{col}</th>\n'
        html += '</tr>\n</thead>\n'
        
        # Body
        html += '<tbody>\n'
        for idx, row in styled_df.iterrows():
            html += '<tr>\n'
            for col, val in row.items():
                # Apply cell background color if specified
                bg_style = ""
                if col in cell_style_map and idx in cell_style_map[col]:
                    bg_color = cell_style_map[col][idx]
                    bg_style = f" background-color: {bg_color};"
                
                # Apply text color if specified
                text_style = ""
                if col in text_style_map and idx in text_style_map[col]:
                    text_color = text_style_map[col][idx]
                    text_style = f" color: {text_color};"
                
                # Create the cell with proper styling
                html += f'<td style="padding: 8px; text-align: {align}; border-bottom: {border_style}; border-right: {border_style};{bg_style}">'
                
                # If text styling is needed, wrap content in span
                if text_style:
                    html += f'<span style="{text_style}">{val}</span>'
                else:
                    html += f'{val}'
                
                html += '</td>\n'
            
            html += '</tr>\n'
        html += '</tbody>\n'
        
        html += '</table>\n</div>'
        
        self.body_content.append(html)
        return self
   
    def hyperlink(self, text: str, url: str) -> 'Mayil':
        """Add a clickable link to the email.
        
        Args:
            text (str): The text to display for the link
            url (str): The URL that the link points to
            
        Returns:
            Mayil: The Mayil instance for method chaining
        """
        link_html = f'<a href="{url}" target="_blank" style="color: #2563eb; text-decoration: none;">{text}</a>'
        self.body_content.append(link_html)
        return self

    def plotly_chart(self, fig, show_legend: bool = True) -> 'Mayil':
        """Add a Plotly chart to the email.
        
        Args:
            fig: A Plotly figure object
            show_legend: Whether to show the legend (default: True)
            
        Returns:
            Mayil: The Mayil instance for method chaining
        """
        # Update figure layout to white theme
        fig.update_layout(
            template='plotly_white',
            showlegend=show_legend
        )
        
        # Convert plotly figure to HTML
        plot_html = fig.to_html(
            full_html=False,
            include_plotlyjs='cdn',
            config={'displayModeBar': False}
        )
        
        # Add responsive wrapper
        responsive_html = f"""
        <div style="width:100%; margin: 16px 0;">
            {plot_html}
        </div>
        """
        
        self.body_content.append(responsive_html)
        return self

    def markdown(self, text: str) -> 'Mayil':
        """Convert markdown text to HTML and add it to the email body.
        
        Args:
            text (str): The markdown formatted text
            
        Returns:
            Mayil: The Mayil instance for method chaining
        """
        try:
            import markdown2
        except ImportError:
            raise ImportError("The markdown2 package is required for markdown support. Install it with 'pip install markdown2'")

        # Convert markdown to HTML
        html = markdown2.markdown(text, extras=['fenced-code-blocks', 'tables', 'break-on-newline'])
        
        # Add some basic styling
        styled_html = f"""
        <div class="markdown" style="line-height: 1.6;">
            {html}
        </div>
        """
        
        self.body_content.append(styled_html)
        return self

    def show(self) -> None:
        """Preview the email body in the default web browser.
        
        Opens the current email body content directly in a new browser tab.
        """
        import webbrowser
        from pathlib import Path
        
        # Create preview directory if it doesn't exist
        preview_dir = Path.home() / '.mayil' / 'preview'
        preview_dir.mkdir(parents=True, exist_ok=True)
        
        # Save preview.html in the preview directory
        preview_path = preview_dir / 'preview.html'
        preview_path.write_text(self.body(), encoding='utf-8')
        
        # Open in browser
        webbrowser.open(f'file://{preview_path}')

    def save(self, path: str) -> None:
        """Save the email body to a file.
        
        Args:
            path (str): The path to save the email body
        """
        with open(path, 'w', encoding='utf-8') as f:
            f.write(self.body())

    def image(self, source: str, width: str = "100%", height: str = "auto") -> "Mayil":
        """Add an image to the email body.
        
        Args:
            source (str): The image source - either a URL or local file path
            width (str): Width of the image (e.g. "500px", "100%", "auto")
            height (str): Height of the image (e.g. "300px", "auto") 
            
        Returns:
            Mayil: The Mayil instance for method chaining
        """
        import base64
        import mimetypes
        from pathlib import Path
        from urllib.parse import urlparse

        # Check if source is URL or local path
        is_url = bool(urlparse(source).scheme)

        if is_url:
            # For URLs, use the source directly
            img_html = f'<img src="{source}" style="width: {width}; height: {height};">'
        else:
            # For local files, embed as base64
            img_path = Path(source)
            if not img_path.exists():
                raise FileNotFoundError(f"Image file not found: {source}")

            # Get mime type
            mime_type, _ = mimetypes.guess_type(source)
            if not mime_type or not mime_type.startswith('image/'):
                raise ValueError(f"Invalid image file: {source}")

            # Read and encode image
            with open(source, 'rb') as img_file:
                img_data = base64.b64encode(img_file.read()).decode('utf-8')

            img_html = f'<img src="data:{mime_type};base64,{img_data}" style="width: {width}; height: {height};">'

        self.body_content.append(img_html)
        return self

    def signature(self, salutation: str = "Best regards,", name: str = None, designation: str = None, signature_image: str = None) -> 'Mayil':
        """Add a professional email signature.
        
        Args:
            salutation (str, optional): The salutation to use. Defaults to "Best regards,"
            name (str): The name to display in the signature
            designation (str, optional): The designation/title/position to display under the name
            signature_image (str, optional): Path to signature image file (jpg/png) or SVG content
            
        Returns:
            Mayil: The Mayil instance for method chaining
        """
        import base64
        import mimetypes
        from pathlib import Path
        from urllib.parse import urlparse

        signature_html = '<div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">'

        # Add salutation if provided
        if salutation:
            signature_html += f'<p style="color: #666666; margin: 0; font-size: 14px;">{salutation}</p>'

        # Add text signature if name provided
        if name:
            signature_html += f'<p style="margin: 10px 0 5px 0; color: #2c3e50; font-weight: 500;">{name}</p>'
            if designation:
                signature_html += f'<p style="margin: 0; color: #666666; font-size: 12px;">{designation}</p>'

        # Handle signature image if provided
        if signature_image:
            if signature_image.lower().endswith('.svg'):
                # For SVG files or content
                if Path(signature_image).exists():
                    with open(signature_image, 'r') as f:
                        svg_content = f.read()
                else:
                    svg_content = signature_image
                signature_html += f'<div style="margin: 10px 0; max-width: 500px; max-height: 40px;">{svg_content}</div>'
            else:
                # For other image types
                is_url = bool(urlparse(signature_image).scheme)
                if is_url:
                    signature_html += f'<img src="{signature_image}" style="max-width: 500px; max-height: 40px; margin: 10px 0; object-fit: contain;">'
                else:
                    img_path = Path(signature_image)
                    if not img_path.exists():
                        raise FileNotFoundError(f"Signature image not found: {signature_image}")
                    
                    mime_type, _ = mimetypes.guess_type(signature_image)
                    if not mime_type or not mime_type.startswith('image/'):
                        raise ValueError(f"Invalid image file: {signature_image}")
                    
                    with open(signature_image, 'rb') as img_file:
                        img_data = base64.b64encode(img_file.read()).decode('utf-8')
                    signature_html += f'<img src="data:{mime_type};base64,{img_data}" style="max-width: 500px; max-height: 40px; margin: 10px 0; object-fit: contain;">'

        signature_html += '</div>'
        self.body_content.append(signature_html)
        return self

    def mention(self, emails, color=None):
        """Add @mentions with email addresses in colorful rounded boxes.
        
        Args:
            emails (list): List of email addresses to mention
            color (str, optional): Hex color code to use for all mentions. If not provided, random colors will be used.
        """
        import random

        # Neon colors for mentions
        neon_colors = [
            "#FF3B3B", # Bright red
            "#FF2B93", # Hot pink
            "#7928CA", # Vibrant purple
            "#0070F3", # Bright blue
            "#00C853", # Emerald green
            "#FF6D00", # Bright orange
            "#00B8D4", # Cyan blue
            "#6200EA", # Deep purple
            "#2962FF", # Royal blue
            "#00C853", # Bright green
            "#D50000", # Pure red
            "#C51162", # Deep pink
            "#AA00FF", # Electric purple
            "#00BFA5", # Teal
            "#FFD600", # Bright yellow
            "#FF3D00", # Deep orange
            "#1DE9B6", # Light teal
            "#00E5FF", # Light blue
            "#651FFF", # Violet
            "#F50057"  # Pink red
        ]

        mentions_html = '<div style="margin: 10px 0;">'
        
        for email in emails:
            # Use provided color or pick random neon color
            mention_color = color if color else random.choice(neon_colors)
            
            # Create mention box with rounded corners and glow effect
            mentions_html += f"""
                <span style="
                    display: inline-block;
                    background-color: {mention_color}10;
                    color: {mention_color};
                    padding: 4px 12px;
                    border-radius: 20px;
                    margin: 0 5px 5px 0;
                    font-size: 14px;
                    border: 1px solid {mention_color}44;
                ">@{email}</span>
            """

        mentions_html += '</div>'
        self.body_content.append(mentions_html)
        return self

    def break_space(self, height=20):
        """Add a vertical white space break.
        
        Args:
            height (int): Height of the break in pixels. Defaults to 20.
        """
        self.body_content.append(f'<div style="height: {height}px; clear: both;"></div>')
        return self

    
    def body(self):
        """Get the complete HTML body of the email."""
        html_content = f"""
        <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
        <html xmlns="http://www.w3.org/1999/xhtml">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
            <meta name="x-apple-disable-message-reformatting" />
            <meta name="color-scheme" content="light">
            <meta name="supported-color-schemes" content="light">
            {self._styles}
        </head>
        <body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #2c3e50; margin: 0; padding: 20px; background-color: #ffffff;">
            <div class="container" style="max-width: 1200px; margin: 0 auto; padding: 20px; width: 100%;">
                {''.join(self.body_content)}
            </div>
            
            <!-- Extra spacer table for Gmail compatibility -->
            <table cellpadding="0" cellspacing="0" border="0" width="100%" style="min-width:100%;">
                <tr><td height="1" style="min-width:100%; font-size:1px; line-height:1px;">&nbsp;</td></tr>
            </table>
        </body>
        </html>
        """
        
        # Inline all CSS using premailer for better email client compatibility
        try:
            from premailer import Premailer
            premailer = Premailer(html_content, remove_classes=False, keep_style_tags=True)
            inlined_html = premailer.transform()
            return inlined_html
        except ImportError:
            print("Warning: premailer package is not installed. Emails will not have inlined CSS, which may affect formatting in some email clients.")
            return html_content