# FAQ & HOWTO: Тестирование и внедрение зависимостей для команд

## Проблема

В текущей архитектуре регистрация команд происходит сразу после определения функции, и функция "захватывает" зависимости (например, data_layer) на момент первого импорта. Это мешает подменять зависимости в тестах, так как функция уже связана с реальным объектом.

---

## Рекомендации и best practices

### 1. Внедрение зависимостей через параметры функции (Dependency Injection)

**Рекомендуемый способ:**
Определяйте команды так, чтобы зависимости передавались явно через параметры функции или через фабрику:

```python
# commands/index/count.py
def count(data_layer):
    return data_layer.count()

registry.register_command("count", lambda: count(data_layer))
```

**В тестах:**
```python
def test_count():
    mock_data_layer = ...
    result = count(mock_data_layer)
    assert result == ...
```

### 2. Использование фабрик или ленивой регистрации

**Фабрика:**
```python
def make_count(data_layer):
    def count():
        return data_layer.count()
    return count

registry.register_command("count", make_count(data_layer))
```
В тестах можно зарегистрировать команду с мок-объектом:
```python
registry.register_command("count", make_count(mock_data_layer))
```

### 3. DI-контейнеры и интеграция с внешними менеджерами зависимостей

Если проект крупный, рассмотрите интеграцию с DI-контейнерами (например, `dependency-injector`, `wired`, `punq` и др.).
Это позволит централизованно управлять зависимостями и легко подменять их в тестах.

### 4. Документирование паттернов

Документация пакета будет дополнена разделом о рекомендуемых паттернах DI и тестирования команд, чтобы избежать подобных ловушек.

---

## Ответы на вопросы

**1. Какой способ изоляции зависимостей и тестирования команд вы рекомендуете при текущей архитектуре пакета?**
→ Используйте DI через параметры функции или фабрики, как показано выше. Это самый простой и универсальный способ.

**2. Планируется ли поддержка более гибкой регистрации команд или интеграция с DI/моками?**
→ Да, в roadmap пакета будет добавлен пункт о поддержке DI и ленивой регистрации команд. Возможна интеграция с DI-контейнерами и/или предоставление вспомогательных утилит для тестирования.

**3. Есть ли best practices или примеры для подобных сценариев?**
→ Примеры будут добавлены в HOWTO и FAQ документации пакета.
Кратко:
- Не захватывайте зависимости на уровне модуля — используйте фабрики.
- Для тестов всегда передавайте зависимости явно.
- Для сложных случаев используйте DI-контейнер.

---

## Пример для документации (HOWTO)

```python
# commands/index/count.py
def make_count(data_layer):
    def count():
        return data_layer.count()
    return count

# В рабочем коде
registry.register_command("count", make_count(real_data_layer))

# В тестах
registry.register_command("count", make_count(mock_data_layer))
```

---

**Спасибо за ваш вопрос и вклад в развитие пакета!**
Если есть пожелания по API или интеграции с DI — пишите, это поможет сделать пакет удобнее для всех пользователей. 