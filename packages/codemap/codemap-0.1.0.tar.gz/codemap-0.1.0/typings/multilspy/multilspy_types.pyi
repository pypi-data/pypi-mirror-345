"""
This type stub file was generated by pyright.
"""

from enum import Enum, IntEnum
from typing_extensions import Dict, List, NotRequired, TypedDict, Union

"""
Defines wrapper objects around the types returned by LSP to ensure decoupling between LSP versions and multilspy
"""
URI = str
DocumentUri = str
Uint = int
RegExp = str
class Position(TypedDict):
    """Position in a text document expressed as zero-based line and character
    offset. Prior to 3.17 the offsets were always based on a UTF-16 string
    representation. So a string of the form `aêêÄb` the character offset of the
    character `a` is 0, the character offset of `êêÄ` is 1 and the character
    offset of b is 3 since `êêÄ` is represented using two code units in UTF-16.
    Since 3.17 clients and servers can agree on a different string encoding
    representation (e.g. UTF-8). The client announces it's supported encoding
    via the client capability [`general.positionEncodings`](#clientCapabilities).
    The value is an array of position encodings the client supports, with
    decreasing preference (e.g. the encoding at index `0` is the most preferred
    one). To stay backwards compatible the only mandatory encoding is UTF-16
    represented via the string `utf-16`. The server can pick one of the
    encodings offered by the client and signals that encoding back to the
    client via the initialize result's property
    [`capabilities.positionEncoding`](#serverCapabilities). If the string value
    `utf-16` is missing from the client's capability `general.positionEncodings`
    servers can safely assume that the client supports UTF-16. If the server
    omits the position encoding in its initialize result the encoding defaults
    to the string value `utf-16`. Implementation considerations: since the
    conversion from one encoding into another requires the content of the
    file / line the conversion is best done where the file is read which is
    usually on the server side.

    Positions are line end character agnostic. So you can not specify a position
    that denotes `\r|\n` or `\n|` where `|` represents the character offset.

    @since 3.17.0 - support for negotiated position encoding."""
    line: Uint
    character: Uint
    ...


class Range(TypedDict):
    """A range in a text document expressed as (zero-based) start and end positions.

    If you want to specify a range that contains a line including the line ending
    character(s) then use an end position denoting the start of the next line.
    For example:
    ```ts
    {
        start: { line: 5, character: 23 }
        end : { line 6, character : 0 }
    }
    ```"""
    start: Position
    end: Position
    ...


class Location(TypedDict):
    """Represents a location inside a resource, such as a line
    inside a text file."""
    uri: DocumentUri
    range: Range
    absolutePath: str
    relativePath: Union[str, None]
    ...


class CompletionItemKind(IntEnum):
    """The kind of a completion entry."""
    Text = ...
    Method = ...
    Function = ...
    Constructor = ...
    Field = ...
    Variable = ...
    Class = ...
    Interface = ...
    Module = ...
    Property = ...
    Unit = ...
    Value = ...
    Enum = ...
    Keyword = ...
    Snippet = ...
    Color = ...
    File = ...
    Reference = ...
    Folder = ...
    EnumMember = ...
    Constant = ...
    Struct = ...
    Event = ...
    Operator = ...
    TypeParameter = ...


class CompletionItem(TypedDict):
    """A completion item represents a text snippet that is
    proposed to complete text that is being typed."""
    completionText: str
    kind: CompletionItemKind
    detail: NotRequired[str]
    ...


class SymbolKind(IntEnum):
    """A symbol kind."""
    File = ...
    Module = ...
    Namespace = ...
    Package = ...
    Class = ...
    Method = ...
    Property = ...
    Field = ...
    Constructor = ...
    Enum = ...
    Interface = ...
    Function = ...
    Variable = ...
    Constant = ...
    String = ...
    Number = ...
    Boolean = ...
    Array = ...
    Object = ...
    Key = ...
    Null = ...
    EnumMember = ...
    Struct = ...
    Event = ...
    Operator = ...
    TypeParameter = ...


class SymbolTag(IntEnum):
    """Symbol tags are extra annotations that tweak the rendering of a symbol.

    @since 3.16"""
    Deprecated = ...


class UnifiedSymbolInformation(TypedDict):
    """Represents information about programming constructs like variables, classes,
    interfaces etc."""
    deprecated: NotRequired[bool]
    location: NotRequired[Location]
    name: str
    kind: SymbolKind
    tags: NotRequired[List[SymbolTag]]
    containerName: NotRequired[str]
    detail: NotRequired[str]
    range: NotRequired[Range]
    selectionRange: NotRequired[Range]
    ...


TreeRepr = Dict[int, List['TreeRepr']]
class MarkupKind(Enum):
    """Describes the content type that a client supports in various
    result literals like `Hover`, `ParameterInfo` or `CompletionItem`.

    Please note that `MarkupKinds` must not start with a `$`. This kinds
    are reserved for internal usage."""
    PlainText = ...
    Markdown = ...


class __MarkedString_Type_1(TypedDict):
    language: str
    value: str
    ...


MarkedString = Union[str, "__MarkedString_Type_1"]
class MarkupContent(TypedDict):
    """A `MarkupContent` literal represents a string value which content is interpreted base on its
    kind flag. Currently the protocol supports `plaintext` and `markdown` as markup kinds.

    If the kind is `markdown` then the value can contain fenced code blocks like in GitHub issues.
    See https://help.github.com/articles/creating-and-highlighting-code-blocks/#syntax-highlighting

    Here is an example how such a string can be constructed using JavaScript / TypeScript:
    ```ts
    let markdown: MarkdownContent = {
     kind: MarkupKind.Markdown,
     value: [
       '# Header',
       'Some text',
       '```typescript',
       'someCode();',
       '```'
     ].join('\n')
    };
    ```

    *Please Note* that clients might sanitize the return markdown. A client could decide to
    remove HTML from the markdown to avoid script execution."""
    kind: MarkupKind
    value: str
    ...


class Hover(TypedDict):
    """The result of a hover request."""
    contents: Union[MarkupContent, MarkedString, List[MarkedString]]
    range: NotRequired[Range]
    ...


