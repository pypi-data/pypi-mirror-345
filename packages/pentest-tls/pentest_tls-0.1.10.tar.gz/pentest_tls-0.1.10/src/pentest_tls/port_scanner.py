import socket
from scapy.all import *
from scapy.layers.inet import IP, UDP, ICMP, TCP

# Deprecated
def scan_tcp_port_v0_1_5(ip: str, port: int, timeout: float = 0.5) -> bool:
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(timeout)
            return sock.connect_ex((ip, port)) == 0
    except Exception:
        return False
    
def scan_tcp_port(ip: str, port: int, timeout: float = 0.5, is_root=False) -> bool:
    if is_root:
        # SYN Scan (requires root privileges)
        pkt = IP(dst=ip)/TCP(dport=port, flags="S")
        ans = sr1(pkt, timeout=timeout, verbose=0)
        if ans is None:
            print(f"[-] {ip}:{port}     CLOSED/FILTERED")
            return False
        elif ans.haslayer(TCP):
            if ans[TCP].flags & 0x12:  # SYN-ACK (0x12) means port is open
                rst_pkt = IP(dst=ip)/TCP(dport=port, flags="R")
                send(rst_pkt, verbose=0)
                print(f"[+] {ip}:{port}     OPEN")
                return True
        elif ans.haslayer(ICMP):
            print(f"[-] {ip}:{port}     FILTERED")
            return False
        print(f"[-] {ip}:{port}     UNKNOWN")
        return False
    else:
        # TCP Connect Scan (no root privileges needed)
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((ip, port))
            if result == 0:
                print(f"[+] {ip}:{port}     OPEN")
                return True
            else:
                print(f"[-] {ip}:{port}     CLOSED")
                return False
        except socket.error as err:
            print(f"[-] {ip}:{port}     ERROR: {err}")
            return False
        finally:
            sock.close()
    
def scan_udp_port(ip: str, port=53, timeout: float=0.5, is_root=False) -> bool:
    if is_root:
        udp_pkt = IP(dst=ip) / UDP(dport=port)
        ans = sr1(udp_pkt, timeout=timeout, verbose=0)
        if ans is None:
            # possibly open/filtered by firewall
            print(f"[?] {ip}:{port}     OPEN/FILTERED")
            return False
        elif ans.haslayer(ICMP):
            icmp_type = ans[ICMP].type
            icmp_code = ans[ICMP].code
            if icmp_type == 3 and icmp_code == 3:
                print(f"[-] {ip}:{port}     CLOSED")
                return False
            else:
                # host unreachable
                print(f"[-] {ip}:{port}     FILTERED")  
                return False
        else:
            # receive response except icmp
            print(f"[+] {ip}:{port}     OPEN")  
            return True
    else:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        timeout = 1
        sock.settimeout(timeout)
        try:
            sock.sendto(b'', (ip, port))
            try:
                data, addr = sock.recvfrom(1024)
                print(f"[+] {ip}:{port}     OPEN")
                return True
            except socket.timeout:
                print(f"[?] {ip}:{port}     OPEN/FILTERED")
                return False
        except socket.error as err:
            print(f"[-] {ip}:{port}     ERROR: {err}")
            return False
        finally:
            sock.close()