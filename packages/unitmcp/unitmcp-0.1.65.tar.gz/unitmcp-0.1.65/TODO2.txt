zaktualizuj examples/runner, dodaj testy i sprawdz czy w src/unitmcp nie ma duplikatow w implementacji,
zmniejsz wielkosc plikow, jesli maja wiecej niz 3400 linii, oddziel rozne funkcje, jesli to mozliwe do osobnych plikow

uzyj runner wszedzie tam, gdzie mozna uproscic start przykladow w exampes/ z uzyciem client-server
finalnie rkazdy przyklad powinien miec w swoim folderze pliki runner, client, server, aby pokazac jak to dziala oraz przyklady impelenmentacji zpotrzebnymi plikami konfiguracji i readme
podobnie jak to jest zaimplementowane w przykladach: examples/ai

zaproponuj inne rozwiazanie jesli ten plan mozna ulepszyc, interesuje mnie jak najprawidziej zrobione rozwiazanie, gdzie w przykladach bedzie
mogl zorientowac sie jak to dziala junior programista oraz nieprogramista: devops, admin, kazdy ktory chce to urchomic w firmie laub w swoim srodowisku w domu



sprawdz czy wszystkei foldery w examples/ maja runner, client, server, aby pokazac jak to dziala oraz przyklady impelenmentacji zpotrzebnymi plikami konfiguracji i readme
sprawdz czy sa poprawnie uruchamiane, stworz skrypt do uruchamiania kolejno wszytskich przykaldow w example/ albo zaktualziuj jesli taki istnieje
bazujac na kodzie z exampels/ stworz wiecej testsow w tests/


I've been working on updating the examples in the UnitMCP project to follow a standardized structure. Let me summarize what I've accomplished so far and what still needs to be done:

Structure Standardization
I've created and implemented:

A standardized base runner in examples/runner/base_runner.py
A template directory structure in examples/template/ with:
runner.py, client.py, server.py
config/client.yaml and config/server.yaml
README.md with documentation
tests/ directory with test files
Two utility scripts:
check_example_structure.py to verify which examples follow the standard structure
convert_example_structure.py to update examples to follow the standard structure


sprawdz czy nie ma duplikatow examples po stworzeniu template,
wszysteki przyklady i pliki powinny byc rozne
jesli nie sa to stworz plan refaktoryzacji i wykonaj zmiany w opaparciu o istniejace pliki w examples
a na koneic przetestuj wszystkie przyklady w examples/
zaktualizuj readme.md w examples/ i w projekcie
czy istnieja przyklady z uzyciem shella, aby polaczyc sie ze zdalnym urzadzeniem i interaktywnie sterowac?
czego brakuje albo co mozna polepszyc w projekcie?

---

znajdz przyklad ze streowaniem gpio na rasberry pi z klienta na PC
czy aktualne przyklady z portem dzialaja na tej zasadzie co ze skryptow, porownaj
zaktualizuj dokumentacje przykladow w examples, czy w shell mozna uruchomic zdalny serwer a potem sie do niego podlaczy aby sterowac GPIO?

check tox and pytes and fix


w examples/shell_cli/README.md nie jest opisany runner.py, popraw w innych przykladach, jesli dokumentacja jest niekompletna, nie opisuje kazdego pliku i sposobu uzycia a takze konfgiugracji oraz
jak pobrac dane konfiguracyjne dla servera z .env lub z command line poprzez start runnera konfigurujacego srodowisko


w poniszych plikach jest zaszyta odpowiedzialnosc runnera z paczki unitmcp, ktory powinien zainstalowac zaleznosci i pozwolic na uztyweanie sprzetu
simple_remote_shell.py
rpi_gpio_helper.py
process_manager.py
w przypadku dzialania shell interaktywnego moga pojawic sie rozne problemy z czasem, gdyby zostaly uruchomione wiele procesow jednoczesnie, monitoruj co sie dzieje i jesli to jakas anomalia to stworz rozwiazanie


(remote) connect 192.168.188.154 --ssh --username pi --password pi
Invalid port: --ssh
(remote) connect 192.168.188.154 --port 22 --ssh --username pi --password pi
Invalid port: --port
(remote) connect 192.168.188.154 22 --ssh --username pi --password pi
SSH support not available. Install paramiko for SSH functionality.
(remote)

add real time streaming for each hardware device such for GPIO Streaming: Added real-time GPIO streaming from Raspberry Pi to client PC


poszerz dzialanie runnera, aby instalowal zaleznosci i uruchamial  aplikacje i skrypty shell,  nodejs, python, php, static html poprzez podanie tylko adresu git,
rozszerzenie powinni pobrac repo na wskazana maszyne (po adresie lub jako istnejacy client, server)
powinna byc mozliwosc uruhcmiania automatycznie, zwlaszzca jesli sa tam rozne ci dla github lub gitlab,
jesli sa jakies dane potrtzebne to interaktywnie user powinien byc zapytany, np. jesli chodzi o zmienne w .env do tego projektu git
oraz gdy po uruchomieniu tej aplikacji z git cos nie dziala poprawnie, powinny byc logi i inteligentne podpowiedzi po analizie logow


bazujac na aktualnym kodzie z folderu ./runner sprawdz czy ta implementacja runnera jest poprawna i przenies to co sie da do ./src/unitmcp aby przykładdy były proste
a cała implementacja była w bibliotece, aby runner insttalowal zaleznosci i uruchamial  aplikacje i skrypty shell,  nodejs, python, php, static html poprzez podanie tylko adresu git,

przenies src/unitmcp/orchestrator/README.md do examples/orchestrator/README.md i stworz kilka przykładów aoraz rozszerz dokumentacje



zwieksz ilsoc przykladow dla kazdej komendy orchestratora w dokumenatcji: examples/orchestrator/README.md


popraw problem z tox
]$ tox
ROOT: will run in automatically provisioned tox, host /home/tom/github/UnitApi/mcp/venv/bin/python3.12 is missing [requires (has)]: setuptools_scm>=6.2
ROOT: provision> .tox/.tox/bin/python -m tox
py311: recreate env because requirements removed: tabulate
py311: remove tox env folder /home/tom/github/UnitApi/mcp/.tox/py311
py311: install_deps> python -I -m pip install 'pyautogui>=0.9.54' 'pytest-asyncio>=0.23.0' 'pytest-cov>=4.1.0' 'pytest-mock>=3.12.0' 'pytest-timeout>=2.2.0' 'pytest>=8.3.5' -r requirements.txt -r requirements-dev.txt
^CROOT: [160661] KeyboardInterrupt - teardown started
ROOT: interrupt tox environment: py311
ROOT: requested interrupt of 160701 from 160661, activate in 0.00
ROOT: send signal SIGINT(2) to 160701 from 160661 with timeout 0.30
(venv) (base) [tom@devop mcp]$


