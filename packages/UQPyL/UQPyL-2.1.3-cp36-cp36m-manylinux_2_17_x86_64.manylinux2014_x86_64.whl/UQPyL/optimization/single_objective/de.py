# Differential Evolution <Single>

import numpy as np

from ..algorithmABC import Algorithm, Population
from ...utility import Verbose

class DE(Algorithm):
    """
    Differential Evolution (DE) Algorithm
    -------------------------------------
    This class implements a single-objective differential evolution algorithm for optimization.

    References:
    [1] Storn R, Price K. Differential Evolution (1997). A Simple and Efficient Heuristic for global Optimization over Continuous Spaces[J].
        Journal of Global Optimization, 11(4):341-359. DOI:10.1023/A:1008202821328.
    """
    
    name = "DE"
    type = "EA"
    
    def __init__(self, cr: float = 0.9, f: float = 0.5,
                 nPop: int = 50,
                 maxFEs: int = 50000, 
                 maxIterTimes: int = 1000, 
                 maxTolerateTimes: int = 1000, tolerate: float = 1e-6, 
                 verboseFlag: bool = True, verboseFreq: int = 10, logFlag: bool = False, saveFlag: bool = True):
        """
        Initialize the differential evolution algorithm with user-defined parameters.

        :param cr: Crossover probability.
        :param f: Differential weight.
        :param nPop: Population size.
        :param maxFEs: Maximum number of function evaluations.
        :param maxIterTimes: Maximum number of iterations.
        :param maxTolerateTimes: Maximum number of tolerated iterations without improvement.
        :param tolerate: Tolerance for improvement.
        :param verbose: Flag to enable verbose output.
        :param verboseFreq: Frequency of verbose output.
        :param logFlag: Flag to enable logging.
        :param saveFlag: Flag to enable saving results.
        """
        
        super().__init__(maxFEs, maxIterTimes, maxTolerateTimes, 
                            tolerate, verboseFlag, verboseFreq, logFlag, saveFlag)
        
        # Set user-defined parameters
        self.setPara('cr', cr)
        self.setPara('f', f)
        self.setPara('nPop', nPop)
        
    @Verbose.decoratorRun
    @Algorithm.initializeRun
    def run(self, problem):
        """
        Execute the differential evolution algorithm on the specified problem.

        :param problem: An instance of a class derived from ProblemABC.
                        This object defines the optimization problem, including
                        the number of inputs (nInput), number of outputs (nOutput),
                        upper bounds (ub), lower bounds (lb), and evaluation methods.
        
        :return Result: An instance of the Result class, which contains the
                        optimization results, including the best decision variables,
                        objective values, and constraint violations encountered during
                        the optimization process.
        """
        
        # Parameter Setting
        cr, f = self.getParaVal('cr', 'f')
        nPop = self.getParaVal('nPop')
        
        # Termination Condition Setting
        self.FEs = 0; self.iters = 0; self.tolerateTimes = 0
        
        # Problem
        self.setProblem(problem)
        
        # Population Generation
        pop = self.initialize(nPop)
        
        # Iterative process
        while self.checkTermination():
            
            # Select mating pool using tournament selection
            matingPool = self._tournamentSelection(pop, len(pop)*2, 2)
            
            # Generate offspring using differential evolution operations
            offspring = self._operateDE(pop, matingPool[:len(pop)], matingPool[len(pop):], cr, f)
            
            # Evaluate the offspring
            self.evaluate(offspring)
            
            # Replace inferior individuals in the population with better offspring
            idx = offspring.objs.ravel() < pop.objs.ravel()
            pop.replace(idx, offspring[idx])
            
            # Record the current state of the population
            self.record(pop)
        
        # Return the final result
        return self.result
            
    def _operateDE(self, pop1, pop2, pop3, cr, f):
        """
        Perform differential evolution operations to generate offspring.

        :param pop1: First population.
        :param pop2: Second population.
        :param pop3: Third population.
        :param cr: Crossover probability.
        :param f: Differential weight.

        :return Population: New population generated by differential evolution.
        """
        
        N, D = pop1.size()
        
        popDecs1 = pop1.decs
        popDecs2 = pop2.decs
        popDecs3 = pop3.decs
        
        # Differential Evolution operation
        sita = np.random.random((N, D)) < cr
        offspringDecs = np.copy(popDecs1)
        offspringDecs[sita] = popDecs1[sita] + (popDecs2[sita] - popDecs3[sita]) * f
        
        return Population(offspringDecs)
        
    def _tournamentSelection(self, pop, N, K: int=2):
        """
        K-tournament selection to choose individuals for mating.

        :param pop: Current population.
        :param N: Number of individuals to select.
        :param K: Number of individuals in each tournament.

        :return: Selected individuals for mating.
        """
        
        rankIndex = pop.argsort()
        rank = np.argsort(rankIndex, axis=0)
        tourSelection = np.random.randint(0, high=len(pop), size=(N, K))
        winner = np.min(rank[tourSelection].ravel().reshape(N, K), axis=1)
        winnerIndex = rankIndex[winner]
        
        return pop[winnerIndex]