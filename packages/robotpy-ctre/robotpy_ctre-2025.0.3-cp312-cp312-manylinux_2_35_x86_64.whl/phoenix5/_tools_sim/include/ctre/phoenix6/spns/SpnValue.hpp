/*
 * Copyright (C) Cross The Road Electronics.Â  All rights reserved.
 * License information can be found in CTRE_LICENSE.txt
 * For support and suggestions contact support@ctr-electronics.com or file
 * an issue tracker at https://github.com/CrossTheRoadElec/Phoenix-Releases
 */
#pragma once

#include <ostream>
#include <string>

namespace ctre
{
    namespace phoenix6
    {
        namespace spns
        {
            /**
             * \private
             *
             * \brief Class that holds all the SPN values used in Phoenix Pro devices.
             */
            class SpnValue
            {
            public:
                int value;

                static constexpr int TalonFX_System_State = 614;
                static constexpr int Startup_ResetFlags = 635;
                static constexpr int Version_Major = 733;
                static constexpr int Version_Minor = 734;
                static constexpr int Version_Bugfix = 735;
                static constexpr int Version_Build = 736;
                static constexpr int Version_Full = 737;
                static constexpr int Licensing_IsProLicensed = 750;
                static constexpr int Licensing_IsSeasonPassed = 753;
                static constexpr int CustomParam0 = 822;
                static constexpr int CustomParam1 = 823;
                static constexpr int CANcoder_SensorDirection = 827;
                static constexpr int FrcLock = 829;
                static constexpr int RobotEnabled = 830;
                static constexpr int LED1_OnColor = 832;
                static constexpr int LED1_OffColor = 833;
                static constexpr int LED2_OnColor = 834;
                static constexpr int LED2_OffColor = 835;
                static constexpr int AllFaults = 841;
                static constexpr int AllStickyFaults = 842;
                static constexpr int Pigeon2UseCompass = 916;
                static constexpr int Pigeon2DisableTemperatureCompensation = 951;
                static constexpr int Pigeon2DisableNoMotionCalibration = 953;
                static constexpr int Pigeon2MountPoseYaw = 958;
                static constexpr int Pigeon2MountPosePitch = 959;
                static constexpr int Pigeon2MountPoseRoll = 960;
                static constexpr int Pigeon2GyroScalarX = 964;
                static constexpr int Pigeon2GyroScalarY = 965;
                static constexpr int Pigeon2GyroScalarZ = 966;
                static constexpr int Pigeon2Yaw = 973;
                static constexpr int Pigeon2Pitch = 974;
                static constexpr int Pigeon2Roll = 975;
                static constexpr int Pigeon2QuatW = 976;
                static constexpr int Pigeon2QuatX = 977;
                static constexpr int Pigeon2QuatY = 978;
                static constexpr int Pigeon2QuatZ = 979;
                static constexpr int Pigeon2GravityVectorX = 980;
                static constexpr int Pigeon2GravityVectorY = 981;
                static constexpr int Pigeon2GravityVectorZ = 982;
                static constexpr int Pigeon2Temperature = 983;
                static constexpr int Pigeon2NoMotionCalEnabled = 984;
                static constexpr int Pigeon2NoMotionCount = 985;
                static constexpr int Pigeon2TempCompDisabled = 986;
                static constexpr int Pigeon2UpTime = 987;
                static constexpr int Pigeon2AccumGyroX = 988;
                static constexpr int Pigeon2AccumGyroY = 989;
                static constexpr int Pigeon2AccumGyroZ = 990;
                static constexpr int Pigeon2AngularVelocityXWorld = 991;
                static constexpr int Pigeon2AngularVelocityYWorld = 992;
                static constexpr int Pigeon2AngularVelocityZWorld = 993;
                static constexpr int Pigeon2AccelerationX = 994;
                static constexpr int Pigeon2AccelerationY = 995;
                static constexpr int Pigeon2AccelerationZ = 996;
                static constexpr int Pigeon2_SupplyVoltage = 997;
                static constexpr int Pigeon2AngularVelocityX = 1000;
                static constexpr int Pigeon2AngularVelocityY = 1001;
                static constexpr int Pigeon2AngularVelocityZ = 1002;
                static constexpr int Pigeon2MagneticFieldX = 1005;
                static constexpr int Pigeon2MagneticFieldY = 1006;
                static constexpr int Pigeon2MagneticFieldZ = 1007;
                static constexpr int Pigeon2RawMagneticFieldX = 1008;
                static constexpr int Pigeon2RawMagneticFieldY = 1009;
                static constexpr int Pigeon2RawMagneticFieldZ = 1010;
                static constexpr int CANCoder_MagnetOffset = 1011;
                static constexpr int TalonFX_SetSensorPosition = 1016;
                static constexpr int CANcoder_SetSensorPosition = 1018;
                static constexpr int Pigeon2_SetYaw = 1020;
                static constexpr int DeviceEnabled = 1049;
                static constexpr int PRO_MotorOutput_MotorVoltage = 2028;
                static constexpr int ForwardLimit = 2029;
                static constexpr int ReverseLimit = 2030;
                static constexpr int PRO_MotorOutput_RotorPolarity = 2031;
                static constexpr int PRO_MotorOutput_DutyCycle = 2032;
                static constexpr int PRO_MotorOutput_TorqueCurrent = 2034;
                static constexpr int PRO_SupplyAndTemp_StatorCurrent = 2035;
                static constexpr int PRO_SupplyAndTemp_SupplyCurrent = 2036;
                static constexpr int PRO_SupplyAndTemp_SupplyVoltage = 2037;
                static constexpr int PRO_SupplyAndTemp_DeviceTemp = 2038;
                static constexpr int PRO_SupplyAndTemp_ProcessorTemp = 2039;
                static constexpr int PRO_RotorPosAndVel_Velocity = 2041;
                static constexpr int PRO_RotorPosAndVel_Position = 2042;
                static constexpr int PRO_PosAndVel_Velocity = 2045;
                static constexpr int PRO_PosAndVel_Position = 2046;
                static constexpr int PRO_PosAndVel_Acceleration = 2047;
                static constexpr int PRO_PIDStateEnables_IntegratedAccum_DC = 2049;
                static constexpr int PRO_PIDStateEnables_IntegratedAccum_V = 2050;
                static constexpr int PRO_PIDStateEnables_IntegratedAccum_A = 2051;
                static constexpr int PRO_PIDStateEnables_FeedForward_DC = 2052;
                static constexpr int PRO_PIDStateEnables_FeedForward_V = 2053;
                static constexpr int PRO_PIDStateEnables_FeedForward_A = 2054;
                static constexpr int TalonFX_ControlMode = 2055;
                static constexpr int PRO_PIDStateEnables_IsMotionMagicRunning = 2061;
                static constexpr int PRO_PIDStateEnables_DeviceEnable = 2063;
                static constexpr int PRO_PIDRefPIDErr_PIDRef_Position = 2065;
                static constexpr int PRO_PIDRefPIDErr_PIDRef_Velocity = 2066;
                static constexpr int PRO_PIDRefPIDErr_PIDErr_Position = 2067;
                static constexpr int PRO_PIDRefPIDErr_PIDErr_Velocity = 2068;
                static constexpr int PRO_PIDRefPIDErr_ClosedLoopMode = 2069;
                static constexpr int PRO_PIDOutput_PIDOutputMode = 2071;
                static constexpr int PRO_PIDOutput_ProportionalOutput_DC = 2072;
                static constexpr int PRO_PIDOutput_ProportionalOutput_V = 2073;
                static constexpr int PRO_PIDOutput_ProportionalOutput_A = 2074;
                static constexpr int PRO_PIDOutput_DerivativeOutput_DC = 2075;
                static constexpr int PRO_PIDOutput_DerivativeOutput_V = 2076;
                static constexpr int PRO_PIDOutput_DerivativeOutput_A = 2077;
                static constexpr int PRO_PIDOutput_Output_DC = 2078;
                static constexpr int PRO_PIDOutput_Output_V = 2079;
                static constexpr int PRO_PIDOutput_Output_A = 2080;
                static constexpr int PRO_PIDOutput_Slot = 2081;
                static constexpr int PRO_PIDRefSlopeECUTime_ReferenceSlope_Position = 2082;
                static constexpr int PRO_PIDRefSlopeECUTime_ReferenceSlope_Velocity = 2083;
                static constexpr int PRO_PIDRefSlopeECUTime_ClosedLoopMode = 2084;
                static constexpr int TalonFX_MotorOutputStatus = 2085;
                static constexpr int PRO_MotorOutput_PIDState_Diff_DutyCycle = 2088;
                static constexpr int PRO_MotorOutput_PIDState_Diff_TorqueCurrent = 2089;
                static constexpr int TalonFX_DifferentialControlMode = 2092;
                static constexpr int PRO_MotorOutput_PIDState_Diff_IntegratedAccum_DC = 2093;
                static constexpr int PRO_MotorOutput_PIDState_Diff_IntegratedAccum_V = 2094;
                static constexpr int PRO_MotorOutput_PIDState_Diff_IntegratedAccum_A = 2095;
                static constexpr int PRO_MotorOutput_PIDState_Diff_FeedForward_DC = 2096;
                static constexpr int PRO_MotorOutput_PIDState_Diff_FeedForward_V = 2097;
                static constexpr int PRO_MotorOutput_PIDState_Diff_FeedForward_A = 2098;
                static constexpr int PRO_AvgPosAndVel_Velocity = 2100;
                static constexpr int PRO_AvgPosAndVel_Position = 2101;
                static constexpr int PRO_DiffPosAndVel_Velocity = 2104;
                static constexpr int PRO_DiffPosAndVel_Position = 2105;
                static constexpr int PRO_DiffPIDRefPIDErr_PIDRef_Position = 2107;
                static constexpr int PRO_DiffPIDRefPIDErr_PIDRef_Velocity = 2108;
                static constexpr int PRO_DiffPIDRefPIDErr_PIDErr_Position = 2109;
                static constexpr int PRO_DiffPIDRefPIDErr_PIDErr_Velocity = 2110;
                static constexpr int PRO_DiffPIDRefPIDErr_ClosedLoopMode = 2111;
                static constexpr int PRO_DiffPIDOutput_PIDOutputMode = 2113;
                static constexpr int PRO_DiffPIDOutput_ProportionalOutput_DC = 2114;
                static constexpr int PRO_DiffPIDOutput_ProportionalOutput_V = 2115;
                static constexpr int PRO_DiffPIDOutput_ProportionalOutput_A = 2116;
                static constexpr int PRO_DiffPIDOutput_DerivativeOutput_DC = 2117;
                static constexpr int PRO_DiffPIDOutput_DerivativeOutput_V = 2118;
                static constexpr int PRO_DiffPIDOutput_DerivativeOutput_A = 2119;
                static constexpr int PRO_DiffPIDOutput_Output_DC = 2120;
                static constexpr int PRO_DiffPIDOutput_Output_V = 2121;
                static constexpr int PRO_DiffPIDOutput_Output_A = 2122;
                static constexpr int PRO_DiffPIDOutput_Slot = 2123;
                static constexpr int PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Position = 2124;
                static constexpr int PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Velocity = 2125;
                static constexpr int PRO_DiffPIDRefSlopeECUTime_ClosedLoopMode = 2126;
                static constexpr int TalonFX_MotorConstants_kT = 2128;
                static constexpr int TalonFX_MotorConstants_kV = 2129;
                static constexpr int TalonFX_MotorConstants_StallCurrent = 2130;
                static constexpr int Slot0_kP = 2131;
                static constexpr int Slot0_kI = 2132;
                static constexpr int Slot0_kD = 2133;
                static constexpr int Slot0_kS = 2134;
                static constexpr int Slot0_kV = 2135;
                static constexpr int Slot0_kA = 2136;
                static constexpr int Slot0_kG = 2137;
                static constexpr int Slot0_kG_Type = 2138;
                static constexpr int Slot1_kP = 2139;
                static constexpr int Slot1_kI = 2140;
                static constexpr int Slot1_kD = 2141;
                static constexpr int Slot1_kS = 2142;
                static constexpr int Slot1_kV = 2143;
                static constexpr int Slot1_kA = 2144;
                static constexpr int Slot1_kG = 2145;
                static constexpr int Slot1_kG_Type = 2146;
                static constexpr int Slot2_kP = 2147;
                static constexpr int Slot2_kI = 2148;
                static constexpr int Slot2_kD = 2149;
                static constexpr int Slot2_kS = 2150;
                static constexpr int Slot2_kV = 2151;
                static constexpr int Slot2_kA = 2152;
                static constexpr int Slot2_kG = 2153;
                static constexpr int Slot2_kG_Type = 2154;
                static constexpr int Config_Inverted = 2155;
                static constexpr int Config_SupplyVLowpassTau = 2156;
                static constexpr int Config_BeepOnBoot = 2157;
                static constexpr int Config_NeutralMode = 2158;
                static constexpr int Config_DutyCycleNeutralDB = 2159;
                static constexpr int Config_StatorCurrentLimit = 2160;
                static constexpr int Config_StatorCurrLimitEn = 2161;
                static constexpr int Config_SupplyCurrentLimit = 2162;
                static constexpr int Config_SupplyCurrLimitEn = 2163;
                static constexpr int Config_PeakForwardDC = 2164;
                static constexpr int Config_PeakReverseDC = 2165;
                static constexpr int Config_PeakForwardV = 2166;
                static constexpr int Config_PeakReverseV = 2167;
                static constexpr int Config_PeakForTorqCurr = 2168;
                static constexpr int Config_PeakRevTorqCurr = 2169;
                static constexpr int Config_TorqueNeutralDB = 2170;
                static constexpr int Config_FeedbackRotorOffset = 2171;
                static constexpr int Config_SensorToMechanismRatio = 2172;
                static constexpr int Config_RotorToSensorRatio = 2173;
                static constexpr int Config_FeedbackSensorSource = 2174;
                static constexpr int Config_FeedbackRemoteSensorID = 2175;
                static constexpr int Config_DutyCycleOpenLoopRampPeriod = 2176;
                static constexpr int Config_VoltageOpenLoopRampPeriod = 2177;
                static constexpr int Config_TorqueOpenLoopRampPeriod = 2178;
                static constexpr int Config_DutyCycleClosedLoopRampPeriod = 2179;
                static constexpr int Config_VoltageClosedLoopRampPeriod = 2180;
                static constexpr int Config_TorqueClosedLoopRampPeriod = 2181;
                static constexpr int Config_ForwardLimitType = 2182;
                static constexpr int Config_ForwardLimitAutosetPosEnable = 2183;
                static constexpr int Config_ForwardLimitAutosetPosValue = 2184;
                static constexpr int Config_ForwardLimitEnable = 2185;
                static constexpr int Config_ForwardLimitSource = 2186;
                static constexpr int Config_ForwardLimitRemoteSensorID = 2187;
                static constexpr int Config_ReverseLimitType = 2188;
                static constexpr int Config_ReverseLimitAutosetPosEnable = 2189;
                static constexpr int Config_ReverseLimitAutosetPosValue = 2190;
                static constexpr int Config_ReverseLimitEnable = 2191;
                static constexpr int Config_ReverseLimitSource = 2192;
                static constexpr int Config_ReverseLimitRemoteSensorID = 2193;
                static constexpr int Config_ForwardSoftLimitEnable = 2194;
                static constexpr int Config_ReverseSoftLimitEnable = 2195;
                static constexpr int Config_ForwardSoftLimitThreshold = 2196;
                static constexpr int Config_ReverseSoftLimitThreshold = 2197;
                static constexpr int Config_MotionMagicCruiseVelocity = 2198;
                static constexpr int Config_MotionMagicAcceleration = 2199;
                static constexpr int Config_MotionMagicJerk = 2200;
                static constexpr int Config_MotionMagicExpo_kV = 2201;
                static constexpr int Config_MotionMagicExpo_kA = 2202;
                static constexpr int Config_PeakDiffDC = 2203;
                static constexpr int Config_PeakDiffV = 2204;
                static constexpr int Config_PeakDiffTorqCurr = 2205;
                static constexpr int CANcoder_Velocity = 2206;
                static constexpr int CANcoder_Position = 2207;
                static constexpr int CANcoder_AbsPosition = 2208;
                static constexpr int CANCoder_RawVel = 2210;
                static constexpr int CANCoder_RawPos = 2211;
                static constexpr int CANCoder_SupplyVoltage = 2212;
                static constexpr int CANcoder_MagHealth = 2213;
                static constexpr int SPN_ClearStickyFaults = 2216;
                static constexpr int PRO_MotorOutput_BridgeType_Public = 2217;
                static constexpr int Config_ContinuousWrap = 2239;
                static constexpr int Config_SupplyCurrentLowerLimit = 2245;
                static constexpr int Config_SupplyCurrentLowerTime = 2246;
                static constexpr int Config_DifferentialSensorSource = 2260;
                static constexpr int Config_DifferentialTalonFXSensorID = 2261;
                static constexpr int Config_DifferentialRemoteSensorID = 2262;
                static constexpr int Config_BeepOnConfig = 2301;
                static constexpr int Config_AllowMusicDurDisable = 2302;
                static constexpr int Compliancy_Version = 2303;
                static constexpr int Version_IsProLicensed = 2304;
                static constexpr int PRO_SupplyAndTemp_DeviceTemp2 = 2343;
                static constexpr int Slot0_kS_Sign = 2366;
                static constexpr int Slot1_kS_Sign = 2367;
                static constexpr int Slot2_kS_Sign = 2368;
                static constexpr int TalonFX_ConnectedMotor = 2369;
                static constexpr int CANrange_SupplyVoltage = 2391;
                static constexpr int CANrange_Distance_Meters = 2392;
                static constexpr int CANrange_MeasTime = 2394;
                static constexpr int CANrange_SignalStrength = 2395;
                static constexpr int CANrange_ProximityDetected = 2396;
                static constexpr int CANrange_MeasState = 2397;
                static constexpr int CANrange_AmbientSignal = 2398;
                static constexpr int CANrange_DistanceStdDev = 2399;
                static constexpr int CANrange_RealFOVCenterX = 2402;
                static constexpr int CANrange_RealFOVCenterY = 2403;
                static constexpr int CANrange_RealFOVRangeX = 2404;
                static constexpr int CANrange_RealFOVRangeY = 2405;
                static constexpr int CANrange_UpdateMode = 2409;
                static constexpr int CANrange_UpdateFreq = 2410;
                static constexpr int CANrange_ProximityThreshold = 2412;
                static constexpr int CANrange_ProximityHysteresis = 2413;
                static constexpr int CANrange_MinSigStrengthForValidMeas = 2414;
                static constexpr int CANrange_FOVCenterX = 2415;
                static constexpr int CANrange_FOVCenterY = 2416;
                static constexpr int CANrange_FOVRangeX = 2417;
                static constexpr int CANrange_FOVRangeY = 2418;
                static constexpr int Config_ControlTimesyncFreq = 2419;
                static constexpr int Config_VelocityFilterTimeConstant = 2420;
                static constexpr int Config_AbsoluteSensorDiscontinuityPoint = 2709;
                static constexpr int Fault_Hardware = 10001;
                static constexpr int StickyFault_Hardware = 10002;
                static constexpr int ClearStickyFault_Hardware = 10003;
                static constexpr int Fault_ProcTemp = 10004;
                static constexpr int StickyFault_ProcTemp = 10005;
                static constexpr int ClearStickyFault_ProcTemp = 10006;
                static constexpr int Fault_DeviceTemp = 10007;
                static constexpr int StickyFault_DeviceTemp = 10008;
                static constexpr int ClearStickyFault_DeviceTemp = 10009;
                static constexpr int Fault_Undervoltage = 10010;
                static constexpr int StickyFault_Undervoltage = 10011;
                static constexpr int ClearStickyFault_Undervoltage = 10012;
                static constexpr int Fault_BootDuringEnable = 10013;
                static constexpr int StickyFault_BootDuringEnable = 10014;
                static constexpr int ClearStickyFault_BootDuringEnable = 10015;
                static constexpr int Fault_UnlicensedFeatureInUse = 10016;
                static constexpr int StickyFault_UnlicensedFeatureInUse = 10017;
                static constexpr int ClearStickyFault_UnlicensedFeatureInUse = 10018;
                static constexpr int Fault_PIGEON2_BootupAccel = 10019;
                static constexpr int StickyFault_PIGEON2_BootupAccel = 10020;
                static constexpr int ClearStickyFault_PIGEON2_BootupAccel = 10021;
                static constexpr int Fault_PIGEON2_BootupGyros = 10022;
                static constexpr int StickyFault_PIGEON2_BootupGyros = 10023;
                static constexpr int ClearStickyFault_PIGEON2_BootupGyros = 10024;
                static constexpr int Fault_PIGEON2_BootupMagne = 10025;
                static constexpr int StickyFault_PIGEON2_BootupMagne = 10026;
                static constexpr int ClearStickyFault_PIGEON2_BootupMagne = 10027;
                static constexpr int Fault_PIGEON2_BootIntoMotion = 10028;
                static constexpr int StickyFault_PIGEON2_BootIntoMotion = 10029;
                static constexpr int ClearStickyFault_PIGEON2_BootIntoMotion = 10030;
                static constexpr int Fault_PIGEON2_DataAcquiredLate = 10031;
                static constexpr int StickyFault_PIGEON2_DataAcquiredLate = 10032;
                static constexpr int ClearStickyFault_PIGEON2_DataAcquiredLate = 10033;
                static constexpr int Fault_PIGEON2_LoopTimeSlow = 10034;
                static constexpr int StickyFault_PIGEON2_LoopTimeSlow = 10035;
                static constexpr int ClearStickyFault_PIGEON2_LoopTimeSlow = 10036;
                static constexpr int Fault_PIGEON2_SaturatedMagne = 10037;
                static constexpr int StickyFault_PIGEON2_SaturatedMagne = 10038;
                static constexpr int ClearStickyFault_PIGEON2_SaturatedMagne = 10039;
                static constexpr int Fault_PIGEON2_SaturatedAccel = 10040;
                static constexpr int StickyFault_PIGEON2_SaturatedAccel = 10041;
                static constexpr int ClearStickyFault_PIGEON2_SaturatedAccel = 10042;
                static constexpr int Fault_PIGEON2_SaturatedGyros = 10043;
                static constexpr int StickyFault_PIGEON2_SaturatedGyros = 10044;
                static constexpr int ClearStickyFault_PIGEON2_SaturatedGyros = 10045;
                static constexpr int Fault_CANCODER_BadMagnet = 10046;
                static constexpr int StickyFault_CANCODER_BadMagnet = 10047;
                static constexpr int ClearStickyFault_CANCODER_BadMagnet = 10048;
                static constexpr int Fault_TALONFX_BridgeBrownout = 10049;
                static constexpr int StickyFault_TALONFX_BridgeBrownout = 10050;
                static constexpr int ClearStickyFault_TALONFX_BridgeBrownout = 10051;
                static constexpr int Fault_TALONFX_RemoteSensorReset = 10052;
                static constexpr int StickyFault_TALONFX_RemoteSensorReset = 10053;
                static constexpr int ClearStickyFault_TALONFX_RemoteSensorReset = 10054;
                static constexpr int Fault_TALONFX_MissingDifferentialFX = 10055;
                static constexpr int StickyFault_TALONFX_MissingDifferentialFX = 10056;
                static constexpr int ClearStickyFault_TALONFX_MissingDifferentialFX = 10057;
                static constexpr int Fault_TALONFX_RemoteSensorPosOverflow = 10058;
                static constexpr int StickyFault_TALONFX_RemoteSensorPosOverflow = 10059;
                static constexpr int ClearStickyFault_TALONFX_RemoteSensorPosOverflow = 10060;
                static constexpr int Fault_TALONFX_OverSupplyV = 10061;
                static constexpr int StickyFault_TALONFX_OverSupplyV = 10062;
                static constexpr int ClearStickyFault_TALONFX_OverSupplyV = 10063;
                static constexpr int Fault_TALONFX_UnstableSupplyV = 10064;
                static constexpr int StickyFault_TALONFX_UnstableSupplyV = 10065;
                static constexpr int ClearStickyFault_TALONFX_UnstableSupplyV = 10066;
                static constexpr int Fault_TALONFX_ReverseHardLimit = 10067;
                static constexpr int StickyFault_TALONFX_ReverseHardLimit = 10068;
                static constexpr int ClearStickyFault_TALONFX_ReverseHardLimit = 10069;
                static constexpr int Fault_TALONFX_ForwardHardLimit = 10070;
                static constexpr int StickyFault_TALONFX_ForwardHardLimit = 10071;
                static constexpr int ClearStickyFault_TALONFX_ForwardHardLimit = 10072;
                static constexpr int Fault_TALONFX_ReverseSoftLimit = 10073;
                static constexpr int StickyFault_TALONFX_ReverseSoftLimit = 10074;
                static constexpr int ClearStickyFault_TALONFX_ReverseSoftLimit = 10075;
                static constexpr int Fault_TALONFX_ForwardSoftLimit = 10076;
                static constexpr int StickyFault_TALONFX_ForwardSoftLimit = 10077;
                static constexpr int ClearStickyFault_TALONFX_ForwardSoftLimit = 10078;
                static constexpr int Fault_TALONFX_MissingRemSoftLim = 10079;
                static constexpr int StickyFault_TALONFX_MissingRemSoftLim = 10080;
                static constexpr int ClearStickyFault_TALONFX_MissingRemSoftLim = 10081;
                static constexpr int Fault_TALONFX_MissingRemHardLim = 10082;
                static constexpr int StickyFault_TALONFX_MissingRemHardLim = 10083;
                static constexpr int ClearStickyFault_TALONFX_MissingRemHardLim = 10084;
                static constexpr int Fault_TALONFX_MissingRemoteSensor = 10085;
                static constexpr int StickyFault_TALONFX_MissingRemoteSensor = 10086;
                static constexpr int ClearStickyFault_TALONFX_MissingRemoteSensor = 10087;
                static constexpr int Fault_TALONFX_FusedSensorOutOfSync = 10088;
                static constexpr int StickyFault_TALONFX_FusedSensorOutOfSync = 10089;
                static constexpr int ClearStickyFault_TALONFX_FusedSensorOutOfSync = 10090;
                static constexpr int Fault_TALONFX_StatorCurrLimit = 10091;
                static constexpr int StickyFault_TALONFX_StatorCurrLimit = 10092;
                static constexpr int ClearStickyFault_TALONFX_StatorCurrLimit = 10093;
                static constexpr int Fault_TALONFX_SupplyCurrLimit = 10094;
                static constexpr int StickyFault_TALONFX_SupplyCurrLimit = 10095;
                static constexpr int ClearStickyFault_TALONFX_SupplyCurrLimit = 10096;
                static constexpr int Fault_TALONFX_UsingFusedCCWhileUnlicensed = 10097;
                static constexpr int StickyFault_TALONFX_UsingFusedCCWhileUnlicensed = 10098;
                static constexpr int ClearStickyFault_TALONFX_UsingFusedCCWhileUnlicensed = 10099;
                static constexpr int Fault_TALONFX_StaticBrakeDisabled = 10100;
                static constexpr int StickyFault_TALONFX_StaticBrakeDisabled = 10101;
                static constexpr int ClearStickyFault_TALONFX_StaticBrakeDisabled = 10102;

                constexpr bool operator==(SpnValue data) const
                {
                    return this->value == data.value;
                }
                constexpr bool operator==(int data) const
                {
                    return this->value == data;
                }
                constexpr bool operator!=(SpnValue data) const
                {
                    return this->value != data.value;
                }
                constexpr bool operator!=(int data) const
                {
                    return this->value != data;
                }
                constexpr bool operator<(SpnValue data) const
                {
                    return this->value < data.value;
                }
                constexpr bool operator<(int data) const
                {
                    return this->value < data;
                }

                /**
                 * \brief Gets the string representation of this enum
                 *
                 * \returns String representation of this enum
                 */
                std::string ToString() const
                {
                    switch (value)
                    {
                    case SpnValue::TalonFX_System_State: return "TalonFX_System_State";
                    case SpnValue::Startup_ResetFlags: return "Startup_ResetFlags";
                    case SpnValue::Version_Major: return "Version_Major";
                    case SpnValue::Version_Minor: return "Version_Minor";
                    case SpnValue::Version_Bugfix: return "Version_Bugfix";
                    case SpnValue::Version_Build: return "Version_Build";
                    case SpnValue::Version_Full: return "Version_Full";
                    case SpnValue::Licensing_IsProLicensed: return "Licensing_IsProLicensed";
                    case SpnValue::Licensing_IsSeasonPassed: return "Licensing_IsSeasonPassed";
                    case SpnValue::CustomParam0: return "CustomParam0";
                    case SpnValue::CustomParam1: return "CustomParam1";
                    case SpnValue::CANcoder_SensorDirection: return "CANcoder_SensorDirection";
                    case SpnValue::FrcLock: return "FrcLock";
                    case SpnValue::RobotEnabled: return "RobotEnabled";
                    case SpnValue::LED1_OnColor: return "LED1_OnColor";
                    case SpnValue::LED1_OffColor: return "LED1_OffColor";
                    case SpnValue::LED2_OnColor: return "LED2_OnColor";
                    case SpnValue::LED2_OffColor: return "LED2_OffColor";
                    case SpnValue::AllFaults: return "AllFaults";
                    case SpnValue::AllStickyFaults: return "AllStickyFaults";
                    case SpnValue::Pigeon2UseCompass: return "Pigeon2UseCompass";
                    case SpnValue::Pigeon2DisableTemperatureCompensation: return "Pigeon2DisableTemperatureCompensation";
                    case SpnValue::Pigeon2DisableNoMotionCalibration: return "Pigeon2DisableNoMotionCalibration";
                    case SpnValue::Pigeon2MountPoseYaw: return "Pigeon2MountPoseYaw";
                    case SpnValue::Pigeon2MountPosePitch: return "Pigeon2MountPosePitch";
                    case SpnValue::Pigeon2MountPoseRoll: return "Pigeon2MountPoseRoll";
                    case SpnValue::Pigeon2GyroScalarX: return "Pigeon2GyroScalarX";
                    case SpnValue::Pigeon2GyroScalarY: return "Pigeon2GyroScalarY";
                    case SpnValue::Pigeon2GyroScalarZ: return "Pigeon2GyroScalarZ";
                    case SpnValue::Pigeon2Yaw: return "Pigeon2Yaw";
                    case SpnValue::Pigeon2Pitch: return "Pigeon2Pitch";
                    case SpnValue::Pigeon2Roll: return "Pigeon2Roll";
                    case SpnValue::Pigeon2QuatW: return "Pigeon2QuatW";
                    case SpnValue::Pigeon2QuatX: return "Pigeon2QuatX";
                    case SpnValue::Pigeon2QuatY: return "Pigeon2QuatY";
                    case SpnValue::Pigeon2QuatZ: return "Pigeon2QuatZ";
                    case SpnValue::Pigeon2GravityVectorX: return "Pigeon2GravityVectorX";
                    case SpnValue::Pigeon2GravityVectorY: return "Pigeon2GravityVectorY";
                    case SpnValue::Pigeon2GravityVectorZ: return "Pigeon2GravityVectorZ";
                    case SpnValue::Pigeon2Temperature: return "Pigeon2Temperature";
                    case SpnValue::Pigeon2NoMotionCalEnabled: return "Pigeon2NoMotionCalEnabled";
                    case SpnValue::Pigeon2NoMotionCount: return "Pigeon2NoMotionCount";
                    case SpnValue::Pigeon2TempCompDisabled: return "Pigeon2TempCompDisabled";
                    case SpnValue::Pigeon2UpTime: return "Pigeon2UpTime";
                    case SpnValue::Pigeon2AccumGyroX: return "Pigeon2AccumGyroX";
                    case SpnValue::Pigeon2AccumGyroY: return "Pigeon2AccumGyroY";
                    case SpnValue::Pigeon2AccumGyroZ: return "Pigeon2AccumGyroZ";
                    case SpnValue::Pigeon2AngularVelocityXWorld: return "Pigeon2AngularVelocityXWorld";
                    case SpnValue::Pigeon2AngularVelocityYWorld: return "Pigeon2AngularVelocityYWorld";
                    case SpnValue::Pigeon2AngularVelocityZWorld: return "Pigeon2AngularVelocityZWorld";
                    case SpnValue::Pigeon2AccelerationX: return "Pigeon2AccelerationX";
                    case SpnValue::Pigeon2AccelerationY: return "Pigeon2AccelerationY";
                    case SpnValue::Pigeon2AccelerationZ: return "Pigeon2AccelerationZ";
                    case SpnValue::Pigeon2_SupplyVoltage: return "Pigeon2_SupplyVoltage";
                    case SpnValue::Pigeon2AngularVelocityX: return "Pigeon2AngularVelocityX";
                    case SpnValue::Pigeon2AngularVelocityY: return "Pigeon2AngularVelocityY";
                    case SpnValue::Pigeon2AngularVelocityZ: return "Pigeon2AngularVelocityZ";
                    case SpnValue::Pigeon2MagneticFieldX: return "Pigeon2MagneticFieldX";
                    case SpnValue::Pigeon2MagneticFieldY: return "Pigeon2MagneticFieldY";
                    case SpnValue::Pigeon2MagneticFieldZ: return "Pigeon2MagneticFieldZ";
                    case SpnValue::Pigeon2RawMagneticFieldX: return "Pigeon2RawMagneticFieldX";
                    case SpnValue::Pigeon2RawMagneticFieldY: return "Pigeon2RawMagneticFieldY";
                    case SpnValue::Pigeon2RawMagneticFieldZ: return "Pigeon2RawMagneticFieldZ";
                    case SpnValue::CANCoder_MagnetOffset: return "CANCoder_MagnetOffset";
                    case SpnValue::TalonFX_SetSensorPosition: return "TalonFX_SetSensorPosition";
                    case SpnValue::CANcoder_SetSensorPosition: return "CANcoder_SetSensorPosition";
                    case SpnValue::Pigeon2_SetYaw: return "Pigeon2_SetYaw";
                    case SpnValue::DeviceEnabled: return "DeviceEnabled";
                    case SpnValue::PRO_MotorOutput_MotorVoltage: return "PRO_MotorOutput_MotorVoltage";
                    case SpnValue::ForwardLimit: return "ForwardLimit";
                    case SpnValue::ReverseLimit: return "ReverseLimit";
                    case SpnValue::PRO_MotorOutput_RotorPolarity: return "PRO_MotorOutput_RotorPolarity";
                    case SpnValue::PRO_MotorOutput_DutyCycle: return "PRO_MotorOutput_DutyCycle";
                    case SpnValue::PRO_MotorOutput_TorqueCurrent: return "PRO_MotorOutput_TorqueCurrent";
                    case SpnValue::PRO_SupplyAndTemp_StatorCurrent: return "PRO_SupplyAndTemp_StatorCurrent";
                    case SpnValue::PRO_SupplyAndTemp_SupplyCurrent: return "PRO_SupplyAndTemp_SupplyCurrent";
                    case SpnValue::PRO_SupplyAndTemp_SupplyVoltage: return "PRO_SupplyAndTemp_SupplyVoltage";
                    case SpnValue::PRO_SupplyAndTemp_DeviceTemp: return "PRO_SupplyAndTemp_DeviceTemp";
                    case SpnValue::PRO_SupplyAndTemp_ProcessorTemp: return "PRO_SupplyAndTemp_ProcessorTemp";
                    case SpnValue::PRO_RotorPosAndVel_Velocity: return "PRO_RotorPosAndVel_Velocity";
                    case SpnValue::PRO_RotorPosAndVel_Position: return "PRO_RotorPosAndVel_Position";
                    case SpnValue::PRO_PosAndVel_Velocity: return "PRO_PosAndVel_Velocity";
                    case SpnValue::PRO_PosAndVel_Position: return "PRO_PosAndVel_Position";
                    case SpnValue::PRO_PosAndVel_Acceleration: return "PRO_PosAndVel_Acceleration";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_DC: return "PRO_PIDStateEnables_IntegratedAccum_DC";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_V: return "PRO_PIDStateEnables_IntegratedAccum_V";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_A: return "PRO_PIDStateEnables_IntegratedAccum_A";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_DC: return "PRO_PIDStateEnables_FeedForward_DC";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_V: return "PRO_PIDStateEnables_FeedForward_V";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_A: return "PRO_PIDStateEnables_FeedForward_A";
                    case SpnValue::TalonFX_ControlMode: return "TalonFX_ControlMode";
                    case SpnValue::PRO_PIDStateEnables_IsMotionMagicRunning: return "PRO_PIDStateEnables_IsMotionMagicRunning";
                    case SpnValue::PRO_PIDStateEnables_DeviceEnable: return "PRO_PIDStateEnables_DeviceEnable";
                    case SpnValue::PRO_PIDRefPIDErr_PIDRef_Position: return "PRO_PIDRefPIDErr_PIDRef_Position";
                    case SpnValue::PRO_PIDRefPIDErr_PIDRef_Velocity: return "PRO_PIDRefPIDErr_PIDRef_Velocity";
                    case SpnValue::PRO_PIDRefPIDErr_PIDErr_Position: return "PRO_PIDRefPIDErr_PIDErr_Position";
                    case SpnValue::PRO_PIDRefPIDErr_PIDErr_Velocity: return "PRO_PIDRefPIDErr_PIDErr_Velocity";
                    case SpnValue::PRO_PIDRefPIDErr_ClosedLoopMode: return "PRO_PIDRefPIDErr_ClosedLoopMode";
                    case SpnValue::PRO_PIDOutput_PIDOutputMode: return "PRO_PIDOutput_PIDOutputMode";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_DC: return "PRO_PIDOutput_ProportionalOutput_DC";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_V: return "PRO_PIDOutput_ProportionalOutput_V";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_A: return "PRO_PIDOutput_ProportionalOutput_A";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_DC: return "PRO_PIDOutput_DerivativeOutput_DC";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_V: return "PRO_PIDOutput_DerivativeOutput_V";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_A: return "PRO_PIDOutput_DerivativeOutput_A";
                    case SpnValue::PRO_PIDOutput_Output_DC: return "PRO_PIDOutput_Output_DC";
                    case SpnValue::PRO_PIDOutput_Output_V: return "PRO_PIDOutput_Output_V";
                    case SpnValue::PRO_PIDOutput_Output_A: return "PRO_PIDOutput_Output_A";
                    case SpnValue::PRO_PIDOutput_Slot: return "PRO_PIDOutput_Slot";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ReferenceSlope_Position: return "PRO_PIDRefSlopeECUTime_ReferenceSlope_Position";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ReferenceSlope_Velocity: return "PRO_PIDRefSlopeECUTime_ReferenceSlope_Velocity";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ClosedLoopMode: return "PRO_PIDRefSlopeECUTime_ClosedLoopMode";
                    case SpnValue::TalonFX_MotorOutputStatus: return "TalonFX_MotorOutputStatus";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_DutyCycle: return "PRO_MotorOutput_PIDState_Diff_DutyCycle";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_TorqueCurrent: return "PRO_MotorOutput_PIDState_Diff_TorqueCurrent";
                    case SpnValue::TalonFX_DifferentialControlMode: return "TalonFX_DifferentialControlMode";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_DC: return "PRO_MotorOutput_PIDState_Diff_IntegratedAccum_DC";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_V: return "PRO_MotorOutput_PIDState_Diff_IntegratedAccum_V";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_A: return "PRO_MotorOutput_PIDState_Diff_IntegratedAccum_A";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_DC: return "PRO_MotorOutput_PIDState_Diff_FeedForward_DC";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_V: return "PRO_MotorOutput_PIDState_Diff_FeedForward_V";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_A: return "PRO_MotorOutput_PIDState_Diff_FeedForward_A";
                    case SpnValue::PRO_AvgPosAndVel_Velocity: return "PRO_AvgPosAndVel_Velocity";
                    case SpnValue::PRO_AvgPosAndVel_Position: return "PRO_AvgPosAndVel_Position";
                    case SpnValue::PRO_DiffPosAndVel_Velocity: return "PRO_DiffPosAndVel_Velocity";
                    case SpnValue::PRO_DiffPosAndVel_Position: return "PRO_DiffPosAndVel_Position";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDRef_Position: return "PRO_DiffPIDRefPIDErr_PIDRef_Position";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDRef_Velocity: return "PRO_DiffPIDRefPIDErr_PIDRef_Velocity";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDErr_Position: return "PRO_DiffPIDRefPIDErr_PIDErr_Position";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDErr_Velocity: return "PRO_DiffPIDRefPIDErr_PIDErr_Velocity";
                    case SpnValue::PRO_DiffPIDRefPIDErr_ClosedLoopMode: return "PRO_DiffPIDRefPIDErr_ClosedLoopMode";
                    case SpnValue::PRO_DiffPIDOutput_PIDOutputMode: return "PRO_DiffPIDOutput_PIDOutputMode";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_DC: return "PRO_DiffPIDOutput_ProportionalOutput_DC";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_V: return "PRO_DiffPIDOutput_ProportionalOutput_V";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_A: return "PRO_DiffPIDOutput_ProportionalOutput_A";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_DC: return "PRO_DiffPIDOutput_DerivativeOutput_DC";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_V: return "PRO_DiffPIDOutput_DerivativeOutput_V";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_A: return "PRO_DiffPIDOutput_DerivativeOutput_A";
                    case SpnValue::PRO_DiffPIDOutput_Output_DC: return "PRO_DiffPIDOutput_Output_DC";
                    case SpnValue::PRO_DiffPIDOutput_Output_V: return "PRO_DiffPIDOutput_Output_V";
                    case SpnValue::PRO_DiffPIDOutput_Output_A: return "PRO_DiffPIDOutput_Output_A";
                    case SpnValue::PRO_DiffPIDOutput_Slot: return "PRO_DiffPIDOutput_Slot";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Position: return "PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Position";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Velocity: return "PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Velocity";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ClosedLoopMode: return "PRO_DiffPIDRefSlopeECUTime_ClosedLoopMode";
                    case SpnValue::TalonFX_MotorConstants_kT: return "TalonFX_MotorConstants_kT";
                    case SpnValue::TalonFX_MotorConstants_kV: return "TalonFX_MotorConstants_kV";
                    case SpnValue::TalonFX_MotorConstants_StallCurrent: return "TalonFX_MotorConstants_StallCurrent";
                    case SpnValue::Slot0_kP: return "Slot0_kP";
                    case SpnValue::Slot0_kI: return "Slot0_kI";
                    case SpnValue::Slot0_kD: return "Slot0_kD";
                    case SpnValue::Slot0_kS: return "Slot0_kS";
                    case SpnValue::Slot0_kV: return "Slot0_kV";
                    case SpnValue::Slot0_kA: return "Slot0_kA";
                    case SpnValue::Slot0_kG: return "Slot0_kG";
                    case SpnValue::Slot0_kG_Type: return "Slot0_kG_Type";
                    case SpnValue::Slot1_kP: return "Slot1_kP";
                    case SpnValue::Slot1_kI: return "Slot1_kI";
                    case SpnValue::Slot1_kD: return "Slot1_kD";
                    case SpnValue::Slot1_kS: return "Slot1_kS";
                    case SpnValue::Slot1_kV: return "Slot1_kV";
                    case SpnValue::Slot1_kA: return "Slot1_kA";
                    case SpnValue::Slot1_kG: return "Slot1_kG";
                    case SpnValue::Slot1_kG_Type: return "Slot1_kG_Type";
                    case SpnValue::Slot2_kP: return "Slot2_kP";
                    case SpnValue::Slot2_kI: return "Slot2_kI";
                    case SpnValue::Slot2_kD: return "Slot2_kD";
                    case SpnValue::Slot2_kS: return "Slot2_kS";
                    case SpnValue::Slot2_kV: return "Slot2_kV";
                    case SpnValue::Slot2_kA: return "Slot2_kA";
                    case SpnValue::Slot2_kG: return "Slot2_kG";
                    case SpnValue::Slot2_kG_Type: return "Slot2_kG_Type";
                    case SpnValue::Config_Inverted: return "Config_Inverted";
                    case SpnValue::Config_SupplyVLowpassTau: return "Config_SupplyVLowpassTau";
                    case SpnValue::Config_BeepOnBoot: return "Config_BeepOnBoot";
                    case SpnValue::Config_NeutralMode: return "Config_NeutralMode";
                    case SpnValue::Config_DutyCycleNeutralDB: return "Config_DutyCycleNeutralDB";
                    case SpnValue::Config_StatorCurrentLimit: return "Config_StatorCurrentLimit";
                    case SpnValue::Config_StatorCurrLimitEn: return "Config_StatorCurrLimitEn";
                    case SpnValue::Config_SupplyCurrentLimit: return "Config_SupplyCurrentLimit";
                    case SpnValue::Config_SupplyCurrLimitEn: return "Config_SupplyCurrLimitEn";
                    case SpnValue::Config_PeakForwardDC: return "Config_PeakForwardDC";
                    case SpnValue::Config_PeakReverseDC: return "Config_PeakReverseDC";
                    case SpnValue::Config_PeakForwardV: return "Config_PeakForwardV";
                    case SpnValue::Config_PeakReverseV: return "Config_PeakReverseV";
                    case SpnValue::Config_PeakForTorqCurr: return "Config_PeakForTorqCurr";
                    case SpnValue::Config_PeakRevTorqCurr: return "Config_PeakRevTorqCurr";
                    case SpnValue::Config_TorqueNeutralDB: return "Config_TorqueNeutralDB";
                    case SpnValue::Config_FeedbackRotorOffset: return "Config_FeedbackRotorOffset";
                    case SpnValue::Config_SensorToMechanismRatio: return "Config_SensorToMechanismRatio";
                    case SpnValue::Config_RotorToSensorRatio: return "Config_RotorToSensorRatio";
                    case SpnValue::Config_FeedbackSensorSource: return "Config_FeedbackSensorSource";
                    case SpnValue::Config_FeedbackRemoteSensorID: return "Config_FeedbackRemoteSensorID";
                    case SpnValue::Config_DutyCycleOpenLoopRampPeriod: return "Config_DutyCycleOpenLoopRampPeriod";
                    case SpnValue::Config_VoltageOpenLoopRampPeriod: return "Config_VoltageOpenLoopRampPeriod";
                    case SpnValue::Config_TorqueOpenLoopRampPeriod: return "Config_TorqueOpenLoopRampPeriod";
                    case SpnValue::Config_DutyCycleClosedLoopRampPeriod: return "Config_DutyCycleClosedLoopRampPeriod";
                    case SpnValue::Config_VoltageClosedLoopRampPeriod: return "Config_VoltageClosedLoopRampPeriod";
                    case SpnValue::Config_TorqueClosedLoopRampPeriod: return "Config_TorqueClosedLoopRampPeriod";
                    case SpnValue::Config_ForwardLimitType: return "Config_ForwardLimitType";
                    case SpnValue::Config_ForwardLimitAutosetPosEnable: return "Config_ForwardLimitAutosetPosEnable";
                    case SpnValue::Config_ForwardLimitAutosetPosValue: return "Config_ForwardLimitAutosetPosValue";
                    case SpnValue::Config_ForwardLimitEnable: return "Config_ForwardLimitEnable";
                    case SpnValue::Config_ForwardLimitSource: return "Config_ForwardLimitSource";
                    case SpnValue::Config_ForwardLimitRemoteSensorID: return "Config_ForwardLimitRemoteSensorID";
                    case SpnValue::Config_ReverseLimitType: return "Config_ReverseLimitType";
                    case SpnValue::Config_ReverseLimitAutosetPosEnable: return "Config_ReverseLimitAutosetPosEnable";
                    case SpnValue::Config_ReverseLimitAutosetPosValue: return "Config_ReverseLimitAutosetPosValue";
                    case SpnValue::Config_ReverseLimitEnable: return "Config_ReverseLimitEnable";
                    case SpnValue::Config_ReverseLimitSource: return "Config_ReverseLimitSource";
                    case SpnValue::Config_ReverseLimitRemoteSensorID: return "Config_ReverseLimitRemoteSensorID";
                    case SpnValue::Config_ForwardSoftLimitEnable: return "Config_ForwardSoftLimitEnable";
                    case SpnValue::Config_ReverseSoftLimitEnable: return "Config_ReverseSoftLimitEnable";
                    case SpnValue::Config_ForwardSoftLimitThreshold: return "Config_ForwardSoftLimitThreshold";
                    case SpnValue::Config_ReverseSoftLimitThreshold: return "Config_ReverseSoftLimitThreshold";
                    case SpnValue::Config_MotionMagicCruiseVelocity: return "Config_MotionMagicCruiseVelocity";
                    case SpnValue::Config_MotionMagicAcceleration: return "Config_MotionMagicAcceleration";
                    case SpnValue::Config_MotionMagicJerk: return "Config_MotionMagicJerk";
                    case SpnValue::Config_MotionMagicExpo_kV: return "Config_MotionMagicExpo_kV";
                    case SpnValue::Config_MotionMagicExpo_kA: return "Config_MotionMagicExpo_kA";
                    case SpnValue::Config_PeakDiffDC: return "Config_PeakDiffDC";
                    case SpnValue::Config_PeakDiffV: return "Config_PeakDiffV";
                    case SpnValue::Config_PeakDiffTorqCurr: return "Config_PeakDiffTorqCurr";
                    case SpnValue::CANcoder_Velocity: return "CANcoder_Velocity";
                    case SpnValue::CANcoder_Position: return "CANcoder_Position";
                    case SpnValue::CANcoder_AbsPosition: return "CANcoder_AbsPosition";
                    case SpnValue::CANCoder_RawVel: return "CANCoder_RawVel";
                    case SpnValue::CANCoder_RawPos: return "CANCoder_RawPos";
                    case SpnValue::CANCoder_SupplyVoltage: return "CANCoder_SupplyVoltage";
                    case SpnValue::CANcoder_MagHealth: return "CANcoder_MagHealth";
                    case SpnValue::SPN_ClearStickyFaults: return "SPN_ClearStickyFaults";
                    case SpnValue::PRO_MotorOutput_BridgeType_Public: return "PRO_MotorOutput_BridgeType_Public";
                    case SpnValue::Config_ContinuousWrap: return "Config_ContinuousWrap";
                    case SpnValue::Config_SupplyCurrentLowerLimit: return "Config_SupplyCurrentLowerLimit";
                    case SpnValue::Config_SupplyCurrentLowerTime: return "Config_SupplyCurrentLowerTime";
                    case SpnValue::Config_DifferentialSensorSource: return "Config_DifferentialSensorSource";
                    case SpnValue::Config_DifferentialTalonFXSensorID: return "Config_DifferentialTalonFXSensorID";
                    case SpnValue::Config_DifferentialRemoteSensorID: return "Config_DifferentialRemoteSensorID";
                    case SpnValue::Config_BeepOnConfig: return "Config_BeepOnConfig";
                    case SpnValue::Config_AllowMusicDurDisable: return "Config_AllowMusicDurDisable";
                    case SpnValue::Compliancy_Version: return "Compliancy_Version";
                    case SpnValue::Version_IsProLicensed: return "Version_IsProLicensed";
                    case SpnValue::PRO_SupplyAndTemp_DeviceTemp2: return "PRO_SupplyAndTemp_DeviceTemp2";
                    case SpnValue::Slot0_kS_Sign: return "Slot0_kS_Sign";
                    case SpnValue::Slot1_kS_Sign: return "Slot1_kS_Sign";
                    case SpnValue::Slot2_kS_Sign: return "Slot2_kS_Sign";
                    case SpnValue::TalonFX_ConnectedMotor: return "TalonFX_ConnectedMotor";
                    case SpnValue::CANrange_SupplyVoltage: return "CANrange_SupplyVoltage";
                    case SpnValue::CANrange_Distance_Meters: return "CANrange_Distance_Meters";
                    case SpnValue::CANrange_MeasTime: return "CANrange_MeasTime";
                    case SpnValue::CANrange_SignalStrength: return "CANrange_SignalStrength";
                    case SpnValue::CANrange_ProximityDetected: return "CANrange_ProximityDetected";
                    case SpnValue::CANrange_MeasState: return "CANrange_MeasState";
                    case SpnValue::CANrange_AmbientSignal: return "CANrange_AmbientSignal";
                    case SpnValue::CANrange_DistanceStdDev: return "CANrange_DistanceStdDev";
                    case SpnValue::CANrange_RealFOVCenterX: return "CANrange_RealFOVCenterX";
                    case SpnValue::CANrange_RealFOVCenterY: return "CANrange_RealFOVCenterY";
                    case SpnValue::CANrange_RealFOVRangeX: return "CANrange_RealFOVRangeX";
                    case SpnValue::CANrange_RealFOVRangeY: return "CANrange_RealFOVRangeY";
                    case SpnValue::CANrange_UpdateMode: return "CANrange_UpdateMode";
                    case SpnValue::CANrange_UpdateFreq: return "CANrange_UpdateFreq";
                    case SpnValue::CANrange_ProximityThreshold: return "CANrange_ProximityThreshold";
                    case SpnValue::CANrange_ProximityHysteresis: return "CANrange_ProximityHysteresis";
                    case SpnValue::CANrange_MinSigStrengthForValidMeas: return "CANrange_MinSigStrengthForValidMeas";
                    case SpnValue::CANrange_FOVCenterX: return "CANrange_FOVCenterX";
                    case SpnValue::CANrange_FOVCenterY: return "CANrange_FOVCenterY";
                    case SpnValue::CANrange_FOVRangeX: return "CANrange_FOVRangeX";
                    case SpnValue::CANrange_FOVRangeY: return "CANrange_FOVRangeY";
                    case SpnValue::Config_ControlTimesyncFreq: return "Config_ControlTimesyncFreq";
                    case SpnValue::Config_VelocityFilterTimeConstant: return "Config_VelocityFilterTimeConstant";
                    case SpnValue::Config_AbsoluteSensorDiscontinuityPoint: return "Config_AbsoluteSensorDiscontinuityPoint";
                    case SpnValue::Fault_Hardware: return "Fault_Hardware";
                    case SpnValue::StickyFault_Hardware: return "StickyFault_Hardware";
                    case SpnValue::ClearStickyFault_Hardware: return "ClearStickyFault_Hardware";
                    case SpnValue::Fault_ProcTemp: return "Fault_ProcTemp";
                    case SpnValue::StickyFault_ProcTemp: return "StickyFault_ProcTemp";
                    case SpnValue::ClearStickyFault_ProcTemp: return "ClearStickyFault_ProcTemp";
                    case SpnValue::Fault_DeviceTemp: return "Fault_DeviceTemp";
                    case SpnValue::StickyFault_DeviceTemp: return "StickyFault_DeviceTemp";
                    case SpnValue::ClearStickyFault_DeviceTemp: return "ClearStickyFault_DeviceTemp";
                    case SpnValue::Fault_Undervoltage: return "Fault_Undervoltage";
                    case SpnValue::StickyFault_Undervoltage: return "StickyFault_Undervoltage";
                    case SpnValue::ClearStickyFault_Undervoltage: return "ClearStickyFault_Undervoltage";
                    case SpnValue::Fault_BootDuringEnable: return "Fault_BootDuringEnable";
                    case SpnValue::StickyFault_BootDuringEnable: return "StickyFault_BootDuringEnable";
                    case SpnValue::ClearStickyFault_BootDuringEnable: return "ClearStickyFault_BootDuringEnable";
                    case SpnValue::Fault_UnlicensedFeatureInUse: return "Fault_UnlicensedFeatureInUse";
                    case SpnValue::StickyFault_UnlicensedFeatureInUse: return "StickyFault_UnlicensedFeatureInUse";
                    case SpnValue::ClearStickyFault_UnlicensedFeatureInUse: return "ClearStickyFault_UnlicensedFeatureInUse";
                    case SpnValue::Fault_PIGEON2_BootupAccel: return "Fault_PIGEON2_BootupAccel";
                    case SpnValue::StickyFault_PIGEON2_BootupAccel: return "StickyFault_PIGEON2_BootupAccel";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupAccel: return "ClearStickyFault_PIGEON2_BootupAccel";
                    case SpnValue::Fault_PIGEON2_BootupGyros: return "Fault_PIGEON2_BootupGyros";
                    case SpnValue::StickyFault_PIGEON2_BootupGyros: return "StickyFault_PIGEON2_BootupGyros";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupGyros: return "ClearStickyFault_PIGEON2_BootupGyros";
                    case SpnValue::Fault_PIGEON2_BootupMagne: return "Fault_PIGEON2_BootupMagne";
                    case SpnValue::StickyFault_PIGEON2_BootupMagne: return "StickyFault_PIGEON2_BootupMagne";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupMagne: return "ClearStickyFault_PIGEON2_BootupMagne";
                    case SpnValue::Fault_PIGEON2_BootIntoMotion: return "Fault_PIGEON2_BootIntoMotion";
                    case SpnValue::StickyFault_PIGEON2_BootIntoMotion: return "StickyFault_PIGEON2_BootIntoMotion";
                    case SpnValue::ClearStickyFault_PIGEON2_BootIntoMotion: return "ClearStickyFault_PIGEON2_BootIntoMotion";
                    case SpnValue::Fault_PIGEON2_DataAcquiredLate: return "Fault_PIGEON2_DataAcquiredLate";
                    case SpnValue::StickyFault_PIGEON2_DataAcquiredLate: return "StickyFault_PIGEON2_DataAcquiredLate";
                    case SpnValue::ClearStickyFault_PIGEON2_DataAcquiredLate: return "ClearStickyFault_PIGEON2_DataAcquiredLate";
                    case SpnValue::Fault_PIGEON2_LoopTimeSlow: return "Fault_PIGEON2_LoopTimeSlow";
                    case SpnValue::StickyFault_PIGEON2_LoopTimeSlow: return "StickyFault_PIGEON2_LoopTimeSlow";
                    case SpnValue::ClearStickyFault_PIGEON2_LoopTimeSlow: return "ClearStickyFault_PIGEON2_LoopTimeSlow";
                    case SpnValue::Fault_PIGEON2_SaturatedMagne: return "Fault_PIGEON2_SaturatedMagne";
                    case SpnValue::StickyFault_PIGEON2_SaturatedMagne: return "StickyFault_PIGEON2_SaturatedMagne";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedMagne: return "ClearStickyFault_PIGEON2_SaturatedMagne";
                    case SpnValue::Fault_PIGEON2_SaturatedAccel: return "Fault_PIGEON2_SaturatedAccel";
                    case SpnValue::StickyFault_PIGEON2_SaturatedAccel: return "StickyFault_PIGEON2_SaturatedAccel";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedAccel: return "ClearStickyFault_PIGEON2_SaturatedAccel";
                    case SpnValue::Fault_PIGEON2_SaturatedGyros: return "Fault_PIGEON2_SaturatedGyros";
                    case SpnValue::StickyFault_PIGEON2_SaturatedGyros: return "StickyFault_PIGEON2_SaturatedGyros";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedGyros: return "ClearStickyFault_PIGEON2_SaturatedGyros";
                    case SpnValue::Fault_CANCODER_BadMagnet: return "Fault_CANCODER_BadMagnet";
                    case SpnValue::StickyFault_CANCODER_BadMagnet: return "StickyFault_CANCODER_BadMagnet";
                    case SpnValue::ClearStickyFault_CANCODER_BadMagnet: return "ClearStickyFault_CANCODER_BadMagnet";
                    case SpnValue::Fault_TALONFX_BridgeBrownout: return "Fault_TALONFX_BridgeBrownout";
                    case SpnValue::StickyFault_TALONFX_BridgeBrownout: return "StickyFault_TALONFX_BridgeBrownout";
                    case SpnValue::ClearStickyFault_TALONFX_BridgeBrownout: return "ClearStickyFault_TALONFX_BridgeBrownout";
                    case SpnValue::Fault_TALONFX_RemoteSensorReset: return "Fault_TALONFX_RemoteSensorReset";
                    case SpnValue::StickyFault_TALONFX_RemoteSensorReset: return "StickyFault_TALONFX_RemoteSensorReset";
                    case SpnValue::ClearStickyFault_TALONFX_RemoteSensorReset: return "ClearStickyFault_TALONFX_RemoteSensorReset";
                    case SpnValue::Fault_TALONFX_MissingDifferentialFX: return "Fault_TALONFX_MissingDifferentialFX";
                    case SpnValue::StickyFault_TALONFX_MissingDifferentialFX: return "StickyFault_TALONFX_MissingDifferentialFX";
                    case SpnValue::ClearStickyFault_TALONFX_MissingDifferentialFX: return "ClearStickyFault_TALONFX_MissingDifferentialFX";
                    case SpnValue::Fault_TALONFX_RemoteSensorPosOverflow: return "Fault_TALONFX_RemoteSensorPosOverflow";
                    case SpnValue::StickyFault_TALONFX_RemoteSensorPosOverflow: return "StickyFault_TALONFX_RemoteSensorPosOverflow";
                    case SpnValue::ClearStickyFault_TALONFX_RemoteSensorPosOverflow: return "ClearStickyFault_TALONFX_RemoteSensorPosOverflow";
                    case SpnValue::Fault_TALONFX_OverSupplyV: return "Fault_TALONFX_OverSupplyV";
                    case SpnValue::StickyFault_TALONFX_OverSupplyV: return "StickyFault_TALONFX_OverSupplyV";
                    case SpnValue::ClearStickyFault_TALONFX_OverSupplyV: return "ClearStickyFault_TALONFX_OverSupplyV";
                    case SpnValue::Fault_TALONFX_UnstableSupplyV: return "Fault_TALONFX_UnstableSupplyV";
                    case SpnValue::StickyFault_TALONFX_UnstableSupplyV: return "StickyFault_TALONFX_UnstableSupplyV";
                    case SpnValue::ClearStickyFault_TALONFX_UnstableSupplyV: return "ClearStickyFault_TALONFX_UnstableSupplyV";
                    case SpnValue::Fault_TALONFX_ReverseHardLimit: return "Fault_TALONFX_ReverseHardLimit";
                    case SpnValue::StickyFault_TALONFX_ReverseHardLimit: return "StickyFault_TALONFX_ReverseHardLimit";
                    case SpnValue::ClearStickyFault_TALONFX_ReverseHardLimit: return "ClearStickyFault_TALONFX_ReverseHardLimit";
                    case SpnValue::Fault_TALONFX_ForwardHardLimit: return "Fault_TALONFX_ForwardHardLimit";
                    case SpnValue::StickyFault_TALONFX_ForwardHardLimit: return "StickyFault_TALONFX_ForwardHardLimit";
                    case SpnValue::ClearStickyFault_TALONFX_ForwardHardLimit: return "ClearStickyFault_TALONFX_ForwardHardLimit";
                    case SpnValue::Fault_TALONFX_ReverseSoftLimit: return "Fault_TALONFX_ReverseSoftLimit";
                    case SpnValue::StickyFault_TALONFX_ReverseSoftLimit: return "StickyFault_TALONFX_ReverseSoftLimit";
                    case SpnValue::ClearStickyFault_TALONFX_ReverseSoftLimit: return "ClearStickyFault_TALONFX_ReverseSoftLimit";
                    case SpnValue::Fault_TALONFX_ForwardSoftLimit: return "Fault_TALONFX_ForwardSoftLimit";
                    case SpnValue::StickyFault_TALONFX_ForwardSoftLimit: return "StickyFault_TALONFX_ForwardSoftLimit";
                    case SpnValue::ClearStickyFault_TALONFX_ForwardSoftLimit: return "ClearStickyFault_TALONFX_ForwardSoftLimit";
                    case SpnValue::Fault_TALONFX_MissingRemSoftLim: return "Fault_TALONFX_MissingRemSoftLim";
                    case SpnValue::StickyFault_TALONFX_MissingRemSoftLim: return "StickyFault_TALONFX_MissingRemSoftLim";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemSoftLim: return "ClearStickyFault_TALONFX_MissingRemSoftLim";
                    case SpnValue::Fault_TALONFX_MissingRemHardLim: return "Fault_TALONFX_MissingRemHardLim";
                    case SpnValue::StickyFault_TALONFX_MissingRemHardLim: return "StickyFault_TALONFX_MissingRemHardLim";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemHardLim: return "ClearStickyFault_TALONFX_MissingRemHardLim";
                    case SpnValue::Fault_TALONFX_MissingRemoteSensor: return "Fault_TALONFX_MissingRemoteSensor";
                    case SpnValue::StickyFault_TALONFX_MissingRemoteSensor: return "StickyFault_TALONFX_MissingRemoteSensor";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemoteSensor: return "ClearStickyFault_TALONFX_MissingRemoteSensor";
                    case SpnValue::Fault_TALONFX_FusedSensorOutOfSync: return "Fault_TALONFX_FusedSensorOutOfSync";
                    case SpnValue::StickyFault_TALONFX_FusedSensorOutOfSync: return "StickyFault_TALONFX_FusedSensorOutOfSync";
                    case SpnValue::ClearStickyFault_TALONFX_FusedSensorOutOfSync: return "ClearStickyFault_TALONFX_FusedSensorOutOfSync";
                    case SpnValue::Fault_TALONFX_StatorCurrLimit: return "Fault_TALONFX_StatorCurrLimit";
                    case SpnValue::StickyFault_TALONFX_StatorCurrLimit: return "StickyFault_TALONFX_StatorCurrLimit";
                    case SpnValue::ClearStickyFault_TALONFX_StatorCurrLimit: return "ClearStickyFault_TALONFX_StatorCurrLimit";
                    case SpnValue::Fault_TALONFX_SupplyCurrLimit: return "Fault_TALONFX_SupplyCurrLimit";
                    case SpnValue::StickyFault_TALONFX_SupplyCurrLimit: return "StickyFault_TALONFX_SupplyCurrLimit";
                    case SpnValue::ClearStickyFault_TALONFX_SupplyCurrLimit: return "ClearStickyFault_TALONFX_SupplyCurrLimit";
                    case SpnValue::Fault_TALONFX_UsingFusedCCWhileUnlicensed: return "Fault_TALONFX_UsingFusedCCWhileUnlicensed";
                    case SpnValue::StickyFault_TALONFX_UsingFusedCCWhileUnlicensed: return "StickyFault_TALONFX_UsingFusedCCWhileUnlicensed";
                    case SpnValue::ClearStickyFault_TALONFX_UsingFusedCCWhileUnlicensed: return "ClearStickyFault_TALONFX_UsingFusedCCWhileUnlicensed";
                    case SpnValue::Fault_TALONFX_StaticBrakeDisabled: return "Fault_TALONFX_StaticBrakeDisabled";
                    case SpnValue::StickyFault_TALONFX_StaticBrakeDisabled: return "StickyFault_TALONFX_StaticBrakeDisabled";
                    case SpnValue::ClearStickyFault_TALONFX_StaticBrakeDisabled: return "ClearStickyFault_TALONFX_StaticBrakeDisabled";
                    default:
                        return "Invalid Value";
                    }
                }

                /**
                 * \brief Gets the API name for this enum
                 *
                 * \returns API name of this enum
                 */
                std::string GetName() const
                {
                    switch (value)
                    {
                    case SpnValue::TalonFX_System_State: return "System_State";
                    case SpnValue::Startup_ResetFlags: return "ResetFlags";
                    case SpnValue::Version_Major: return "VersionMajor";
                    case SpnValue::Version_Minor: return "VersionMinor";
                    case SpnValue::Version_Bugfix: return "VersionBugfix";
                    case SpnValue::Version_Build: return "VersionBuild";
                    case SpnValue::Version_Full: return "Version";
                    case SpnValue::Licensing_IsProLicensed: return "IsPROLicensed";
                    case SpnValue::Licensing_IsSeasonPassed: return "Licensing_IsSeasonPassed";
                    case SpnValue::CustomParam0: return "CustomParam0";
                    case SpnValue::CustomParam1: return "CustomParam1";
                    case SpnValue::CANcoder_SensorDirection: return "SensorDirection";
                    case SpnValue::FrcLock: return "FrcLock";
                    case SpnValue::RobotEnabled: return "RobotEnable";
                    case SpnValue::LED1_OnColor: return "Led1OnColor";
                    case SpnValue::LED1_OffColor: return "Led1OffColor";
                    case SpnValue::LED2_OnColor: return "Led2OnColor";
                    case SpnValue::LED2_OffColor: return "Led2OffColor";
                    case SpnValue::AllFaults: return "FaultField";
                    case SpnValue::AllStickyFaults: return "StickyFaultField";
                    case SpnValue::Pigeon2UseCompass: return "EnableCompass";
                    case SpnValue::Pigeon2DisableTemperatureCompensation: return "DisableTemperatureCompensation";
                    case SpnValue::Pigeon2DisableNoMotionCalibration: return "DisableNoMotionCalibration";
                    case SpnValue::Pigeon2MountPoseYaw: return "MountPoseYaw";
                    case SpnValue::Pigeon2MountPosePitch: return "MountPosePitch";
                    case SpnValue::Pigeon2MountPoseRoll: return "MountPoseRoll";
                    case SpnValue::Pigeon2GyroScalarX: return "GyroScalarX";
                    case SpnValue::Pigeon2GyroScalarY: return "GyroScalarY";
                    case SpnValue::Pigeon2GyroScalarZ: return "GyroScalarZ";
                    case SpnValue::Pigeon2Yaw: return "Yaw";
                    case SpnValue::Pigeon2Pitch: return "Pitch";
                    case SpnValue::Pigeon2Roll: return "Roll";
                    case SpnValue::Pigeon2QuatW: return "QuatW";
                    case SpnValue::Pigeon2QuatX: return "QuatX";
                    case SpnValue::Pigeon2QuatY: return "QuatY";
                    case SpnValue::Pigeon2QuatZ: return "QuatZ";
                    case SpnValue::Pigeon2GravityVectorX: return "GravityVectorX";
                    case SpnValue::Pigeon2GravityVectorY: return "GravityVectorY";
                    case SpnValue::Pigeon2GravityVectorZ: return "GravityVectorZ";
                    case SpnValue::Pigeon2Temperature: return "Temperature";
                    case SpnValue::Pigeon2NoMotionCalEnabled: return "NoMotionEnabled";
                    case SpnValue::Pigeon2NoMotionCount: return "NoMotionCount";
                    case SpnValue::Pigeon2TempCompDisabled: return "TemperatureCompensationDisabled";
                    case SpnValue::Pigeon2UpTime: return "UpTime";
                    case SpnValue::Pigeon2AccumGyroX: return "AccumGyroX";
                    case SpnValue::Pigeon2AccumGyroY: return "AccumGyroY";
                    case SpnValue::Pigeon2AccumGyroZ: return "AccumGyroZ";
                    case SpnValue::Pigeon2AngularVelocityXWorld: return "AngularVelocityXWorld";
                    case SpnValue::Pigeon2AngularVelocityYWorld: return "AngularVelocityYWorld";
                    case SpnValue::Pigeon2AngularVelocityZWorld: return "AngularVelocityZWorld";
                    case SpnValue::Pigeon2AccelerationX: return "AccelerationX";
                    case SpnValue::Pigeon2AccelerationY: return "AccelerationY";
                    case SpnValue::Pigeon2AccelerationZ: return "AccelerationZ";
                    case SpnValue::Pigeon2_SupplyVoltage: return "SupplyVoltage";
                    case SpnValue::Pigeon2AngularVelocityX: return "AngularVelocityXDevice";
                    case SpnValue::Pigeon2AngularVelocityY: return "AngularVelocityYDevice";
                    case SpnValue::Pigeon2AngularVelocityZ: return "AngularVelocityZDevice";
                    case SpnValue::Pigeon2MagneticFieldX: return "MagneticFieldX";
                    case SpnValue::Pigeon2MagneticFieldY: return "MagneticFieldY";
                    case SpnValue::Pigeon2MagneticFieldZ: return "MagneticFieldZ";
                    case SpnValue::Pigeon2RawMagneticFieldX: return "RawMagneticFieldX";
                    case SpnValue::Pigeon2RawMagneticFieldY: return "RawMagneticFieldY";
                    case SpnValue::Pigeon2RawMagneticFieldZ: return "RawMagneticFieldZ";
                    case SpnValue::CANCoder_MagnetOffset: return "MagnetOffset";
                    case SpnValue::TalonFX_SetSensorPosition: return "SetPosition";
                    case SpnValue::CANcoder_SetSensorPosition: return "SetPosition";
                    case SpnValue::Pigeon2_SetYaw: return "SetYaw";
                    case SpnValue::DeviceEnabled: return "DeviceEnable";
                    case SpnValue::PRO_MotorOutput_MotorVoltage: return "MotorVoltage";
                    case SpnValue::ForwardLimit: return "ForwardLimit";
                    case SpnValue::ReverseLimit: return "ReverseLimit";
                    case SpnValue::PRO_MotorOutput_RotorPolarity: return "AppliedRotorPolarity";
                    case SpnValue::PRO_MotorOutput_DutyCycle: return "DutyCycle";
                    case SpnValue::PRO_MotorOutput_TorqueCurrent: return "TorqueCurrent";
                    case SpnValue::PRO_SupplyAndTemp_StatorCurrent: return "StatorCurrent";
                    case SpnValue::PRO_SupplyAndTemp_SupplyCurrent: return "SupplyCurrent";
                    case SpnValue::PRO_SupplyAndTemp_SupplyVoltage: return "SupplyVoltage";
                    case SpnValue::PRO_SupplyAndTemp_DeviceTemp: return "DeviceTemp";
                    case SpnValue::PRO_SupplyAndTemp_ProcessorTemp: return "ProcessorTemp";
                    case SpnValue::PRO_RotorPosAndVel_Velocity: return "RotorVelocity";
                    case SpnValue::PRO_RotorPosAndVel_Position: return "RotorPosition";
                    case SpnValue::PRO_PosAndVel_Velocity: return "Velocity";
                    case SpnValue::PRO_PosAndVel_Position: return "Position";
                    case SpnValue::PRO_PosAndVel_Acceleration: return "Acceleration";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_DC: return "PIDDutyCycle_IntegratedAccum";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_V: return "PIDMotorVoltage_IntegratedAccum";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_A: return "PIDTorqueCurrent_IntegratedAccum";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_DC: return "PIDDutyCycle_FeedForward";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_V: return "PIDMotorVoltage_FeedForward";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_A: return "PIDTorqueCurrent_FeedForward";
                    case SpnValue::TalonFX_ControlMode: return "ControlMode";
                    case SpnValue::PRO_PIDStateEnables_IsMotionMagicRunning: return "MotionMagicIsRunning";
                    case SpnValue::PRO_PIDStateEnables_DeviceEnable: return "DeviceEnable";
                    case SpnValue::PRO_PIDRefPIDErr_PIDRef_Position: return "PIDPosition_Reference";
                    case SpnValue::PRO_PIDRefPIDErr_PIDRef_Velocity: return "PIDVelocity_Reference";
                    case SpnValue::PRO_PIDRefPIDErr_PIDErr_Position: return "PIDPosition_ClosedLoopError";
                    case SpnValue::PRO_PIDRefPIDErr_PIDErr_Velocity: return "PIDVelocity_ClosedLoopError";
                    case SpnValue::PRO_PIDRefPIDErr_ClosedLoopMode: return "PIDRefPIDErr_ClosedLoopMode";
                    case SpnValue::PRO_PIDOutput_PIDOutputMode: return "PIDOutput_PIDOutputMode";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_DC: return "PIDDutyCycle_ProportionalOutput";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_V: return "PIDMotorVoltage_ProportionalOutput";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_A: return "PIDTorqueCurrent_ProportionalOutput";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_DC: return "PIDDutyCycle_DerivativeOutput";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_V: return "PIDMotorVoltage_DerivativeOutput";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_A: return "PIDTorqueCurrent_DerivativeOutput";
                    case SpnValue::PRO_PIDOutput_Output_DC: return "PIDDutyCycle_Output";
                    case SpnValue::PRO_PIDOutput_Output_V: return "PIDMotorVoltage_Output";
                    case SpnValue::PRO_PIDOutput_Output_A: return "PIDTorqueCurrent_Output";
                    case SpnValue::PRO_PIDOutput_Slot: return "ClosedLoopSlot";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ReferenceSlope_Position: return "PIDPosition_ReferenceSlope";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ReferenceSlope_Velocity: return "PIDVelocity_ReferenceSlope";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ClosedLoopMode: return "PIDRefSlopeECUTime_ClosedLoopMode";
                    case SpnValue::TalonFX_MotorOutputStatus: return "MotorOutputStatus";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_DutyCycle: return "DifferentialDutyCycle";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_TorqueCurrent: return "DifferentialTorqueCurrent";
                    case SpnValue::TalonFX_DifferentialControlMode: return "DifferentialControlMode";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_DC: return "Differential_PIDDutyCycle_IntegratedAccum";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_V: return "Differential_PIDMotorVoltage_IntegratedAccum";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_A: return "Differential_PIDTorqueCurrent_IntegratedAccum";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_DC: return "Differential_PIDDutyCycle_FeedForward";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_V: return "Differential_PIDMotorVoltage_FeedForward";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_A: return "Differential_PIDTorqueCurrent_FeedForward";
                    case SpnValue::PRO_AvgPosAndVel_Velocity: return "DifferentialAverageVelocity";
                    case SpnValue::PRO_AvgPosAndVel_Position: return "DifferentialAveragePosition";
                    case SpnValue::PRO_DiffPosAndVel_Velocity: return "DifferentialDifferenceVelocity";
                    case SpnValue::PRO_DiffPosAndVel_Position: return "DifferentialDifferencePosition";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDRef_Position: return "Differential_PIDPosition_Reference";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDRef_Velocity: return "Differential_PIDVelocity_Reference";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDErr_Position: return "Differential_PIDPosition_ClosedLoopError";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDErr_Velocity: return "Differential_PIDVelocity_ClosedLoopError";
                    case SpnValue::PRO_DiffPIDRefPIDErr_ClosedLoopMode: return "DiffPIDRefPIDErr_ClosedLoopMode";
                    case SpnValue::PRO_DiffPIDOutput_PIDOutputMode: return "DiffPIDOutput_PIDOutputMode";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_DC: return "Differential_PIDDutyCycle_ProportionalOutput";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_V: return "Differential_PIDMotorVoltage_ProportionalOutput";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_A: return "Differential_PIDTorqueCurrent_ProportionalOutput";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_DC: return "Differential_PIDDutyCycle_DerivativeOutput";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_V: return "DiffPIDMotorVoltage_DerivativeOutput";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_A: return "Differential_PIDTorqueCurrent_DerivativeOutput";
                    case SpnValue::PRO_DiffPIDOutput_Output_DC: return "Differential_PIDDutyCycle_Output";
                    case SpnValue::PRO_DiffPIDOutput_Output_V: return "Differential_PIDMotorVoltage_Output";
                    case SpnValue::PRO_DiffPIDOutput_Output_A: return "Differential_PIDTorqueCurrent_Output";
                    case SpnValue::PRO_DiffPIDOutput_Slot: return "DifferentialClosedLoopSlot";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Position: return "Differential_PIDPosition_ReferenceSlope";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Velocity: return "Differential_PIDVelocity_ReferenceSlope";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ClosedLoopMode: return "DiffPIDRefSlopeECUTime_ClosedLoopMode";
                    case SpnValue::TalonFX_MotorConstants_kT: return "MotorKT";
                    case SpnValue::TalonFX_MotorConstants_kV: return "MotorKV";
                    case SpnValue::TalonFX_MotorConstants_StallCurrent: return "MotorStallCurrent";
                    case SpnValue::Slot0_kP: return "kP";
                    case SpnValue::Slot0_kI: return "kI";
                    case SpnValue::Slot0_kD: return "kD";
                    case SpnValue::Slot0_kS: return "kS";
                    case SpnValue::Slot0_kV: return "kV";
                    case SpnValue::Slot0_kA: return "kA";
                    case SpnValue::Slot0_kG: return "kG";
                    case SpnValue::Slot0_kG_Type: return "GravityType";
                    case SpnValue::Slot1_kP: return "kP";
                    case SpnValue::Slot1_kI: return "kI";
                    case SpnValue::Slot1_kD: return "kD";
                    case SpnValue::Slot1_kS: return "kS";
                    case SpnValue::Slot1_kV: return "kV";
                    case SpnValue::Slot1_kA: return "kA";
                    case SpnValue::Slot1_kG: return "kG";
                    case SpnValue::Slot1_kG_Type: return "GravityType";
                    case SpnValue::Slot2_kP: return "kP";
                    case SpnValue::Slot2_kI: return "kI";
                    case SpnValue::Slot2_kD: return "kD";
                    case SpnValue::Slot2_kS: return "kS";
                    case SpnValue::Slot2_kV: return "kV";
                    case SpnValue::Slot2_kA: return "kA";
                    case SpnValue::Slot2_kG: return "kG";
                    case SpnValue::Slot2_kG_Type: return "GravityType";
                    case SpnValue::Config_Inverted: return "Inverted";
                    case SpnValue::Config_SupplyVLowpassTau: return "SupplyVoltageTimeConstant";
                    case SpnValue::Config_BeepOnBoot: return "BeepOnBoot";
                    case SpnValue::Config_NeutralMode: return "NeutralMode";
                    case SpnValue::Config_DutyCycleNeutralDB: return "DutyCycleNeutralDeadband";
                    case SpnValue::Config_StatorCurrentLimit: return "StatorCurrentLimit";
                    case SpnValue::Config_StatorCurrLimitEn: return "StatorCurrentLimitEnable";
                    case SpnValue::Config_SupplyCurrentLimit: return "SupplyCurrentLimit";
                    case SpnValue::Config_SupplyCurrLimitEn: return "SupplyCurrentLimitEnable";
                    case SpnValue::Config_PeakForwardDC: return "PeakForwardDutyCycle";
                    case SpnValue::Config_PeakReverseDC: return "PeakReverseDutyCycle";
                    case SpnValue::Config_PeakForwardV: return "PeakForwardVoltage";
                    case SpnValue::Config_PeakReverseV: return "PeakReverseVoltage";
                    case SpnValue::Config_PeakForTorqCurr: return "PeakForwardTorqueCurrent";
                    case SpnValue::Config_PeakRevTorqCurr: return "PeakReverseTorqueCurrent";
                    case SpnValue::Config_TorqueNeutralDB: return "TorqueNeutralDeadband";
                    case SpnValue::Config_FeedbackRotorOffset: return "FeedbackRotorOffset";
                    case SpnValue::Config_SensorToMechanismRatio: return "SensorToMechanismRatio";
                    case SpnValue::Config_RotorToSensorRatio: return "RotorToSensorRatio";
                    case SpnValue::Config_FeedbackSensorSource: return "FeedbackSensorSource";
                    case SpnValue::Config_FeedbackRemoteSensorID: return "FeedbackRemoteSensorID";
                    case SpnValue::Config_DutyCycleOpenLoopRampPeriod: return "DutyCycleOpenLoopRampPeriod";
                    case SpnValue::Config_VoltageOpenLoopRampPeriod: return "VoltageOpenLoopRampPeriod";
                    case SpnValue::Config_TorqueOpenLoopRampPeriod: return "TorqueOpenLoopRampPeriod";
                    case SpnValue::Config_DutyCycleClosedLoopRampPeriod: return "DutyCycleClosedLoopRampPeriod";
                    case SpnValue::Config_VoltageClosedLoopRampPeriod: return "VoltageClosedLoopRampPeriod";
                    case SpnValue::Config_TorqueClosedLoopRampPeriod: return "TorqueClosedLoopRampPeriod";
                    case SpnValue::Config_ForwardLimitType: return "ForwardLimitType";
                    case SpnValue::Config_ForwardLimitAutosetPosEnable: return "ForwardLimitAutosetPositionEnable";
                    case SpnValue::Config_ForwardLimitAutosetPosValue: return "ForwardLimitAutosetPositionValue";
                    case SpnValue::Config_ForwardLimitEnable: return "ForwardLimitEnable";
                    case SpnValue::Config_ForwardLimitSource: return "ForwardLimitSource";
                    case SpnValue::Config_ForwardLimitRemoteSensorID: return "ForwardLimitRemoteSensorID";
                    case SpnValue::Config_ReverseLimitType: return "ReverseLimitType";
                    case SpnValue::Config_ReverseLimitAutosetPosEnable: return "ReverseLimitAutosetPositionEnable";
                    case SpnValue::Config_ReverseLimitAutosetPosValue: return "ReverseLimitAutosetPositionValue";
                    case SpnValue::Config_ReverseLimitEnable: return "ReverseLimitEnable";
                    case SpnValue::Config_ReverseLimitSource: return "ReverseLimitSource";
                    case SpnValue::Config_ReverseLimitRemoteSensorID: return "ReverseLimitRemoteSensorID";
                    case SpnValue::Config_ForwardSoftLimitEnable: return "ForwardSoftLimitEnable";
                    case SpnValue::Config_ReverseSoftLimitEnable: return "ReverseSoftLimitEnable";
                    case SpnValue::Config_ForwardSoftLimitThreshold: return "ForwardSoftLimitThreshold";
                    case SpnValue::Config_ReverseSoftLimitThreshold: return "ReverseSoftLimitThreshold";
                    case SpnValue::Config_MotionMagicCruiseVelocity: return "MotionMagicCruiseVelocity";
                    case SpnValue::Config_MotionMagicAcceleration: return "MotionMagicAcceleration";
                    case SpnValue::Config_MotionMagicJerk: return "MotionMagicJerk";
                    case SpnValue::Config_MotionMagicExpo_kV: return "MotionMagicExpo_kV";
                    case SpnValue::Config_MotionMagicExpo_kA: return "MotionMagicExpo_kA";
                    case SpnValue::Config_PeakDiffDC: return "PeakDifferentialDutyCycle";
                    case SpnValue::Config_PeakDiffV: return "PeakDifferentialVoltage";
                    case SpnValue::Config_PeakDiffTorqCurr: return "PeakDifferentialTorqueCurrent";
                    case SpnValue::CANcoder_Velocity: return "Velocity";
                    case SpnValue::CANcoder_Position: return "Position";
                    case SpnValue::CANcoder_AbsPosition: return "AbsolutePosition";
                    case SpnValue::CANCoder_RawVel: return "UnfilteredVelocity";
                    case SpnValue::CANCoder_RawPos: return "PositionSinceBoot";
                    case SpnValue::CANCoder_SupplyVoltage: return "SupplyVoltage";
                    case SpnValue::CANcoder_MagHealth: return "MagnetHealth";
                    case SpnValue::SPN_ClearStickyFaults: return "ClearStickyFaults";
                    case SpnValue::PRO_MotorOutput_BridgeType_Public: return "BridgeOutput";
                    case SpnValue::Config_ContinuousWrap: return "ContinuousWrap";
                    case SpnValue::Config_SupplyCurrentLowerLimit: return "SupplyCurrentLowerLimit";
                    case SpnValue::Config_SupplyCurrentLowerTime: return "SupplyCurrentLowerTime";
                    case SpnValue::Config_DifferentialSensorSource: return "DifferentialSensorSource";
                    case SpnValue::Config_DifferentialTalonFXSensorID: return "DifferentialTalonFXSensorID";
                    case SpnValue::Config_DifferentialRemoteSensorID: return "DifferentialRemoteSensorID";
                    case SpnValue::Config_BeepOnConfig: return "BeepOnConfig";
                    case SpnValue::Config_AllowMusicDurDisable: return "AllowMusicDurDisable";
                    case SpnValue::Compliancy_Version: return "Compliancy";
                    case SpnValue::Version_IsProLicensed: return "IsProLicensed";
                    case SpnValue::PRO_SupplyAndTemp_DeviceTemp2: return "AncillaryDeviceTemp";
                    case SpnValue::Slot0_kS_Sign: return "StaticFeedforwardSign";
                    case SpnValue::Slot1_kS_Sign: return "StaticFeedforwardSign";
                    case SpnValue::Slot2_kS_Sign: return "StaticFeedforwardSign";
                    case SpnValue::TalonFX_ConnectedMotor: return "ConnectedMotor";
                    case SpnValue::CANrange_SupplyVoltage: return "SupplyVoltage";
                    case SpnValue::CANrange_Distance_Meters: return "Distance";
                    case SpnValue::CANrange_MeasTime: return "MeasurementTime";
                    case SpnValue::CANrange_SignalStrength: return "SignalStrength";
                    case SpnValue::CANrange_ProximityDetected: return "IsDetected";
                    case SpnValue::CANrange_MeasState: return "MeasurementHealth";
                    case SpnValue::CANrange_AmbientSignal: return "AmbientSignal";
                    case SpnValue::CANrange_DistanceStdDev: return "DistanceStdDev";
                    case SpnValue::CANrange_RealFOVCenterX: return "RealFOVCenterX";
                    case SpnValue::CANrange_RealFOVCenterY: return "RealFOVCenterY";
                    case SpnValue::CANrange_RealFOVRangeX: return "RealFOVRangeX";
                    case SpnValue::CANrange_RealFOVRangeY: return "RealFOVRangeY";
                    case SpnValue::CANrange_UpdateMode: return "UpdateMode";
                    case SpnValue::CANrange_UpdateFreq: return "UpdateFrequency";
                    case SpnValue::CANrange_ProximityThreshold: return "ProximityThreshold";
                    case SpnValue::CANrange_ProximityHysteresis: return "ProximityHysteresis";
                    case SpnValue::CANrange_MinSigStrengthForValidMeas: return "MinSignalStrengthForValidMeasurement";
                    case SpnValue::CANrange_FOVCenterX: return "FOVCenterX";
                    case SpnValue::CANrange_FOVCenterY: return "FOVCenterY";
                    case SpnValue::CANrange_FOVRangeX: return "FOVRangeX";
                    case SpnValue::CANrange_FOVRangeY: return "FOVRangeY";
                    case SpnValue::Config_ControlTimesyncFreq: return "ControlTimesyncFreqHz";
                    case SpnValue::Config_VelocityFilterTimeConstant: return "VelocityFilterTimeConstant";
                    case SpnValue::Config_AbsoluteSensorDiscontinuityPoint: return "AbsoluteSensorDiscontinuityPoint";
                    case SpnValue::Fault_Hardware: return "Fault_Hardware";
                    case SpnValue::StickyFault_Hardware: return "StickyFault_Hardware";
                    case SpnValue::ClearStickyFault_Hardware: return "ClearStickyFault_Hardware";
                    case SpnValue::Fault_ProcTemp: return "Fault_ProcTemp";
                    case SpnValue::StickyFault_ProcTemp: return "StickyFault_ProcTemp";
                    case SpnValue::ClearStickyFault_ProcTemp: return "ClearStickyFault_ProcTemp";
                    case SpnValue::Fault_DeviceTemp: return "Fault_DeviceTemp";
                    case SpnValue::StickyFault_DeviceTemp: return "StickyFault_DeviceTemp";
                    case SpnValue::ClearStickyFault_DeviceTemp: return "ClearStickyFault_DeviceTemp";
                    case SpnValue::Fault_Undervoltage: return "Fault_Undervoltage";
                    case SpnValue::StickyFault_Undervoltage: return "StickyFault_Undervoltage";
                    case SpnValue::ClearStickyFault_Undervoltage: return "ClearStickyFault_Undervoltage";
                    case SpnValue::Fault_BootDuringEnable: return "Fault_BootDuringEnable";
                    case SpnValue::StickyFault_BootDuringEnable: return "StickyFault_BootDuringEnable";
                    case SpnValue::ClearStickyFault_BootDuringEnable: return "ClearStickyFault_BootDuringEnable";
                    case SpnValue::Fault_UnlicensedFeatureInUse: return "Fault_UnlicensedFeatureInUse";
                    case SpnValue::StickyFault_UnlicensedFeatureInUse: return "StickyFault_UnlicensedFeatureInUse";
                    case SpnValue::ClearStickyFault_UnlicensedFeatureInUse: return "ClearStickyFault_UnlicensedFeatureInUse";
                    case SpnValue::Fault_PIGEON2_BootupAccel: return "Fault_BootupAccelerometer";
                    case SpnValue::StickyFault_PIGEON2_BootupAccel: return "StickyFault_BootupAccelerometer";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupAccel: return "ClearStickyFault_BootupAccelerometer";
                    case SpnValue::Fault_PIGEON2_BootupGyros: return "Fault_BootupGyroscope";
                    case SpnValue::StickyFault_PIGEON2_BootupGyros: return "StickyFault_BootupGyroscope";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupGyros: return "ClearStickyFault_BootupGyroscope";
                    case SpnValue::Fault_PIGEON2_BootupMagne: return "Fault_BootupMagnetometer";
                    case SpnValue::StickyFault_PIGEON2_BootupMagne: return "StickyFault_BootupMagnetometer";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupMagne: return "ClearStickyFault_BootupMagnetometer";
                    case SpnValue::Fault_PIGEON2_BootIntoMotion: return "Fault_BootIntoMotion";
                    case SpnValue::StickyFault_PIGEON2_BootIntoMotion: return "StickyFault_BootIntoMotion";
                    case SpnValue::ClearStickyFault_PIGEON2_BootIntoMotion: return "ClearStickyFault_BootIntoMotion";
                    case SpnValue::Fault_PIGEON2_DataAcquiredLate: return "Fault_DataAcquiredLate";
                    case SpnValue::StickyFault_PIGEON2_DataAcquiredLate: return "StickyFault_DataAcquiredLate";
                    case SpnValue::ClearStickyFault_PIGEON2_DataAcquiredLate: return "ClearStickyFault_DataAcquiredLate";
                    case SpnValue::Fault_PIGEON2_LoopTimeSlow: return "Fault_LoopTimeSlow";
                    case SpnValue::StickyFault_PIGEON2_LoopTimeSlow: return "StickyFault_LoopTimeSlow";
                    case SpnValue::ClearStickyFault_PIGEON2_LoopTimeSlow: return "ClearStickyFault_LoopTimeSlow";
                    case SpnValue::Fault_PIGEON2_SaturatedMagne: return "Fault_SaturatedMagnetometer";
                    case SpnValue::StickyFault_PIGEON2_SaturatedMagne: return "StickyFault_SaturatedMagnetometer";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedMagne: return "ClearStickyFault_SaturatedMagnetometer";
                    case SpnValue::Fault_PIGEON2_SaturatedAccel: return "Fault_SaturatedAccelerometer";
                    case SpnValue::StickyFault_PIGEON2_SaturatedAccel: return "StickyFault_SaturatedAccelerometer";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedAccel: return "ClearStickyFault_SaturatedAccelerometer";
                    case SpnValue::Fault_PIGEON2_SaturatedGyros: return "Fault_SaturatedGyroscope";
                    case SpnValue::StickyFault_PIGEON2_SaturatedGyros: return "StickyFault_SaturatedGyroscope";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedGyros: return "ClearStickyFault_SaturatedGyroscope";
                    case SpnValue::Fault_CANCODER_BadMagnet: return "Fault_BadMagnet";
                    case SpnValue::StickyFault_CANCODER_BadMagnet: return "StickyFault_BadMagnet";
                    case SpnValue::ClearStickyFault_CANCODER_BadMagnet: return "ClearStickyFault_BadMagnet";
                    case SpnValue::Fault_TALONFX_BridgeBrownout: return "Fault_BridgeBrownout";
                    case SpnValue::StickyFault_TALONFX_BridgeBrownout: return "StickyFault_BridgeBrownout";
                    case SpnValue::ClearStickyFault_TALONFX_BridgeBrownout: return "ClearStickyFault_BridgeBrownout";
                    case SpnValue::Fault_TALONFX_RemoteSensorReset: return "Fault_RemoteSensorReset";
                    case SpnValue::StickyFault_TALONFX_RemoteSensorReset: return "StickyFault_RemoteSensorReset";
                    case SpnValue::ClearStickyFault_TALONFX_RemoteSensorReset: return "ClearStickyFault_RemoteSensorReset";
                    case SpnValue::Fault_TALONFX_MissingDifferentialFX: return "Fault_MissingDifferentialFX";
                    case SpnValue::StickyFault_TALONFX_MissingDifferentialFX: return "StickyFault_MissingDifferentialFX";
                    case SpnValue::ClearStickyFault_TALONFX_MissingDifferentialFX: return "ClearStickyFault_MissingDifferentialFX";
                    case SpnValue::Fault_TALONFX_RemoteSensorPosOverflow: return "Fault_RemoteSensorPosOverflow";
                    case SpnValue::StickyFault_TALONFX_RemoteSensorPosOverflow: return "StickyFault_RemoteSensorPosOverflow";
                    case SpnValue::ClearStickyFault_TALONFX_RemoteSensorPosOverflow: return "ClearStickyFault_RemoteSensorPosOverflow";
                    case SpnValue::Fault_TALONFX_OverSupplyV: return "Fault_OverSupplyV";
                    case SpnValue::StickyFault_TALONFX_OverSupplyV: return "StickyFault_OverSupplyV";
                    case SpnValue::ClearStickyFault_TALONFX_OverSupplyV: return "ClearStickyFault_OverSupplyV";
                    case SpnValue::Fault_TALONFX_UnstableSupplyV: return "Fault_UnstableSupplyV";
                    case SpnValue::StickyFault_TALONFX_UnstableSupplyV: return "StickyFault_UnstableSupplyV";
                    case SpnValue::ClearStickyFault_TALONFX_UnstableSupplyV: return "ClearStickyFault_UnstableSupplyV";
                    case SpnValue::Fault_TALONFX_ReverseHardLimit: return "Fault_ReverseHardLimit";
                    case SpnValue::StickyFault_TALONFX_ReverseHardLimit: return "StickyFault_ReverseHardLimit";
                    case SpnValue::ClearStickyFault_TALONFX_ReverseHardLimit: return "ClearStickyFault_ReverseHardLimit";
                    case SpnValue::Fault_TALONFX_ForwardHardLimit: return "Fault_ForwardHardLimit";
                    case SpnValue::StickyFault_TALONFX_ForwardHardLimit: return "StickyFault_ForwardHardLimit";
                    case SpnValue::ClearStickyFault_TALONFX_ForwardHardLimit: return "ClearStickyFault_ForwardHardLimit";
                    case SpnValue::Fault_TALONFX_ReverseSoftLimit: return "Fault_ReverseSoftLimit";
                    case SpnValue::StickyFault_TALONFX_ReverseSoftLimit: return "StickyFault_ReverseSoftLimit";
                    case SpnValue::ClearStickyFault_TALONFX_ReverseSoftLimit: return "ClearStickyFault_ReverseSoftLimit";
                    case SpnValue::Fault_TALONFX_ForwardSoftLimit: return "Fault_ForwardSoftLimit";
                    case SpnValue::StickyFault_TALONFX_ForwardSoftLimit: return "StickyFault_ForwardSoftLimit";
                    case SpnValue::ClearStickyFault_TALONFX_ForwardSoftLimit: return "ClearStickyFault_ForwardSoftLimit";
                    case SpnValue::Fault_TALONFX_MissingRemSoftLim: return "Fault_MissingSoftLimitRemote";
                    case SpnValue::StickyFault_TALONFX_MissingRemSoftLim: return "StickyFault_MissingSoftLimitRemote";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemSoftLim: return "ClearStickyFault_MissingSoftLimitRemote";
                    case SpnValue::Fault_TALONFX_MissingRemHardLim: return "Fault_MissingHardLimitRemote";
                    case SpnValue::StickyFault_TALONFX_MissingRemHardLim: return "StickyFault_MissingHardLimitRemote";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemHardLim: return "ClearStickyFault_MissingHardLimitRemote";
                    case SpnValue::Fault_TALONFX_MissingRemoteSensor: return "Fault_RemoteSensorDataInvalid";
                    case SpnValue::StickyFault_TALONFX_MissingRemoteSensor: return "StickyFault_RemoteSensorDataInvalid";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemoteSensor: return "ClearStickyFault_RemoteSensorDataInvalid";
                    case SpnValue::Fault_TALONFX_FusedSensorOutOfSync: return "Fault_FusedSensorOutOfSync";
                    case SpnValue::StickyFault_TALONFX_FusedSensorOutOfSync: return "StickyFault_FusedSensorOutOfSync";
                    case SpnValue::ClearStickyFault_TALONFX_FusedSensorOutOfSync: return "ClearStickyFault_FusedSensorOutOfSync";
                    case SpnValue::Fault_TALONFX_StatorCurrLimit: return "Fault_StatorCurrLimit";
                    case SpnValue::StickyFault_TALONFX_StatorCurrLimit: return "StickyFault_StatorCurrLimit";
                    case SpnValue::ClearStickyFault_TALONFX_StatorCurrLimit: return "ClearStickyFault_StatorCurrLimit";
                    case SpnValue::Fault_TALONFX_SupplyCurrLimit: return "Fault_SupplyCurrLimit";
                    case SpnValue::StickyFault_TALONFX_SupplyCurrLimit: return "StickyFault_SupplyCurrLimit";
                    case SpnValue::ClearStickyFault_TALONFX_SupplyCurrLimit: return "ClearStickyFault_SupplyCurrLimit";
                    case SpnValue::Fault_TALONFX_UsingFusedCCWhileUnlicensed: return "Fault_UsingFusedCANcoderWhileUnlicensed";
                    case SpnValue::StickyFault_TALONFX_UsingFusedCCWhileUnlicensed: return "StickyFault_UsingFusedCANcoderWhileUnlicensed";
                    case SpnValue::ClearStickyFault_TALONFX_UsingFusedCCWhileUnlicensed: return "ClearStickyFault_UsingFusedCANcoderWhileUnlicensed";
                    case SpnValue::Fault_TALONFX_StaticBrakeDisabled: return "Fault_StaticBrakeDisabled";
                    case SpnValue::StickyFault_TALONFX_StaticBrakeDisabled: return "StickyFault_StaticBrakeDisabled";
                    case SpnValue::ClearStickyFault_TALONFX_StaticBrakeDisabled: return "ClearStickyFault_StaticBrakeDisabled";
                    default:
                        return "Invalid Value";
                    }
                }

                /**
                 * \brief Gets the units for this enum if applicable
                 *
                 * \returns Units of this enum
                */
                std::string GetUnits() const
                {
                    switch (value)
                    {
                    case SpnValue::TalonFX_System_State: return "";
                    case SpnValue::Startup_ResetFlags: return "";
                    case SpnValue::Version_Major: return "";
                    case SpnValue::Version_Minor: return "";
                    case SpnValue::Version_Bugfix: return "";
                    case SpnValue::Version_Build: return "";
                    case SpnValue::Version_Full: return "";
                    case SpnValue::Licensing_IsProLicensed: return "";
                    case SpnValue::Licensing_IsSeasonPassed: return "";
                    case SpnValue::CustomParam0: return "";
                    case SpnValue::CustomParam1: return "";
                    case SpnValue::CANcoder_SensorDirection: return "";
                    case SpnValue::FrcLock: return "";
                    case SpnValue::RobotEnabled: return "";
                    case SpnValue::LED1_OnColor: return "";
                    case SpnValue::LED1_OffColor: return "";
                    case SpnValue::LED2_OnColor: return "";
                    case SpnValue::LED2_OffColor: return "";
                    case SpnValue::AllFaults: return "";
                    case SpnValue::AllStickyFaults: return "";
                    case SpnValue::Pigeon2UseCompass: return "";
                    case SpnValue::Pigeon2DisableTemperatureCompensation: return "";
                    case SpnValue::Pigeon2DisableNoMotionCalibration: return "";
                    case SpnValue::Pigeon2MountPoseYaw: return "deg";
                    case SpnValue::Pigeon2MountPosePitch: return "deg";
                    case SpnValue::Pigeon2MountPoseRoll: return "deg";
                    case SpnValue::Pigeon2GyroScalarX: return "deg per rotation";
                    case SpnValue::Pigeon2GyroScalarY: return "deg per rotation";
                    case SpnValue::Pigeon2GyroScalarZ: return "deg per rotation";
                    case SpnValue::Pigeon2Yaw: return "deg";
                    case SpnValue::Pigeon2Pitch: return "deg";
                    case SpnValue::Pigeon2Roll: return "deg";
                    case SpnValue::Pigeon2QuatW: return "";
                    case SpnValue::Pigeon2QuatX: return "";
                    case SpnValue::Pigeon2QuatY: return "";
                    case SpnValue::Pigeon2QuatZ: return "";
                    case SpnValue::Pigeon2GravityVectorX: return "";
                    case SpnValue::Pigeon2GravityVectorY: return "";
                    case SpnValue::Pigeon2GravityVectorZ: return "";
                    case SpnValue::Pigeon2Temperature: return "â";
                    case SpnValue::Pigeon2NoMotionCalEnabled: return "";
                    case SpnValue::Pigeon2NoMotionCount: return "";
                    case SpnValue::Pigeon2TempCompDisabled: return "";
                    case SpnValue::Pigeon2UpTime: return "s";
                    case SpnValue::Pigeon2AccumGyroX: return "deg";
                    case SpnValue::Pigeon2AccumGyroY: return "deg";
                    case SpnValue::Pigeon2AccumGyroZ: return "deg";
                    case SpnValue::Pigeon2AngularVelocityXWorld: return "dps";
                    case SpnValue::Pigeon2AngularVelocityYWorld: return "dps";
                    case SpnValue::Pigeon2AngularVelocityZWorld: return "dps";
                    case SpnValue::Pigeon2AccelerationX: return "g";
                    case SpnValue::Pigeon2AccelerationY: return "g";
                    case SpnValue::Pigeon2AccelerationZ: return "g";
                    case SpnValue::Pigeon2_SupplyVoltage: return "V";
                    case SpnValue::Pigeon2AngularVelocityX: return "dps";
                    case SpnValue::Pigeon2AngularVelocityY: return "dps";
                    case SpnValue::Pigeon2AngularVelocityZ: return "dps";
                    case SpnValue::Pigeon2MagneticFieldX: return "uT";
                    case SpnValue::Pigeon2MagneticFieldY: return "uT";
                    case SpnValue::Pigeon2MagneticFieldZ: return "uT";
                    case SpnValue::Pigeon2RawMagneticFieldX: return "uT";
                    case SpnValue::Pigeon2RawMagneticFieldY: return "uT";
                    case SpnValue::Pigeon2RawMagneticFieldZ: return "uT";
                    case SpnValue::CANCoder_MagnetOffset: return "rotations";
                    case SpnValue::TalonFX_SetSensorPosition: return "rotations";
                    case SpnValue::CANcoder_SetSensorPosition: return "rotations";
                    case SpnValue::Pigeon2_SetYaw: return "deg";
                    case SpnValue::DeviceEnabled: return "";
                    case SpnValue::PRO_MotorOutput_MotorVoltage: return "V";
                    case SpnValue::ForwardLimit: return "";
                    case SpnValue::ReverseLimit: return "";
                    case SpnValue::PRO_MotorOutput_RotorPolarity: return "";
                    case SpnValue::PRO_MotorOutput_DutyCycle: return "fractional";
                    case SpnValue::PRO_MotorOutput_TorqueCurrent: return "A";
                    case SpnValue::PRO_SupplyAndTemp_StatorCurrent: return "A";
                    case SpnValue::PRO_SupplyAndTemp_SupplyCurrent: return "A";
                    case SpnValue::PRO_SupplyAndTemp_SupplyVoltage: return "V";
                    case SpnValue::PRO_SupplyAndTemp_DeviceTemp: return "â";
                    case SpnValue::PRO_SupplyAndTemp_ProcessorTemp: return "â";
                    case SpnValue::PRO_RotorPosAndVel_Velocity: return "rotations per second";
                    case SpnValue::PRO_RotorPosAndVel_Position: return "rotations";
                    case SpnValue::PRO_PosAndVel_Velocity: return "rotations per second";
                    case SpnValue::PRO_PosAndVel_Position: return "rotations";
                    case SpnValue::PRO_PosAndVel_Acceleration: return "rotations per secondÂ²";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_DC: return "fractional";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_V: return "V";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_A: return "A";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_DC: return "fractional";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_V: return "V";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_A: return "A";
                    case SpnValue::TalonFX_ControlMode: return "";
                    case SpnValue::PRO_PIDStateEnables_IsMotionMagicRunning: return "";
                    case SpnValue::PRO_PIDStateEnables_DeviceEnable: return "";
                    case SpnValue::PRO_PIDRefPIDErr_PIDRef_Position: return "rotations";
                    case SpnValue::PRO_PIDRefPIDErr_PIDRef_Velocity: return "rotations per second";
                    case SpnValue::PRO_PIDRefPIDErr_PIDErr_Position: return "rotations";
                    case SpnValue::PRO_PIDRefPIDErr_PIDErr_Velocity: return "rotations per second";
                    case SpnValue::PRO_PIDRefPIDErr_ClosedLoopMode: return "";
                    case SpnValue::PRO_PIDOutput_PIDOutputMode: return "";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_DC: return "fractional";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_V: return "V";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_A: return "A";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_DC: return "fractional";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_V: return "V";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_A: return "A";
                    case SpnValue::PRO_PIDOutput_Output_DC: return "fractional";
                    case SpnValue::PRO_PIDOutput_Output_V: return "V";
                    case SpnValue::PRO_PIDOutput_Output_A: return "A";
                    case SpnValue::PRO_PIDOutput_Slot: return "";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ReferenceSlope_Position: return "rotations per second";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ReferenceSlope_Velocity: return "rotations per secondÂ²";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ClosedLoopMode: return "";
                    case SpnValue::TalonFX_MotorOutputStatus: return "";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_DutyCycle: return "fractional";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_TorqueCurrent: return "A";
                    case SpnValue::TalonFX_DifferentialControlMode: return "";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_DC: return "fractional";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_V: return "V";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_A: return "A";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_DC: return "fractional";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_V: return "V";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_A: return "A";
                    case SpnValue::PRO_AvgPosAndVel_Velocity: return "rotations per second";
                    case SpnValue::PRO_AvgPosAndVel_Position: return "rotations";
                    case SpnValue::PRO_DiffPosAndVel_Velocity: return "rotations per second";
                    case SpnValue::PRO_DiffPosAndVel_Position: return "rotations";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDRef_Position: return "rotations";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDRef_Velocity: return "rotations per second";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDErr_Position: return "rotations";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDErr_Velocity: return "rotations per second";
                    case SpnValue::PRO_DiffPIDRefPIDErr_ClosedLoopMode: return "";
                    case SpnValue::PRO_DiffPIDOutput_PIDOutputMode: return "";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_DC: return "fractional";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_V: return "V";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_A: return "A";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_DC: return "fractional";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_V: return "V";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_A: return "A";
                    case SpnValue::PRO_DiffPIDOutput_Output_DC: return "fractional";
                    case SpnValue::PRO_DiffPIDOutput_Output_V: return "V";
                    case SpnValue::PRO_DiffPIDOutput_Output_A: return "A";
                    case SpnValue::PRO_DiffPIDOutput_Slot: return "";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Position: return "rotations per second";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Velocity: return "rotations per secondÂ²";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ClosedLoopMode: return "";
                    case SpnValue::TalonFX_MotorConstants_kT: return "Nm/A";
                    case SpnValue::TalonFX_MotorConstants_kV: return "RPM/V";
                    case SpnValue::TalonFX_MotorConstants_StallCurrent: return "A";
                    case SpnValue::Slot0_kP: return "";
                    case SpnValue::Slot0_kI: return "";
                    case SpnValue::Slot0_kD: return "";
                    case SpnValue::Slot0_kS: return "";
                    case SpnValue::Slot0_kV: return "";
                    case SpnValue::Slot0_kA: return "";
                    case SpnValue::Slot0_kG: return "";
                    case SpnValue::Slot0_kG_Type: return "";
                    case SpnValue::Slot1_kP: return "";
                    case SpnValue::Slot1_kI: return "";
                    case SpnValue::Slot1_kD: return "";
                    case SpnValue::Slot1_kS: return "";
                    case SpnValue::Slot1_kV: return "";
                    case SpnValue::Slot1_kA: return "";
                    case SpnValue::Slot1_kG: return "";
                    case SpnValue::Slot1_kG_Type: return "";
                    case SpnValue::Slot2_kP: return "";
                    case SpnValue::Slot2_kI: return "";
                    case SpnValue::Slot2_kD: return "";
                    case SpnValue::Slot2_kS: return "";
                    case SpnValue::Slot2_kV: return "";
                    case SpnValue::Slot2_kA: return "";
                    case SpnValue::Slot2_kG: return "";
                    case SpnValue::Slot2_kG_Type: return "";
                    case SpnValue::Config_Inverted: return "";
                    case SpnValue::Config_SupplyVLowpassTau: return "seconds";
                    case SpnValue::Config_BeepOnBoot: return "";
                    case SpnValue::Config_NeutralMode: return "";
                    case SpnValue::Config_DutyCycleNeutralDB: return "fractional";
                    case SpnValue::Config_StatorCurrentLimit: return "A";
                    case SpnValue::Config_StatorCurrLimitEn: return "";
                    case SpnValue::Config_SupplyCurrentLimit: return "A";
                    case SpnValue::Config_SupplyCurrLimitEn: return "";
                    case SpnValue::Config_PeakForwardDC: return "fractional";
                    case SpnValue::Config_PeakReverseDC: return "fractional";
                    case SpnValue::Config_PeakForwardV: return "V";
                    case SpnValue::Config_PeakReverseV: return "V";
                    case SpnValue::Config_PeakForTorqCurr: return "A";
                    case SpnValue::Config_PeakRevTorqCurr: return "A";
                    case SpnValue::Config_TorqueNeutralDB: return "A";
                    case SpnValue::Config_FeedbackRotorOffset: return "rotations";
                    case SpnValue::Config_SensorToMechanismRatio: return "scalar";
                    case SpnValue::Config_RotorToSensorRatio: return "scalar";
                    case SpnValue::Config_FeedbackSensorSource: return "";
                    case SpnValue::Config_FeedbackRemoteSensorID: return "";
                    case SpnValue::Config_DutyCycleOpenLoopRampPeriod: return "seconds";
                    case SpnValue::Config_VoltageOpenLoopRampPeriod: return "seconds";
                    case SpnValue::Config_TorqueOpenLoopRampPeriod: return "seconds";
                    case SpnValue::Config_DutyCycleClosedLoopRampPeriod: return "seconds";
                    case SpnValue::Config_VoltageClosedLoopRampPeriod: return "seconds";
                    case SpnValue::Config_TorqueClosedLoopRampPeriod: return "seconds";
                    case SpnValue::Config_ForwardLimitType: return "";
                    case SpnValue::Config_ForwardLimitAutosetPosEnable: return "";
                    case SpnValue::Config_ForwardLimitAutosetPosValue: return "rotations";
                    case SpnValue::Config_ForwardLimitEnable: return "";
                    case SpnValue::Config_ForwardLimitSource: return "";
                    case SpnValue::Config_ForwardLimitRemoteSensorID: return "";
                    case SpnValue::Config_ReverseLimitType: return "";
                    case SpnValue::Config_ReverseLimitAutosetPosEnable: return "";
                    case SpnValue::Config_ReverseLimitAutosetPosValue: return "rotations";
                    case SpnValue::Config_ReverseLimitEnable: return "";
                    case SpnValue::Config_ReverseLimitSource: return "";
                    case SpnValue::Config_ReverseLimitRemoteSensorID: return "";
                    case SpnValue::Config_ForwardSoftLimitEnable: return "";
                    case SpnValue::Config_ReverseSoftLimitEnable: return "";
                    case SpnValue::Config_ForwardSoftLimitThreshold: return "rotations";
                    case SpnValue::Config_ReverseSoftLimitThreshold: return "rotations";
                    case SpnValue::Config_MotionMagicCruiseVelocity: return "rot per sec";
                    case SpnValue::Config_MotionMagicAcceleration: return "rot per secÂ²";
                    case SpnValue::Config_MotionMagicJerk: return "rot per secÂ³";
                    case SpnValue::Config_MotionMagicExpo_kV: return "V/rps";
                    case SpnValue::Config_MotionMagicExpo_kA: return "V/rpsÂ²";
                    case SpnValue::Config_PeakDiffDC: return "fractional";
                    case SpnValue::Config_PeakDiffV: return "V";
                    case SpnValue::Config_PeakDiffTorqCurr: return "A";
                    case SpnValue::CANcoder_Velocity: return "rotations per second";
                    case SpnValue::CANcoder_Position: return "rotations";
                    case SpnValue::CANcoder_AbsPosition: return "rotations";
                    case SpnValue::CANCoder_RawVel: return "rotations per second";
                    case SpnValue::CANCoder_RawPos: return "rotations";
                    case SpnValue::CANCoder_SupplyVoltage: return "V";
                    case SpnValue::CANcoder_MagHealth: return "";
                    case SpnValue::SPN_ClearStickyFaults: return "";
                    case SpnValue::PRO_MotorOutput_BridgeType_Public: return "";
                    case SpnValue::Config_ContinuousWrap: return "";
                    case SpnValue::Config_SupplyCurrentLowerLimit: return "A";
                    case SpnValue::Config_SupplyCurrentLowerTime: return "seconds";
                    case SpnValue::Config_DifferentialSensorSource: return "";
                    case SpnValue::Config_DifferentialTalonFXSensorID: return "";
                    case SpnValue::Config_DifferentialRemoteSensorID: return "";
                    case SpnValue::Config_BeepOnConfig: return "";
                    case SpnValue::Config_AllowMusicDurDisable: return "";
                    case SpnValue::Compliancy_Version: return "";
                    case SpnValue::Version_IsProLicensed: return "";
                    case SpnValue::PRO_SupplyAndTemp_DeviceTemp2: return "â";
                    case SpnValue::Slot0_kS_Sign: return "";
                    case SpnValue::Slot1_kS_Sign: return "";
                    case SpnValue::Slot2_kS_Sign: return "";
                    case SpnValue::TalonFX_ConnectedMotor: return "";
                    case SpnValue::CANrange_SupplyVoltage: return "V";
                    case SpnValue::CANrange_Distance_Meters: return "m";
                    case SpnValue::CANrange_MeasTime: return "s";
                    case SpnValue::CANrange_SignalStrength: return "";
                    case SpnValue::CANrange_ProximityDetected: return "";
                    case SpnValue::CANrange_MeasState: return "";
                    case SpnValue::CANrange_AmbientSignal: return "";
                    case SpnValue::CANrange_DistanceStdDev: return "m";
                    case SpnValue::CANrange_RealFOVCenterX: return "deg";
                    case SpnValue::CANrange_RealFOVCenterY: return "deg";
                    case SpnValue::CANrange_RealFOVRangeX: return "deg";
                    case SpnValue::CANrange_RealFOVRangeY: return "deg";
                    case SpnValue::CANrange_UpdateMode: return "";
                    case SpnValue::CANrange_UpdateFreq: return "Hz";
                    case SpnValue::CANrange_ProximityThreshold: return "m";
                    case SpnValue::CANrange_ProximityHysteresis: return "m";
                    case SpnValue::CANrange_MinSigStrengthForValidMeas: return "";
                    case SpnValue::CANrange_FOVCenterX: return "deg";
                    case SpnValue::CANrange_FOVCenterY: return "deg";
                    case SpnValue::CANrange_FOVRangeX: return "deg";
                    case SpnValue::CANrange_FOVRangeY: return "deg";
                    case SpnValue::Config_ControlTimesyncFreq: return "Hz";
                    case SpnValue::Config_VelocityFilterTimeConstant: return "seconds";
                    case SpnValue::Config_AbsoluteSensorDiscontinuityPoint: return "rotations";
                    case SpnValue::Fault_Hardware: return "";
                    case SpnValue::StickyFault_Hardware: return "";
                    case SpnValue::ClearStickyFault_Hardware: return "";
                    case SpnValue::Fault_ProcTemp: return "";
                    case SpnValue::StickyFault_ProcTemp: return "";
                    case SpnValue::ClearStickyFault_ProcTemp: return "";
                    case SpnValue::Fault_DeviceTemp: return "";
                    case SpnValue::StickyFault_DeviceTemp: return "";
                    case SpnValue::ClearStickyFault_DeviceTemp: return "";
                    case SpnValue::Fault_Undervoltage: return "";
                    case SpnValue::StickyFault_Undervoltage: return "";
                    case SpnValue::ClearStickyFault_Undervoltage: return "";
                    case SpnValue::Fault_BootDuringEnable: return "";
                    case SpnValue::StickyFault_BootDuringEnable: return "";
                    case SpnValue::ClearStickyFault_BootDuringEnable: return "";
                    case SpnValue::Fault_UnlicensedFeatureInUse: return "";
                    case SpnValue::StickyFault_UnlicensedFeatureInUse: return "";
                    case SpnValue::ClearStickyFault_UnlicensedFeatureInUse: return "";
                    case SpnValue::Fault_PIGEON2_BootupAccel: return "";
                    case SpnValue::StickyFault_PIGEON2_BootupAccel: return "";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupAccel: return "";
                    case SpnValue::Fault_PIGEON2_BootupGyros: return "";
                    case SpnValue::StickyFault_PIGEON2_BootupGyros: return "";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupGyros: return "";
                    case SpnValue::Fault_PIGEON2_BootupMagne: return "";
                    case SpnValue::StickyFault_PIGEON2_BootupMagne: return "";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupMagne: return "";
                    case SpnValue::Fault_PIGEON2_BootIntoMotion: return "";
                    case SpnValue::StickyFault_PIGEON2_BootIntoMotion: return "";
                    case SpnValue::ClearStickyFault_PIGEON2_BootIntoMotion: return "";
                    case SpnValue::Fault_PIGEON2_DataAcquiredLate: return "";
                    case SpnValue::StickyFault_PIGEON2_DataAcquiredLate: return "";
                    case SpnValue::ClearStickyFault_PIGEON2_DataAcquiredLate: return "";
                    case SpnValue::Fault_PIGEON2_LoopTimeSlow: return "";
                    case SpnValue::StickyFault_PIGEON2_LoopTimeSlow: return "";
                    case SpnValue::ClearStickyFault_PIGEON2_LoopTimeSlow: return "";
                    case SpnValue::Fault_PIGEON2_SaturatedMagne: return "";
                    case SpnValue::StickyFault_PIGEON2_SaturatedMagne: return "";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedMagne: return "";
                    case SpnValue::Fault_PIGEON2_SaturatedAccel: return "";
                    case SpnValue::StickyFault_PIGEON2_SaturatedAccel: return "";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedAccel: return "";
                    case SpnValue::Fault_PIGEON2_SaturatedGyros: return "";
                    case SpnValue::StickyFault_PIGEON2_SaturatedGyros: return "";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedGyros: return "";
                    case SpnValue::Fault_CANCODER_BadMagnet: return "";
                    case SpnValue::StickyFault_CANCODER_BadMagnet: return "";
                    case SpnValue::ClearStickyFault_CANCODER_BadMagnet: return "";
                    case SpnValue::Fault_TALONFX_BridgeBrownout: return "";
                    case SpnValue::StickyFault_TALONFX_BridgeBrownout: return "";
                    case SpnValue::ClearStickyFault_TALONFX_BridgeBrownout: return "";
                    case SpnValue::Fault_TALONFX_RemoteSensorReset: return "";
                    case SpnValue::StickyFault_TALONFX_RemoteSensorReset: return "";
                    case SpnValue::ClearStickyFault_TALONFX_RemoteSensorReset: return "";
                    case SpnValue::Fault_TALONFX_MissingDifferentialFX: return "";
                    case SpnValue::StickyFault_TALONFX_MissingDifferentialFX: return "";
                    case SpnValue::ClearStickyFault_TALONFX_MissingDifferentialFX: return "";
                    case SpnValue::Fault_TALONFX_RemoteSensorPosOverflow: return "";
                    case SpnValue::StickyFault_TALONFX_RemoteSensorPosOverflow: return "";
                    case SpnValue::ClearStickyFault_TALONFX_RemoteSensorPosOverflow: return "";
                    case SpnValue::Fault_TALONFX_OverSupplyV: return "";
                    case SpnValue::StickyFault_TALONFX_OverSupplyV: return "";
                    case SpnValue::ClearStickyFault_TALONFX_OverSupplyV: return "";
                    case SpnValue::Fault_TALONFX_UnstableSupplyV: return "";
                    case SpnValue::StickyFault_TALONFX_UnstableSupplyV: return "";
                    case SpnValue::ClearStickyFault_TALONFX_UnstableSupplyV: return "";
                    case SpnValue::Fault_TALONFX_ReverseHardLimit: return "";
                    case SpnValue::StickyFault_TALONFX_ReverseHardLimit: return "";
                    case SpnValue::ClearStickyFault_TALONFX_ReverseHardLimit: return "";
                    case SpnValue::Fault_TALONFX_ForwardHardLimit: return "";
                    case SpnValue::StickyFault_TALONFX_ForwardHardLimit: return "";
                    case SpnValue::ClearStickyFault_TALONFX_ForwardHardLimit: return "";
                    case SpnValue::Fault_TALONFX_ReverseSoftLimit: return "";
                    case SpnValue::StickyFault_TALONFX_ReverseSoftLimit: return "";
                    case SpnValue::ClearStickyFault_TALONFX_ReverseSoftLimit: return "";
                    case SpnValue::Fault_TALONFX_ForwardSoftLimit: return "";
                    case SpnValue::StickyFault_TALONFX_ForwardSoftLimit: return "";
                    case SpnValue::ClearStickyFault_TALONFX_ForwardSoftLimit: return "";
                    case SpnValue::Fault_TALONFX_MissingRemSoftLim: return "";
                    case SpnValue::StickyFault_TALONFX_MissingRemSoftLim: return "";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemSoftLim: return "";
                    case SpnValue::Fault_TALONFX_MissingRemHardLim: return "";
                    case SpnValue::StickyFault_TALONFX_MissingRemHardLim: return "";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemHardLim: return "";
                    case SpnValue::Fault_TALONFX_MissingRemoteSensor: return "";
                    case SpnValue::StickyFault_TALONFX_MissingRemoteSensor: return "";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemoteSensor: return "";
                    case SpnValue::Fault_TALONFX_FusedSensorOutOfSync: return "";
                    case SpnValue::StickyFault_TALONFX_FusedSensorOutOfSync: return "";
                    case SpnValue::ClearStickyFault_TALONFX_FusedSensorOutOfSync: return "";
                    case SpnValue::Fault_TALONFX_StatorCurrLimit: return "";
                    case SpnValue::StickyFault_TALONFX_StatorCurrLimit: return "";
                    case SpnValue::ClearStickyFault_TALONFX_StatorCurrLimit: return "";
                    case SpnValue::Fault_TALONFX_SupplyCurrLimit: return "";
                    case SpnValue::StickyFault_TALONFX_SupplyCurrLimit: return "";
                    case SpnValue::ClearStickyFault_TALONFX_SupplyCurrLimit: return "";
                    case SpnValue::Fault_TALONFX_UsingFusedCCWhileUnlicensed: return "";
                    case SpnValue::StickyFault_TALONFX_UsingFusedCCWhileUnlicensed: return "";
                    case SpnValue::ClearStickyFault_TALONFX_UsingFusedCCWhileUnlicensed: return "";
                    case SpnValue::Fault_TALONFX_StaticBrakeDisabled: return "";
                    case SpnValue::StickyFault_TALONFX_StaticBrakeDisabled: return "";
                    case SpnValue::ClearStickyFault_TALONFX_StaticBrakeDisabled: return "";
                    default:
                        return "Invalid Value";
                    }
                }

                /**
                 * \brief Gets the summary for this enum if applicable
                 *
                 * \returns Summary of this enum
                */
                std::string GetSummary() const
                {
                    switch (value)
                    {
                    case SpnValue::TalonFX_System_State: return "System state of the device.";
                    case SpnValue::Startup_ResetFlags: return "This signal needs a summary";
                    case SpnValue::Version_Major: return "App Major Version number.";
                    case SpnValue::Version_Minor: return "App Minor Version number.";
                    case SpnValue::Version_Bugfix: return "App Bugfix Version number.";
                    case SpnValue::Version_Build: return "App Build Version number.";
                    case SpnValue::Version_Full: return "Full Version of firmware in device.  The format is a four byte value.";
                    case SpnValue::Licensing_IsProLicensed: return "Whether the device is Pro licensed.";
                    case SpnValue::Licensing_IsSeasonPassed: return "Whether the device is Season Pass licensed.";
                    case SpnValue::CustomParam0: return "Custom parameter 0.  This is provided to allow end-applications to store persistent information in the device.";
                    case SpnValue::CustomParam1: return "Custom parameter 1.  This is provided to allow end-applications to store persistent information in the device.";
                    case SpnValue::CANcoder_SensorDirection: return "Direction of the sensor to determine positive rotation, as seen facing the LED side of the CANcoder.";
                    case SpnValue::FrcLock: return "Whether device is locked by FRC.";
                    case SpnValue::RobotEnabled: return "Whether the robot is enabled.";
                    case SpnValue::LED1_OnColor: return "The Color of LED1 when it's \"On\".";
                    case SpnValue::LED1_OffColor: return "The Color of LED1 when it's \"Off\".";
                    case SpnValue::LED2_OnColor: return "The Color of LED2 when it's \"On\".";
                    case SpnValue::LED2_OffColor: return "The Color of LED2 when it's \"Off\".";
                    case SpnValue::AllFaults: return "Integer representing all fault flags reported by the device.";
                    case SpnValue::AllStickyFaults: return "Integer representing all (persistent) sticky fault flags reported by the device.";
                    case SpnValue::Pigeon2UseCompass: return "Turns on or off the magnetometer fusing for 9-axis. FRC users are not recommended to turn this on, as the magnetic influence of the robot will likely negatively affect the performance of the Pigeon2.";
                    case SpnValue::Pigeon2DisableTemperatureCompensation: return "Disables using the temperature compensation feature.";
                    case SpnValue::Pigeon2DisableNoMotionCalibration: return "Disables using the no-motion calibration feature.";
                    case SpnValue::Pigeon2MountPoseYaw: return "The mounting calibration yaw-component.";
                    case SpnValue::Pigeon2MountPosePitch: return "The mounting calibration pitch-component.";
                    case SpnValue::Pigeon2MountPoseRoll: return "The mounting calibration roll-component.";
                    case SpnValue::Pigeon2GyroScalarX: return "The gyro scalar component for the X axis.";
                    case SpnValue::Pigeon2GyroScalarY: return "The gyro scalar component for the Y axis.";
                    case SpnValue::Pigeon2GyroScalarZ: return "The gyro scalar component for the Z axis.";
                    case SpnValue::Pigeon2Yaw: return "Current reported yaw of the Pigeon2.";
                    case SpnValue::Pigeon2Pitch: return "Current reported pitch of the Pigeon2.";
                    case SpnValue::Pigeon2Roll: return "Current reported roll of the Pigeon2.";
                    case SpnValue::Pigeon2QuatW: return "The W component of the reported Quaternion.";
                    case SpnValue::Pigeon2QuatX: return "The X component of the reported Quaternion.";
                    case SpnValue::Pigeon2QuatY: return "The Y component of the reported Quaternion.";
                    case SpnValue::Pigeon2QuatZ: return "The Z component of the reported Quaternion.";
                    case SpnValue::Pigeon2GravityVectorX: return "The X component of the gravity vector.";
                    case SpnValue::Pigeon2GravityVectorY: return "The Y component of the gravity vector.";
                    case SpnValue::Pigeon2GravityVectorZ: return "The Z component of the gravity vector.";
                    case SpnValue::Pigeon2Temperature: return "Temperature of the Pigeon 2.";
                    case SpnValue::Pigeon2NoMotionCalEnabled: return "Whether the no-motion calibration feature is enabled.";
                    case SpnValue::Pigeon2NoMotionCount: return "The number of times a no-motion event occurred, wraps at 15.";
                    case SpnValue::Pigeon2TempCompDisabled: return "Whether the temperature-compensation feature is disabled.";
                    case SpnValue::Pigeon2UpTime: return "How long the Pigeon 2's been up in seconds, caps at 255 seconds.";
                    case SpnValue::Pigeon2AccumGyroX: return "The accumulated gyro about the X axis without any sensor fusing.";
                    case SpnValue::Pigeon2AccumGyroY: return "The accumulated gyro about the Y axis without any sensor fusing.";
                    case SpnValue::Pigeon2AccumGyroZ: return "The accumulated gyro about the Z axis without any sensor fusing.";
                    case SpnValue::Pigeon2AngularVelocityXWorld: return "The angular velocity (Ï) of the Pigeon 2 about the X axis with respect to the world frame.  This value is mount-calibrated.";
                    case SpnValue::Pigeon2AngularVelocityYWorld: return "The angular velocity (Ï) of the Pigeon 2 about the Y axis with respect to the world frame.  This value is mount-calibrated.";
                    case SpnValue::Pigeon2AngularVelocityZWorld: return "The angular velocity (Ï) of the Pigeon 2 about the Z axis with respect to the world frame.  This value is mount-calibrated.";
                    case SpnValue::Pigeon2AccelerationX: return "The acceleration measured by Pigeon2 in the X direction.";
                    case SpnValue::Pigeon2AccelerationY: return "The acceleration measured by Pigeon2 in the Y direction.";
                    case SpnValue::Pigeon2AccelerationZ: return "The acceleration measured by Pigeon2 in the Z direction.";
                    case SpnValue::Pigeon2_SupplyVoltage: return "Measured supply voltage to the Pigeon2.";
                    case SpnValue::Pigeon2AngularVelocityX: return "The angular velocity (Ï) of the Pigeon 2 about the device's X axis.";
                    case SpnValue::Pigeon2AngularVelocityY: return "The angular velocity (Ï) of the Pigeon 2 about the device's Y axis.";
                    case SpnValue::Pigeon2AngularVelocityZ: return "The angular velocity (Ï) of the Pigeon 2 about the device's Z axis.";
                    case SpnValue::Pigeon2MagneticFieldX: return "The biased magnitude of the magnetic field measured by the Pigeon 2 in the X direction. This is only valid after performing a magnetometer calibration.";
                    case SpnValue::Pigeon2MagneticFieldY: return "The biased magnitude of the magnetic field measured by the Pigeon 2 in the Y direction. This is only valid after performing a magnetometer calibration.";
                    case SpnValue::Pigeon2MagneticFieldZ: return "The biased magnitude of the magnetic field measured by the Pigeon 2 in the Z direction. This is only valid after performing a magnetometer calibration.";
                    case SpnValue::Pigeon2RawMagneticFieldX: return "The raw magnitude of the magnetic field measured by the Pigeon 2 in the X direction. This is only valid after performing a magnetometer calibration.";
                    case SpnValue::Pigeon2RawMagneticFieldY: return "The raw magnitude of the magnetic field measured by the Pigeon 2 in the Y direction. This is only valid after performing a magnetometer calibration.";
                    case SpnValue::Pigeon2RawMagneticFieldZ: return "The raw magnitude of the magnetic field measured by the Pigeon 2 in the Z direction. This is only valid after performing a magnetometer calibration.";
                    case SpnValue::CANCoder_MagnetOffset: return "This offset is added to the reported position, allowing the application to trim the zero position.  When set to the default value of zero, position reports zero when magnet north pole aligns with the LED.";
                    case SpnValue::TalonFX_SetSensorPosition: return "Sets the mechanism position of the device in mechanism rotations.";
                    case SpnValue::CANcoder_SetSensorPosition: return "Sets the current position of the device.";
                    case SpnValue::Pigeon2_SetYaw: return "The yaw to set the Pigeon2 to right now.";
                    case SpnValue::DeviceEnabled: return "Whether the device is enabled.";
                    case SpnValue::PRO_MotorOutput_MotorVoltage: return "The applied (output) motor voltage.";
                    case SpnValue::ForwardLimit: return "Forward Limit Pin.";
                    case SpnValue::ReverseLimit: return "Reverse Limit Pin.";
                    case SpnValue::PRO_MotorOutput_RotorPolarity: return "The applied rotor polarity as seen from the front of the motor.  This typically is determined by the Inverted config, but can be overridden if using Follower features.";
                    case SpnValue::PRO_MotorOutput_DutyCycle: return "The applied motor duty cycle.";
                    case SpnValue::PRO_MotorOutput_TorqueCurrent: return "Current corresponding to the torque output by the motor. Similar to StatorCurrent. Users will likely prefer this current to calculate the applied torque to the rotor.";
                    case SpnValue::PRO_SupplyAndTemp_StatorCurrent: return "Current corresponding to the stator windings. Similar to TorqueCurrent. Users will likely prefer TorqueCurrent over StatorCurrent.";
                    case SpnValue::PRO_SupplyAndTemp_SupplyCurrent: return "Measured supply side current.";
                    case SpnValue::PRO_SupplyAndTemp_SupplyVoltage: return "Measured supply voltage to the device.";
                    case SpnValue::PRO_SupplyAndTemp_DeviceTemp: return "Temperature of device.";
                    case SpnValue::PRO_SupplyAndTemp_ProcessorTemp: return "Temperature of the processor.";
                    case SpnValue::PRO_RotorPosAndVel_Velocity: return "Velocity of the motor rotor. This velocity is not affected by any feedback configs.";
                    case SpnValue::PRO_RotorPosAndVel_Position: return "Position of the motor rotor. This position is only affected by the RotorOffset config and calls to setPosition.";
                    case SpnValue::PRO_PosAndVel_Velocity: return "Velocity of the device in mechanism rotations per second. This can be the velocity of a remote sensor and is affected by the RotorToSensorRatio and SensorToMechanismRatio configs.";
                    case SpnValue::PRO_PosAndVel_Position: return "Position of the device in mechanism rotations. This can be the position of a remote sensor and is affected by the RotorToSensorRatio and SensorToMechanismRatio configs, as well as calls to setPosition.";
                    case SpnValue::PRO_PosAndVel_Acceleration: return "Acceleration of the device in mechanism rotations per secondÂ². This can be the acceleration of a remote sensor and is affected by the RotorToSensorRatio and SensorToMechanismRatio configs.";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_DC: return "Integrated Accumulator of PID controller when PID'ing under a DutyCycle Request.";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_V: return "Integrated Accumulator of PID controller when PID'ing under a Voltage Request.";
                    case SpnValue::PRO_PIDStateEnables_IntegratedAccum_A: return "Integrated Accumulator of PID controller when PID'ing under a TorqueCurrent Request.";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_DC: return "Feedforward passed to PID controller.";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_V: return "Feedforward passed to PID controller.";
                    case SpnValue::PRO_PIDStateEnables_FeedForward_A: return "Feedforward passed to PID controller.";
                    case SpnValue::TalonFX_ControlMode: return "The active control mode of the motor controller.";
                    case SpnValue::PRO_PIDStateEnables_IsMotionMagicRunning: return "Check if Motion MagicÂ® is running.  This is equivalent to checking that the reported control mode is a Motion MagicÂ® based mode.";
                    case SpnValue::PRO_PIDStateEnables_DeviceEnable: return "Indicates if device is actuator enabled.";
                    case SpnValue::PRO_PIDRefPIDErr_PIDRef_Position: return "Input position of PID controller when PID'ing to a position.";
                    case SpnValue::PRO_PIDRefPIDErr_PIDRef_Velocity: return "Input velocity of PID controller when PID'ing to a velocity.";
                    case SpnValue::PRO_PIDRefPIDErr_PIDErr_Position: return "The difference between target position and current position.";
                    case SpnValue::PRO_PIDRefPIDErr_PIDErr_Velocity: return "The difference between target velocity and current velocity.";
                    case SpnValue::PRO_PIDRefPIDErr_ClosedLoopMode: return "Whether the closed-loop is running on position or velocity.";
                    case SpnValue::PRO_PIDOutput_PIDOutputMode: return "The output mode of the PID controller.";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_DC: return "Proportional output of PID controller when PID'ing under a DutyCycle Request.";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_V: return "Proportional output of PID controller when PID'ing under a Voltage Request.";
                    case SpnValue::PRO_PIDOutput_ProportionalOutput_A: return "Proportional output of PID controller when PID'ing under a TorqueCurrent Request.";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_DC: return "Derivative Output of PID controller when PID'ing under a DutyCycle Request.";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_V: return "Derivative Output of PID controller when PID'ing under a Voltage Request.";
                    case SpnValue::PRO_PIDOutput_DerivativeOutput_A: return "Derivative Output of PID controller when PID'ing under a TorqueCurrent Request.";
                    case SpnValue::PRO_PIDOutput_Output_DC: return "Output of PID controller when PID'ing under a DutyCycle Request.";
                    case SpnValue::PRO_PIDOutput_Output_V: return "Output of PID controller when PID'ing under a Voltage Request.";
                    case SpnValue::PRO_PIDOutput_Output_A: return "Output of PID controller when PID'ing under a TorqueCurrent Request.";
                    case SpnValue::PRO_PIDOutput_Slot: return "The slot that the closed-loop PID is using.";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ReferenceSlope_Position: return "Change in input (velocity) of PID controller when PID'ing to a position.";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ReferenceSlope_Velocity: return "Change in input (acceleration) of PID controller when PID'ing to a velocity.";
                    case SpnValue::PRO_PIDRefSlopeECUTime_ClosedLoopMode: return "Whether the closed-loop is running on position or velocity.";
                    case SpnValue::TalonFX_MotorOutputStatus: return "Assess the status of the motor output with respect to load and supply.";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_DutyCycle: return "The calculated motor duty cycle for differential followers.";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_TorqueCurrent: return "The calculated motor torque current for differential followers.";
                    case SpnValue::TalonFX_DifferentialControlMode: return "The active control mode of the differential controller.";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_DC: return "Integrated Accumulator of differential PID controller when PID'ing under a DutyCycle Request.";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_V: return "Integrated Accumulator of differential PID controller when PID'ing under a Voltage Request.";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_IntegratedAccum_A: return "Integrated Accumulator of differential PID controller when PID'ing under a TorqueCurrent Request.";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_DC: return "Feedforward passed to differential PID controller.";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_V: return "Feedforward passed to differential PID controller.";
                    case SpnValue::PRO_MotorOutput_PIDState_Diff_FeedForward_A: return "Feedforward passed to differential PID controller.";
                    case SpnValue::PRO_AvgPosAndVel_Velocity: return "Average component of the differential velocity of device.";
                    case SpnValue::PRO_AvgPosAndVel_Position: return "Average component of the differential position of device.";
                    case SpnValue::PRO_DiffPosAndVel_Velocity: return "Difference component of the differential velocity of device.";
                    case SpnValue::PRO_DiffPosAndVel_Position: return "Difference component of the differential position of device.";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDRef_Position: return "Input position of differential PID controller when PID'ing to a differential position.";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDRef_Velocity: return "Input velocity of differential PID controller when PID'ing to a differential velocity.";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDErr_Position: return "The difference between target differential position and current differential position.";
                    case SpnValue::PRO_DiffPIDRefPIDErr_PIDErr_Velocity: return "The difference between target differential velocity and current differential velocity.";
                    case SpnValue::PRO_DiffPIDRefPIDErr_ClosedLoopMode: return "Whether the closed-loop is running on position or velocity.";
                    case SpnValue::PRO_DiffPIDOutput_PIDOutputMode: return "The output mode of the differential PID controller.";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_DC: return "Proportional output of differential PID controller when PID'ing under a DutyCycle Request.";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_V: return "Proportional output of differential PID controller when PID'ing under a Voltage Request.";
                    case SpnValue::PRO_DiffPIDOutput_ProportionalOutput_A: return "Proportional output of differential PID controller when PID'ing under a TorqueCurrent Request.";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_DC: return "Derivative Output of differential PID controller when PID'ing under a DutyCycle Request.";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_V: return "Derivative Output of differential PID controller when PID'ing under a Voltage Request.";
                    case SpnValue::PRO_DiffPIDOutput_DerivativeOutput_A: return "Derivative Output of differential PID controller when PID'ing under a TorqueCurrent Request.";
                    case SpnValue::PRO_DiffPIDOutput_Output_DC: return "Output of differential PID controller when PID'ing under a DutyCycle Request.";
                    case SpnValue::PRO_DiffPIDOutput_Output_V: return "Output of differential PID controller when PID'ing under a Voltage Request.";
                    case SpnValue::PRO_DiffPIDOutput_Output_A: return "Output of differential PID controller when PID'ing under a TorqueCurrent Request.";
                    case SpnValue::PRO_DiffPIDOutput_Slot: return "The slot that the closed-loop differential PID is using.";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Position: return "Change in input (velocity) of differential PID controller when PID'ing to a differential position.";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ReferenceSlope_Velocity: return "Change in input (acceleration) of differential PID controller when PID'ing to a differential velocity.";
                    case SpnValue::PRO_DiffPIDRefSlopeECUTime_ClosedLoopMode: return "Whether the closed-loop is running on position or velocity.";
                    case SpnValue::TalonFX_MotorConstants_kT: return "The torque constant (K_T) of the motor.";
                    case SpnValue::TalonFX_MotorConstants_kV: return "The velocity constant (K_V) of the motor.";
                    case SpnValue::TalonFX_MotorConstants_StallCurrent: return "The stall current of the motor at 12 V output.";
                    case SpnValue::Slot0_kP: return "Proportional Gain.";
                    case SpnValue::Slot0_kI: return "Integral Gain.";
                    case SpnValue::Slot0_kD: return "Derivative Gain.";
                    case SpnValue::Slot0_kS: return "Static Feedforward Gain.";
                    case SpnValue::Slot0_kV: return "Velocity Feedforward Gain.";
                    case SpnValue::Slot0_kA: return "Acceleration Feedforward Gain.";
                    case SpnValue::Slot0_kG: return "Gravity Feedforward/Feedback Gain.";
                    case SpnValue::Slot0_kG_Type: return "Gravity Feedforward/Feedback Type.\nThis determines the type of the gravity feedforward/feedback.\nChoose Elevator_Static for systems where the gravity feedforward is constant, such as an elevator. The gravity feedforward output will always have the same sign.\nChoose Arm_Cosine for systems where the gravity feedback is dependent on the angular position of the mechanism, such as an arm. The gravity feedback output will vary depending on the mechanism angular position. Note that the sensor offset and ratios must be configured so that the sensor reports a position of 0 when the mechanism is horizonal (parallel to the ground), and the reported sensor position is 1:1 with the mechanism.";
                    case SpnValue::Slot1_kP: return "Proportional Gain.";
                    case SpnValue::Slot1_kI: return "Integral Gain.";
                    case SpnValue::Slot1_kD: return "Derivative Gain.";
                    case SpnValue::Slot1_kS: return "Static Feedforward Gain.";
                    case SpnValue::Slot1_kV: return "Velocity Feedforward Gain.";
                    case SpnValue::Slot1_kA: return "Acceleration Feedforward Gain.";
                    case SpnValue::Slot1_kG: return "Gravity Feedforward/Feedback Gain.";
                    case SpnValue::Slot1_kG_Type: return "Gravity Feedforward/Feedback Type.\nThis determines the type of the gravity feedforward/feedback.\nChoose Elevator_Static for systems where the gravity feedforward is constant, such as an elevator. The gravity feedforward output will always be positive.\nChoose Arm_Cosine for systems where the gravity feedback is dependent on the angular position of the mechanism, such as an arm. The gravity feedback output will vary depending on the mechanism angular position. Note that the sensor offset and ratios must be configured so that the sensor position is 0 when the mechanism is horizonal, and one rotation of the mechanism corresponds to one rotation of the sensor position.";
                    case SpnValue::Slot2_kP: return "Proportional Gain.";
                    case SpnValue::Slot2_kI: return "Integral Gain.";
                    case SpnValue::Slot2_kD: return "Derivative Gain.";
                    case SpnValue::Slot2_kS: return "Static Feedforward Gain.";
                    case SpnValue::Slot2_kV: return "Velocity Feedforward Gain.";
                    case SpnValue::Slot2_kA: return "Acceleration Feedforward Gain.";
                    case SpnValue::Slot2_kG: return "Gravity Feedforward/Feedback Gain.";
                    case SpnValue::Slot2_kG_Type: return "Gravity Feedforward/Feedback Type.\nThis determines the type of the gravity feedforward/feedback.\nChoose Elevator_Static for systems where the gravity feedforward is constant, such as an elevator. The gravity feedforward output will always be positive.\nChoose Arm_Cosine for systems where the gravity feedback is dependent on the angular position of the mechanism, such as an arm. The gravity feedback output will vary depending on the mechanism angular position. Note that the sensor offset and ratios must be configured so that the sensor position is 0 when the mechanism is horizonal, and one rotation of the mechanism corresponds to one rotation of the sensor position.";
                    case SpnValue::Config_Inverted: return "Invert state of the device as seen from the front of the motor.";
                    case SpnValue::Config_SupplyVLowpassTau: return "The time constant (in seconds) of the low-pass filter for the supply voltage.";
                    case SpnValue::Config_BeepOnBoot: return "If true, the TalonFX will beep during boot-up.  This is useful for general debugging, and defaults to true.  If rotor is moving during boot-up, the beep will not occur regardless of this setting.";
                    case SpnValue::Config_NeutralMode: return "The state of the motor controller bridge when output is neutral or disabled.";
                    case SpnValue::Config_DutyCycleNeutralDB: return "Configures the output deadband duty cycle during duty cycle and voltage based control modes.";
                    case SpnValue::Config_StatorCurrentLimit: return "The amount of current allowed in the motor (motoring and regen current).  Note this requires StatorCurrentLimitEnable to be true.\nFor torque current control, this is applied in addition to the PeakForwardTorqueCurrent and PeakReverseTorqueCurrent in TorqueCurrentConfigs.\nStator current is directly proportional to torque, so this limit can be used to restrict the torque output of the motor, such as preventing wheel slip for a drivetrain.  Additionally, stator current limits can prevent brownouts during acceleration; supply current will never exceed the stator current limit and is often significantly lower than stator current.\nA reasonable starting point for a stator current limit is 120 A, with values commonly ranging from 80-160 A. Mechanisms with a hard stop may need a smaller limit to reduce the torque applied when running into the hard stop.";
                    case SpnValue::Config_StatorCurrLimitEn: return "Enable motor stator current limiting.";
                    case SpnValue::Config_SupplyCurrentLimit: return "The absolute maximum amount of supply current allowed.  Note this requires SupplyCurrentLimitEnable to be true.  Use SupplyCurrentLowerLimit and SupplyCurrentLowerTime to reduce the supply current limit after the time threshold is exceeded.\nSupply current is the current drawn from the battery, so this limit can be used to prevent breaker trips and improve battery longevity.  Additionally, in scenarios where the robot experiences brownouts despite configuring stator current limits, a supply current limit can further help avoid brownouts. However, it is important to note that such brownouts may be caused by a bad battery or poor power wiring.\nA reasonable starting point for a supply current limit is 70 A with a lower limit of 40 A after 1.0 second. Supply current limits commonly range from 20-80 A depending on the breaker used.";
                    case SpnValue::Config_SupplyCurrLimitEn: return "Enable motor supply current limiting.";
                    case SpnValue::Config_PeakForwardDC: return "Maximum (forward) output during duty cycle based control modes.";
                    case SpnValue::Config_PeakReverseDC: return "Minimum (reverse) output during duty cycle based control modes.";
                    case SpnValue::Config_PeakForwardV: return "Maximum (forward) output during voltage based control modes.";
                    case SpnValue::Config_PeakReverseV: return "Minimum (reverse) output during voltage based control modes.";
                    case SpnValue::Config_PeakForTorqCurr: return "Maximum (forward) output during torque current based control modes.";
                    case SpnValue::Config_PeakRevTorqCurr: return "Minimum (reverse) output during torque current based control modes.";
                    case SpnValue::Config_TorqueNeutralDB: return "Configures the output deadband during torque current based control modes.";
                    case SpnValue::Config_FeedbackRotorOffset: return "The offset applied to the absolute integrated rotor sensor.  This can be used to zero the rotor in applications that are within one rotor rotation.";
                    case SpnValue::Config_SensorToMechanismRatio: return "The ratio of sensor rotations to the mechanism's output, where a ratio greater than 1 is a reduction.\nThis is equivalent to the mechanism's gear ratio if the sensor is located on the input of a gearbox.  If sensor is on the output of a gearbox, then this is typically set to 1.\nWe recommend against using this config to perform onboard unit conversions.  Instead, unit conversions should be performed in robot code using the units library.\nIf this is set to zero, the device will reset back to one.";
                    case SpnValue::Config_RotorToSensorRatio: return "The ratio of motor rotor rotations to remote sensor rotations, where a ratio greater than 1 is a reduction.\nThe Talon FX is capable of fusing a remote CANcoder with its rotor sensor to produce a high-bandwidth sensor source.  This feature requires specifying the ratio between the motor rotor and the remote sensor.\nIf this is set to zero, the device will reset back to one.";
                    case SpnValue::Config_FeedbackSensorSource: return "Choose what sensor source is reported via API and used by closed-loop and limit features.  The default is RotorSensor, which uses the internal rotor sensor in the Talon.\nChoose RemoteCANcoder to use another CANcoder on the same CAN bus (this also requires setting FeedbackRemoteSensorID).  Talon will update its position and velocity whenever CANcoder publishes its information on CAN bus, and the Talon internal rotor will not be used.\nChoose FusedCANcoder (requires Phoenix Pro) and Talon will fuse another CANcoder's information with the internal rotor, which provides the best possible position and velocity for accuracy and bandwidth (this also requires setting FeedbackRemoteSensorID).  FusedCANcoder was developed for applications such as swerve-azimuth.\nChoose SyncCANcoder (requires Phoenix Pro) and Talon will synchronize its internal rotor position against another CANcoder, then continue to use the rotor sensor for closed loop control (this also requires setting FeedbackRemoteSensorID).  The Talon will report if its internal position differs significantly from the reported CANcoder position.  SyncCANcoder was developed for mechanisms where there is a risk of the CANcoder failing in such a way that it reports a position that does not match the mechanism, such as the sensor mounting assembly breaking off.\nChoose RemotePigeon2_Yaw, RemotePigeon2_Pitch, and RemotePigeon2_Roll to use another Pigeon2 on the same CAN bus (this also requires setting FeedbackRemoteSensorID).  Talon will update its position to match the selected value whenever Pigeon2 publishes its information on CAN bus. Note that the Talon position will be in rotations and not degrees.";
                    case SpnValue::Config_FeedbackRemoteSensorID: return "Device ID of which remote device to use.  This is not used if the Sensor Source is the internal rotor sensor.";
                    case SpnValue::Config_DutyCycleOpenLoopRampPeriod: return "If non-zero, this determines how much time to ramp from 0% output to 100% during the open-loop DutyCycleOut control mode.\nThis provides an easy way to limit the acceleration of the motor. However, the acceleration and current draw of the motor can be better restricted using current limits instead of a ramp rate.";
                    case SpnValue::Config_VoltageOpenLoopRampPeriod: return "If non-zero, this determines how much time to ramp from 0V output to 12V during the open-loop VoltageOut control mode.\nThis provides an easy way to limit the acceleration of the motor. However, the acceleration and current draw of the motor can be better restricted using current limits instead of a ramp rate.";
                    case SpnValue::Config_TorqueOpenLoopRampPeriod: return "If non-zero, this determines how much time to ramp from 0A output to 300A during the open-loop TorqueCurrent control mode.\nSince TorqueCurrent is directly proportional to acceleration, this ramp limits jerk instead of acceleration.";
                    case SpnValue::Config_DutyCycleClosedLoopRampPeriod: return "If non-zero, this determines how much time to ramp from 0% output to 100% during the closed-loop DutyCycle control modes.\nIf the goal is to limit acceleration, it is more useful to ramp the closed-loop setpoint instead of the output. This can be achieved using Motion MagicÂ® controls.\nThe acceleration and current draw of the motor can also be better restricted using current limits instead of a ramp rate.";
                    case SpnValue::Config_VoltageClosedLoopRampPeriod: return "If non-zero, this determines how much time to ramp from 0V output to 12V during the closed-loop Voltage control modes.\nIf the goal is to limit acceleration, it is more useful to ramp the closed-loop setpoint instead of the output. This can be achieved using Motion MagicÂ® controls.\nThe acceleration and current draw of the motor can also be better restricted using current limits instead of a ramp rate.";
                    case SpnValue::Config_TorqueClosedLoopRampPeriod: return "If non-zero, this determines how much time to ramp from 0A output to 300A during the closed-loop TorqueCurrent control modes.\nSince TorqueCurrent is directly proportional to acceleration, this ramp limits jerk instead of acceleration.\nIf the goal is to limit acceleration or jerk, it is more useful to ramp the closed-loop setpoint instead of the output. This can be achieved using Motion MagicÂ® controls.\nThe acceleration and current draw of the motor can also be better restricted using current limits instead of a ramp rate.";
                    case SpnValue::Config_ForwardLimitType: return "Determines if the forward limit switch is normally-open (default) or normally-closed.";
                    case SpnValue::Config_ForwardLimitAutosetPosEnable: return "If enabled, the position is automatically set to a specific value, specified by ForwardLimitAutosetPositionValue, when the forward limit switch is asserted.";
                    case SpnValue::Config_ForwardLimitAutosetPosValue: return "The value to automatically set the position to when the forward limit switch is asserted.  This has no effect if ForwardLimitAutosetPositionEnable is false.";
                    case SpnValue::Config_ForwardLimitEnable: return "If enabled, motor output is set to neutral when the forward limit switch is asserted and positive output is requested.";
                    case SpnValue::Config_ForwardLimitSource: return "Determines where to poll the forward limit switch.  This defaults to the forward limit switch pin on the limit switch connector.\nChoose RemoteTalonFX to use the forward limit switch attached to another Talon FX on the same CAN bus (this also requires setting ForwardLimitRemoteSensorID).\nChoose RemoteCANifier to use the forward limit switch attached to another CANifier on the same CAN bus (this also requires setting ForwardLimitRemoteSensorID).\nChoose RemoteCANcoder to use another CANcoder on the same CAN bus (this also requires setting ForwardLimitRemoteSensorID).  The forward limit will assert when the CANcoder magnet strength changes from BAD (red) to ADEQUATE (orange) or GOOD (green).";
                    case SpnValue::Config_ForwardLimitRemoteSensorID: return "Device ID of the remote device if using remote limit switch features for the forward limit switch.";
                    case SpnValue::Config_ReverseLimitType: return "Determines if the reverse limit switch is normally-open (default) or normally-closed.";
                    case SpnValue::Config_ReverseLimitAutosetPosEnable: return "If enabled, the position is automatically set to a specific value, specified by ReverseLimitAutosetPositionValue, when the reverse limit switch is asserted.";
                    case SpnValue::Config_ReverseLimitAutosetPosValue: return "The value to automatically set the position to when the reverse limit switch is asserted.  This has no effect if ReverseLimitAutosetPositionEnable is false.";
                    case SpnValue::Config_ReverseLimitEnable: return "If enabled, motor output is set to neutral when reverse limit switch is asseted and negative output is requested.";
                    case SpnValue::Config_ReverseLimitSource: return "Determines where to poll the reverse limit switch.  This defaults to the reverse limit switch pin on the limit switch connector.\nChoose RemoteTalonFX to use the reverse limit switch attached to another Talon FX on the same CAN bus (this also requires setting ReverseLimitRemoteSensorID).\nChoose RemoteCANifier to use the reverse limit switch attached to another CANifier on the same CAN bus (this also requires setting ReverseLimitRemoteSensorID).\nChoose RemoteCANcoder to use another CANcoder on the same CAN bus (this also requires setting ReverseLimitRemoteSensorID).  The reverse limit will assert when the CANcoder magnet strength changes from BAD (red) to ADEQUATE (orange) or GOOD (green).";
                    case SpnValue::Config_ReverseLimitRemoteSensorID: return "Device ID of the remote device if using remote limit switch features for the reverse limit switch.";
                    case SpnValue::Config_ForwardSoftLimitEnable: return "If enabled, the motor output is set to neutral if position exceeds ForwardSoftLimitThreshold and forward output is requested.";
                    case SpnValue::Config_ReverseSoftLimitEnable: return "If enabled, the motor output is set to neutral if position exceeds ReverseSoftLimitThreshold and reverse output is requested.";
                    case SpnValue::Config_ForwardSoftLimitThreshold: return "Position threshold for forward soft limit features. ForwardSoftLimitEnable must be enabled for this to take effect.";
                    case SpnValue::Config_ReverseSoftLimitThreshold: return "Position threshold for reverse soft limit features. ReverseSoftLimitEnable must be enabled for this to take effect.";
                    case SpnValue::Config_MotionMagicCruiseVelocity: return "This is the maximum velocity Motion MagicÂ® based control modes are allowed to use.  Motion MagicÂ® Velocity control modes do not use this config.\nWhen using Motion MagicÂ® Expo control modes, setting this to 0 will allow the profile to run to the max possible velocity based on Expo_kV.";
                    case SpnValue::Config_MotionMagicAcceleration: return "This is the target acceleration Motion MagicÂ® based control modes are allowed to use.  Motion MagicÂ® Expo control modes do not use this config.";
                    case SpnValue::Config_MotionMagicJerk: return "This is the target jerk (acceleration derivative) Motion MagicÂ® based control modes are allowed to use.  Motion MagicÂ® Expo control modes do not use this config.  This allows Motion MagicÂ® to generate S-Curve profiles.\nJerk is optional; if this is set to zero, then Motion MagicÂ® will not apply a Jerk limit.";
                    case SpnValue::Config_MotionMagicExpo_kV: return "This is the target kV used only by Motion MagicÂ® Expo control modes. Unlike the kV slot gain, this is always in units of V/rps.\nThis represents the amount of voltage necessary to hold a velocity. In terms of the Motion MagicÂ® Expo profile, a higher kV results in a slower maximum velocity.";
                    case SpnValue::Config_MotionMagicExpo_kA: return "This is the target kA used only by Motion MagicÂ® Expo control modes. Unlike the kA slot gain, this is always in units of V/rpsÂ².\nThis represents the amount of voltage necessary to achieve an acceleration. In terms of the Motion MagicÂ® Expo profile, a higher kA results in a slower acceleration.";
                    case SpnValue::Config_PeakDiffDC: return "Maximum differential output during duty cycle based differential control modes.";
                    case SpnValue::Config_PeakDiffV: return "Maximum differential output during voltage based differential control modes.";
                    case SpnValue::Config_PeakDiffTorqCurr: return "Maximum differential output during torque current based differential control modes.";
                    case SpnValue::CANcoder_Velocity: return "Velocity of the device.";
                    case SpnValue::CANcoder_Position: return "Position of the device. This is initialized to the absolute position on boot.";
                    case SpnValue::CANcoder_AbsPosition: return "Absolute Position of the device. The possible range is documented below; however, the exact expected range is determined by the AbsoluteSensorDiscontinuityPoint. This position is only affected by the MagnetSensor configs.";
                    case SpnValue::CANCoder_RawVel: return "The unfiltered velocity reported by CANcoder.";
                    case SpnValue::CANCoder_RawPos: return "The relative position reported by the CANcoder since boot.";
                    case SpnValue::CANCoder_SupplyVoltage: return "Measured supply voltage to the CANcoder.";
                    case SpnValue::CANcoder_MagHealth: return "Magnet health as measured by CANcoder.\nRed indicates too close or too far, Orange is adequate but with reduced accuracy, green is ideal. Invalid means the accuracy cannot be determined.";
                    case SpnValue::SPN_ClearStickyFaults: return "Clear the sticky faults in the device.";
                    case SpnValue::PRO_MotorOutput_BridgeType_Public: return "The applied output of the bridge.";
                    case SpnValue::Config_ContinuousWrap: return "Wrap position error within [-0.5,+0.5) mechanism rotations.  Typically used for continuous position closed-loops like swerve azimuth.";
                    case SpnValue::Config_SupplyCurrentLowerLimit: return "The amount of supply current allowed after the regular SupplyCurrentLimit is active for longer than SupplyCurrentLowerTime.  This allows higher current draws for a fixed period of time before reducing the current limit to protect breakers.  This has no effect if SupplyCurrentLimit is lower than this value or SupplyCurrentLowerTime is 0.";
                    case SpnValue::Config_SupplyCurrentLowerTime: return "Reduces supply current to the SupplyCurrentLowerLimit after limiting to SupplyCurrentLimit for this period of time.  If this is set to 0, SupplyCurrentLowerLimit will be ignored.";
                    case SpnValue::Config_DifferentialSensorSource: return "Choose what sensor source is used for differential control of a mechanism.  The default is Disabled.  All other options require setting the DifferentialTalonFXSensorID, as the average of this Talon FX's sensor and the remote TalonFX's sensor is used for the differential controller's primary targets.\nChoose RemoteTalonFX_Diff to use another TalonFX on the same CAN bus.  Talon FX will update its differential position and velocity whenever the remote TalonFX publishes its information on CAN bus.  The differential controller will use the difference between this TalonFX's sensor and the remote Talon FX's sensor for the differential component of the output.\nChoose RemotePigeon2_Yaw, RemotePigeon2_Pitch, and RemotePigeon2_Roll to use another Pigeon2 on the same CAN bus (this also requires setting DifferentialRemoteSensorID).  Talon FX will update its differential position to match the selected value whenever Pigeon2 publishes its information on CAN bus. Note that the Talon FX differential position will be in rotations and not degrees.\nChoose RemoteCANcoder to use another CANcoder on the same CAN bus (this also requires setting DifferentialRemoteSensorID).  Talon FX will update its differential position and velocity to match the CANcoder whenever CANcoder publishes its information on CAN bus.";
                    case SpnValue::Config_DifferentialTalonFXSensorID: return "Device ID of which remote Talon FX to use.  This is used when the Differential Sensor Source is not disabled.";
                    case SpnValue::Config_DifferentialRemoteSensorID: return "Device ID of which remote sensor to use on the differential axis.  This is used when the Differential Sensor Source is not RemoteTalonFX_Diff.";
                    case SpnValue::Config_BeepOnConfig: return "If true, the TalonFX will beep during configuration API calls if device is disabled.  This is useful for general debugging, and defaults to true.  Note that if the rotor is moving, the beep will not occur regardless of this setting.";
                    case SpnValue::Config_AllowMusicDurDisable: return "If true, the TalonFX will allow Orchestra and MusicTone requests during disabled state.  This can be used to address corner cases when music features are needed when disabled.  This setting defaults to false.  Note that if the rotor is moving, music features are always disabled regardless of this setting.";
                    case SpnValue::Compliancy_Version: return "Compliancy number.";
                    case SpnValue::Version_IsProLicensed: return "Whether the device is Phoenix Pro licensed.";
                    case SpnValue::PRO_SupplyAndTemp_DeviceTemp2: return "Temperature of device from second sensor.";
                    case SpnValue::Slot0_kS_Sign: return "Static Feedforward Sign during position closed loop.\nThis determines the sign of the applied kS during position closed-loop modes. The default behavior uses the velocity reference sign. This works well with velocity closed loop, Motion MagicÂ® controls, and position closed loop when velocity reference is specified (motion profiling).\nHowever, when using position closed loop with zero velocity reference (no motion profiling), the application may want to apply static feedforward based on the sign of closed loop error instead. When doing so, we recommend using the minimal amount of kS, otherwise the motor output may dither when closed loop error is near zero.";
                    case SpnValue::Slot1_kS_Sign: return "Static Feedforward Sign during position closed loop.\nThis determines the sign of the applied kS during position closed-loop modes. The default behavior uses the velocity reference sign. This works well with velocity closed loop, Motion MagicÂ® controls, and position closed loop when velocity reference is specified (motion profiling).\nHowever, when using position closed loop with zero velocity reference (no motion profiling), the application may want to apply static feedforward based on the closed loop error sign instead. When doing so, we recommend using the minimal amount of kS, otherwise the motor output may dither when closed loop error is near zero.";
                    case SpnValue::Slot2_kS_Sign: return "Static Feedforward Sign during position closed loop.\nThis determines the sign of the applied kS during position closed-loop modes. The default behavior uses the velocity reference sign. This works well with velocity closed loop, Motion MagicÂ® controls, and position closed loop when velocity reference is specified (motion profiling).\nHowever, when using position closed loop with zero velocity reference (no motion profiling), the application may want to apply static feedforward based on the closed loop error sign instead. When doing so, we recommend using the minimal amount of kS, otherwise the motor output may dither when closed loop error is near zero.";
                    case SpnValue::TalonFX_ConnectedMotor: return "The type of motor attached to the Talon.";
                    case SpnValue::CANrange_SupplyVoltage: return "Measured supply voltage to the CANrange.";
                    case SpnValue::CANrange_Distance_Meters: return "Distance to the nearest object in the configured field of view of the CANrange.";
                    case SpnValue::CANrange_MeasTime: return "Timestamp of the most recent measurements. This is not synchronized to any other clock source.\nUsers can use this to check when the measurements are updated.";
                    case SpnValue::CANrange_SignalStrength: return "Approximate signal strength of the measurement. A higher value indicates a higher strength of signal.\nA value of ~2500 is typical when detecting an object under short-range conditions.";
                    case SpnValue::CANrange_ProximityDetected: return "Whether the CANrange detects an object using the configured proximity parameters.";
                    case SpnValue::CANrange_MeasState: return "Health of the distance measurement.";
                    case SpnValue::CANrange_AmbientSignal: return "The amount of ambient infrared light that the sensor is detecting. For ideal operation, this should be as low as possible.";
                    case SpnValue::CANrange_DistanceStdDev: return "Standard Deviation of the distance measurement.";
                    case SpnValue::CANrange_RealFOVCenterX: return "The actual center of the FOV in the X direction. This takes into account the user-configured FOVCenterX and FOVRangeX.";
                    case SpnValue::CANrange_RealFOVCenterY: return "The actual center of the FOV in the Y direction. This takes into account the user-configured FOVCenterY and FOVRangeY.";
                    case SpnValue::CANrange_RealFOVRangeX: return "The actual range of the FOV in the X direction. This takes into account the user-configured FOVRangeX.";
                    case SpnValue::CANrange_RealFOVRangeY: return "The actual range of the FOV in the Y direction. This takes into account the user-configured FOVRangeY.";
                    case SpnValue::CANrange_UpdateMode: return "Update mode of the CANrange. The CANrange supports short-range and long-range detection at various update frequencies.";
                    case SpnValue::CANrange_UpdateFreq: return "Rate at which the CANrange will take measurements. A lower frequency may provide more stable readings but will reduce the data rate of the sensor.";
                    case SpnValue::CANrange_ProximityThreshold: return "Threshold for object detection.";
                    case SpnValue::CANrange_ProximityHysteresis: return "How far above and below the threshold the distance needs to be to trigger undetected and detected, respectively. This is used to prevent bouncing between the detected and undetected states for objects on the threshold.\nIf the threshold is set to 0.1 meters, and the hysteresis is 0.01 meters, then an object needs to be within 0.09 meters to be detected. After the object is first detected, the distance then needs to exceed 0.11 meters to become undetected again.";
                    case SpnValue::CANrange_MinSigStrengthForValidMeas: return "The minimum allowable signal strength before determining the measurement is valid.\nIf the signal strength is particularly low, this typically means the object is far away and there's fewer total samples to derive the distance from. Set this value to be below the lowest strength you see when you're detecting an object with the CANrange; the default of 2500 is typically acceptable in most cases.";
                    case SpnValue::CANrange_FOVCenterX: return "Specifies the target center of the Field of View in the X direction.";
                    case SpnValue::CANrange_FOVCenterY: return "Specifies the target center of the Field of View in the Y direction.";
                    case SpnValue::CANrange_FOVRangeX: return "Specifies the target range of the Field of View in the X direction. This is the full range of the FOV.\nThe magnitude of this is capped to abs(27 - 2*FOVCenterX).";
                    case SpnValue::CANrange_FOVRangeY: return "Specifies the target range of the Field of View in the Y direction. This is the full range of the FOV.\nThe magnitude of this is capped to abs(27 - 2*FOVCenterY).";
                    case SpnValue::Config_ControlTimesyncFreq: return "When a control request UseTimesync is enabled, this determines the time-sychronized frequency at which control requests are applied.";
                    case SpnValue::Config_VelocityFilterTimeConstant: return "The configurable time constant of the Kalman velocity filter. The velocity Kalman filter will adjust to act as a low-pass with this value as its time constant.";
                    case SpnValue::Config_AbsoluteSensorDiscontinuityPoint: return "The positive discontinuity point of the absolute sensor in rotations. This determines the point at which the absolute sensor wraps around, keeping the absolute position in the range [x-1, x). <list><item>Setting this to 1 makes the absolute position unsigned [0, 1) <item>Setting this to 0.5 makes the absolute position signed [-0.5, 0.5) <item>Setting this to 0 makes the absolute position always negative [-1, 0)</list> Many rotational mechanisms such as arms have a region of motion that is unreachable. This should be set to the center of that region of motion, in non-negative rotations. This affects the position of the device at bootup.";
                    case SpnValue::Fault_Hardware: return "Hardware fault occurred";
                    case SpnValue::StickyFault_Hardware: return "Hardware fault occurred";
                    case SpnValue::ClearStickyFault_Hardware: return "Clear sticky fault: Hardware fault occurred";
                    case SpnValue::Fault_ProcTemp: return "Processor temperature exceeded limit";
                    case SpnValue::StickyFault_ProcTemp: return "Processor temperature exceeded limit";
                    case SpnValue::ClearStickyFault_ProcTemp: return "Clear sticky fault: Processor temperature exceeded limit";
                    case SpnValue::Fault_DeviceTemp: return "Device temperature exceeded limit";
                    case SpnValue::StickyFault_DeviceTemp: return "Device temperature exceeded limit";
                    case SpnValue::ClearStickyFault_DeviceTemp: return "Clear sticky fault: Device temperature exceeded limit";
                    case SpnValue::Fault_Undervoltage: return "Device supply voltage dropped to near brownout levels";
                    case SpnValue::StickyFault_Undervoltage: return "Device supply voltage dropped to near brownout levels";
                    case SpnValue::ClearStickyFault_Undervoltage: return "Clear sticky fault: Device supply voltage dropped to near brownout levels";
                    case SpnValue::Fault_BootDuringEnable: return "Device boot while detecting the enable signal";
                    case SpnValue::StickyFault_BootDuringEnable: return "Device boot while detecting the enable signal";
                    case SpnValue::ClearStickyFault_BootDuringEnable: return "Clear sticky fault: Device boot while detecting the enable signal";
                    case SpnValue::Fault_UnlicensedFeatureInUse: return "An unlicensed feature is in use, device may not behave as expected.";
                    case SpnValue::StickyFault_UnlicensedFeatureInUse: return "An unlicensed feature is in use, device may not behave as expected.";
                    case SpnValue::ClearStickyFault_UnlicensedFeatureInUse: return "Clear sticky fault: An unlicensed feature is in use, device may not behave as expected.";
                    case SpnValue::Fault_PIGEON2_BootupAccel: return "Bootup checks failed: Accelerometer";
                    case SpnValue::StickyFault_PIGEON2_BootupAccel: return "Bootup checks failed: Accelerometer";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupAccel: return "Clear sticky fault: Bootup checks failed: Accelerometer";
                    case SpnValue::Fault_PIGEON2_BootupGyros: return "Bootup checks failed: Gyroscope";
                    case SpnValue::StickyFault_PIGEON2_BootupGyros: return "Bootup checks failed: Gyroscope";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupGyros: return "Clear sticky fault: Bootup checks failed: Gyroscope";
                    case SpnValue::Fault_PIGEON2_BootupMagne: return "Bootup checks failed: Magnetometer";
                    case SpnValue::StickyFault_PIGEON2_BootupMagne: return "Bootup checks failed: Magnetometer";
                    case SpnValue::ClearStickyFault_PIGEON2_BootupMagne: return "Clear sticky fault: Bootup checks failed: Magnetometer";
                    case SpnValue::Fault_PIGEON2_BootIntoMotion: return "Motion Detected during bootup.";
                    case SpnValue::StickyFault_PIGEON2_BootIntoMotion: return "Motion Detected during bootup.";
                    case SpnValue::ClearStickyFault_PIGEON2_BootIntoMotion: return "Clear sticky fault: Motion Detected during bootup.";
                    case SpnValue::Fault_PIGEON2_DataAcquiredLate: return "Motion stack data acquisition was slower than expected";
                    case SpnValue::StickyFault_PIGEON2_DataAcquiredLate: return "Motion stack data acquisition was slower than expected";
                    case SpnValue::ClearStickyFault_PIGEON2_DataAcquiredLate: return "Clear sticky fault: Motion stack data acquisition was slower than expected";
                    case SpnValue::Fault_PIGEON2_LoopTimeSlow: return "Motion stack loop time was slower than expected.";
                    case SpnValue::StickyFault_PIGEON2_LoopTimeSlow: return "Motion stack loop time was slower than expected.";
                    case SpnValue::ClearStickyFault_PIGEON2_LoopTimeSlow: return "Clear sticky fault: Motion stack loop time was slower than expected.";
                    case SpnValue::Fault_PIGEON2_SaturatedMagne: return "Magnetometer values are saturated";
                    case SpnValue::StickyFault_PIGEON2_SaturatedMagne: return "Magnetometer values are saturated";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedMagne: return "Clear sticky fault: Magnetometer values are saturated";
                    case SpnValue::Fault_PIGEON2_SaturatedAccel: return "Accelerometer values are saturated";
                    case SpnValue::StickyFault_PIGEON2_SaturatedAccel: return "Accelerometer values are saturated";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedAccel: return "Clear sticky fault: Accelerometer values are saturated";
                    case SpnValue::Fault_PIGEON2_SaturatedGyros: return "Gyroscope values are saturated";
                    case SpnValue::StickyFault_PIGEON2_SaturatedGyros: return "Gyroscope values are saturated";
                    case SpnValue::ClearStickyFault_PIGEON2_SaturatedGyros: return "Clear sticky fault: Gyroscope values are saturated";
                    case SpnValue::Fault_CANCODER_BadMagnet: return "The magnet distance is not correct or magnet is missing";
                    case SpnValue::StickyFault_CANCODER_BadMagnet: return "The magnet distance is not correct or magnet is missing";
                    case SpnValue::ClearStickyFault_CANCODER_BadMagnet: return "Clear sticky fault: The magnet distance is not correct or magnet is missing";
                    case SpnValue::Fault_TALONFX_BridgeBrownout: return "Bridge was disabled most likely due to supply voltage dropping too low.";
                    case SpnValue::StickyFault_TALONFX_BridgeBrownout: return "Bridge was disabled most likely due to supply voltage dropping too low.";
                    case SpnValue::ClearStickyFault_TALONFX_BridgeBrownout: return "Clear sticky fault: Bridge was disabled most likely due to supply voltage dropping too low.";
                    case SpnValue::Fault_TALONFX_RemoteSensorReset: return "The remote sensor has reset.";
                    case SpnValue::StickyFault_TALONFX_RemoteSensorReset: return "The remote sensor has reset.";
                    case SpnValue::ClearStickyFault_TALONFX_RemoteSensorReset: return "Clear sticky fault: The remote sensor has reset.";
                    case SpnValue::Fault_TALONFX_MissingDifferentialFX: return "The remote Talon used for differential control is not present on CAN Bus.";
                    case SpnValue::StickyFault_TALONFX_MissingDifferentialFX: return "The remote Talon used for differential control is not present on CAN Bus.";
                    case SpnValue::ClearStickyFault_TALONFX_MissingDifferentialFX: return "Clear sticky fault: The remote Talon used for differential control is not present on CAN Bus.";
                    case SpnValue::Fault_TALONFX_RemoteSensorPosOverflow: return "The remote sensor position has overflowed. Because of the nature of remote sensors, it is possible for the remote sensor position to overflow beyond what is supported by the status signal frame. However, this is rare and cannot occur over the course of an FRC match under normal use.";
                    case SpnValue::StickyFault_TALONFX_RemoteSensorPosOverflow: return "The remote sensor position has overflowed. Because of the nature of remote sensors, it is possible for the remote sensor position to overflow beyond what is supported by the status signal frame. However, this is rare and cannot occur over the course of an FRC match under normal use.";
                    case SpnValue::ClearStickyFault_TALONFX_RemoteSensorPosOverflow: return "Clear sticky fault: The remote sensor position has overflowed. Because of the nature of remote sensors, it is possible for the remote sensor position to overflow beyond what is supported by the status signal frame. However, this is rare and cannot occur over the course of an FRC match under normal use.";
                    case SpnValue::Fault_TALONFX_OverSupplyV: return "Supply Voltage has exceeded the maximum voltage rating of device.";
                    case SpnValue::StickyFault_TALONFX_OverSupplyV: return "Supply Voltage has exceeded the maximum voltage rating of device.";
                    case SpnValue::ClearStickyFault_TALONFX_OverSupplyV: return "Clear sticky fault: Supply Voltage has exceeded the maximum voltage rating of device.";
                    case SpnValue::Fault_TALONFX_UnstableSupplyV: return "Supply Voltage is unstable.  Ensure you are using a battery and current limited power supply.";
                    case SpnValue::StickyFault_TALONFX_UnstableSupplyV: return "Supply Voltage is unstable.  Ensure you are using a battery and current limited power supply.";
                    case SpnValue::ClearStickyFault_TALONFX_UnstableSupplyV: return "Clear sticky fault: Supply Voltage is unstable.  Ensure you are using a battery and current limited power supply.";
                    case SpnValue::Fault_TALONFX_ReverseHardLimit: return "Reverse limit switch has been asserted.  Output is set to neutral.";
                    case SpnValue::StickyFault_TALONFX_ReverseHardLimit: return "Reverse limit switch has been asserted.  Output is set to neutral.";
                    case SpnValue::ClearStickyFault_TALONFX_ReverseHardLimit: return "Clear sticky fault: Reverse limit switch has been asserted.  Output is set to neutral.";
                    case SpnValue::Fault_TALONFX_ForwardHardLimit: return "Forward limit switch has been asserted.  Output is set to neutral.";
                    case SpnValue::StickyFault_TALONFX_ForwardHardLimit: return "Forward limit switch has been asserted.  Output is set to neutral.";
                    case SpnValue::ClearStickyFault_TALONFX_ForwardHardLimit: return "Clear sticky fault: Forward limit switch has been asserted.  Output is set to neutral.";
                    case SpnValue::Fault_TALONFX_ReverseSoftLimit: return "Reverse soft limit has been asserted.  Output is set to neutral.";
                    case SpnValue::StickyFault_TALONFX_ReverseSoftLimit: return "Reverse soft limit has been asserted.  Output is set to neutral.";
                    case SpnValue::ClearStickyFault_TALONFX_ReverseSoftLimit: return "Clear sticky fault: Reverse soft limit has been asserted.  Output is set to neutral.";
                    case SpnValue::Fault_TALONFX_ForwardSoftLimit: return "Forward soft limit has been asserted.  Output is set to neutral.";
                    case SpnValue::StickyFault_TALONFX_ForwardSoftLimit: return "Forward soft limit has been asserted.  Output is set to neutral.";
                    case SpnValue::ClearStickyFault_TALONFX_ForwardSoftLimit: return "Clear sticky fault: Forward soft limit has been asserted.  Output is set to neutral.";
                    case SpnValue::Fault_TALONFX_MissingRemSoftLim: return "The remote soft limit device is not present on CAN Bus.";
                    case SpnValue::StickyFault_TALONFX_MissingRemSoftLim: return "The remote soft limit device is not present on CAN Bus.";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemSoftLim: return "Clear sticky fault: The remote soft limit device is not present on CAN Bus.";
                    case SpnValue::Fault_TALONFX_MissingRemHardLim: return "The remote limit switch device is not present on CAN Bus.";
                    case SpnValue::StickyFault_TALONFX_MissingRemHardLim: return "The remote limit switch device is not present on CAN Bus.";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemHardLim: return "Clear sticky fault: The remote limit switch device is not present on CAN Bus.";
                    case SpnValue::Fault_TALONFX_MissingRemoteSensor: return "The remote sensor's data is no longer trusted. This can happen if the remote sensor disappears from the CAN bus or if the remote sensor indicates its data is no longer valid, such as when a CANcoder's magnet strength falls into the \"red\" range.";
                    case SpnValue::StickyFault_TALONFX_MissingRemoteSensor: return "The remote sensor's data is no longer trusted. This can happen if the remote sensor disappears from the CAN bus or if the remote sensor indicates its data is no longer valid, such as when a CANcoder's magnet strength falls into the \"red\" range.";
                    case SpnValue::ClearStickyFault_TALONFX_MissingRemoteSensor: return "Clear sticky fault: The remote sensor's data is no longer trusted. This can happen if the remote sensor disappears from the CAN bus or if the remote sensor indicates its data is no longer valid, such as when a CANcoder's magnet strength falls into the \"red\" range.";
                    case SpnValue::Fault_TALONFX_FusedSensorOutOfSync: return "The remote sensor used for fusion has fallen out of sync to the local sensor. A re-synchronization has occurred, which may cause a discontinuity. This typically happens if there is significant slop in the mechanism, or if the RotorToSensorRatio configuration parameter is incorrect.";
                    case SpnValue::StickyFault_TALONFX_FusedSensorOutOfSync: return "The remote sensor used for fusion has fallen out of sync to the local sensor. A re-synchronization has occurred, which may cause a discontinuity. This typically happens if there is significant slop in the mechanism, or if the RotorToSensorRatio configuration parameter is incorrect.";
                    case SpnValue::ClearStickyFault_TALONFX_FusedSensorOutOfSync: return "Clear sticky fault: The remote sensor used for fusion has fallen out of sync to the local sensor. A re-synchronization has occurred, which may cause a discontinuity. This typically happens if there is significant slop in the mechanism, or if the RotorToSensorRatio configuration parameter is incorrect.";
                    case SpnValue::Fault_TALONFX_StatorCurrLimit: return "Stator current limit occured.";
                    case SpnValue::StickyFault_TALONFX_StatorCurrLimit: return "Stator current limit occured.";
                    case SpnValue::ClearStickyFault_TALONFX_StatorCurrLimit: return "Clear sticky fault: Stator current limit occured.";
                    case SpnValue::Fault_TALONFX_SupplyCurrLimit: return "Supply current limit occured.";
                    case SpnValue::StickyFault_TALONFX_SupplyCurrLimit: return "Supply current limit occured.";
                    case SpnValue::ClearStickyFault_TALONFX_SupplyCurrLimit: return "Clear sticky fault: Supply current limit occured.";
                    case SpnValue::Fault_TALONFX_UsingFusedCCWhileUnlicensed: return "Using Fused CANcoder feature while unlicensed. Device has fallen back to remote CANcoder.";
                    case SpnValue::StickyFault_TALONFX_UsingFusedCCWhileUnlicensed: return "Using Fused CANcoder feature while unlicensed. Device has fallen back to remote CANcoder.";
                    case SpnValue::ClearStickyFault_TALONFX_UsingFusedCCWhileUnlicensed: return "Clear sticky fault: Using Fused CANcoder feature while unlicensed. Device has fallen back to remote CANcoder.";
                    case SpnValue::Fault_TALONFX_StaticBrakeDisabled: return "Static brake was momentarily disabled due to excessive braking current while disabled.";
                    case SpnValue::StickyFault_TALONFX_StaticBrakeDisabled: return "Static brake was momentarily disabled due to excessive braking current while disabled.";
                    case SpnValue::ClearStickyFault_TALONFX_StaticBrakeDisabled: return "Clear sticky fault: Static brake was momentarily disabled due to excessive braking current while disabled.";
                    default:
                        return "Invalid Value";
                    }
                }

                friend std::ostream &operator<<(std::ostream &os, SpnValue data)
                {
                    os << data.ToString();
                    return os;
                }
            };
        }
    }
}
