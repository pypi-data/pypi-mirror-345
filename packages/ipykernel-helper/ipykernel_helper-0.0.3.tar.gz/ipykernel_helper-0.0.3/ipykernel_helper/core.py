"""API for ipykernel-helper"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['safe_repr']

# %% ../nbs/00_core.ipynb
from fastcore.meta import delegates
from fastcore.utils import patch,dict2obj
import typing,warnings
from types import ModuleType, FunctionType, MethodType, BuiltinFunctionType
from inspect import signature, currentframe
from functools import cmp_to_key,partial
from toolslm.funccall import *

from jupyter_client import AsyncKernelClient
from IPython.core.interactiveshell import InteractiveShell
from IPython.core.completer import ProvisionalCompleterWarning
from jedi import Interpreter, Script as jscript

from IPython.core.display import DisplayObject

# %% ../nbs/00_core.ipynb
warnings.filterwarnings('ignore', category=ProvisionalCompleterWarning)

# %% ../nbs/00_core.ipynb
def safe_repr(obj, max_len=200):
    "Safely get the repr() of an object, truncating if it exceeds max_len."
    try:
        s = str(obj)
        return s[:max_len] + ("â€¦" if len(s)>max_len else "")
    except Exception as e: return f"<repr error: {str(e)}>"

# %% ../nbs/00_core.ipynb
@patch
def user_items(self:InteractiveShell, max_len=200, xtra_skip=()):
    "Get user-defined vars & funcs from namespace."
    ns = self.user_ns
    ignore = {'In', 'Out', 'exit', 'quit', 'open', 'nbmeta', 'receive_nbmeta'}
    ignore.add(xtra_skip)
    rm_types = (
        type, FunctionType, ModuleType, MethodType, BuiltinFunctionType,
        getattr(typing, '_SpecialGenericAlias', ()),
        getattr(typing, '_GenericAlias', ()),
        getattr(typing, '_SpecialForm', ())
    )
    user_items = {k:v for k, v in ns.items()
                  if not k in ignore}
    user_vars = {k:safe_repr(v, max_len=max_len)
                 for k, v in user_items.items() if not k.startswith('_') and not isinstance(v, rm_types)}
    user_fns = {k:str(signature(v)) for k, v in user_items.items()
                if isinstance(v, FunctionType) and v.__module__ == '__main__' and not k.startswith('__')}
    return user_vars,user_fns

# %% ../nbs/00_core.ipynb
def _rank(c, s):
    "Rank a completion `c` for text `s` with namespace `ns`."
    parts = s.split('.')
    is_public = not c.text.startswith('_')
    if c.type=='param': r=1
    elif c.mod=='__main__': r=2 # local
    elif len(parts)>1 and parts[0]==c.mod: r=3 # module
    elif c.mod=='builtins': r=4
    else: r=5
    return r if is_public else r+0.1

# %% ../nbs/00_core.ipynb
@patch
def ranked_complete(self:InteractiveShell, code, line_no=None, col_no=None):
    ns = self.user_ns
    lines = code.splitlines(True)
    if line_no: offset = sum(len(lines[i]) for i in range(line_no-1)) + col_no -1
    else: offset = len(code)
    cs = self.Completer.completions(code, offset)
    def _c(a):
        res = dict2obj({attr: getattr(a, attr) for attr in dir(a) if attr[0]!='_'})
        res['mod']= getattr(ns.get(a.text, None), '__module__', None)
        res['rank'] = _rank(res, s=code)
        return res
    return [_c(c) for c in cs if not c.text.startswith('__')]

# %% ../nbs/00_core.ipynb
def _signatures(ns, s, line, col):
    ctx = Interpreter(s, [ns]).get_signatures(line, col)
    if not ctx: ctx = jscript(s).get_signatures(line, col)
    return ctx

@patch
def sig_help(self:InteractiveShell, code, line_no=None, col_no=None):
    ns = self.user_ns
    ctx = _signatures(ns, code, line=line_no, col=col_no)
    def _s(s): return {'label':s.description,'typ':s.type, 'mod':s.module_name, 'doc':s.docstring(),
                       'idx':s.index, 'params':[{'name':p.name} for p in s.params]}
    return [_s(opt) for opt in ctx]

# %% ../nbs/00_core.ipynb
@patch
def get_vars(self:InteractiveShell, vs:list):
    "Get variables from namespace."
    ns = self.user_ns
    return {v:ns[v] for v in vs if v in ns}

# %% ../nbs/00_core.ipynb
def _get_schema(ns: dict, t):
    "Check if tool `t` has errors."
    if t not in ns: return f"`{t}` not found. Did you run it?"
    try: return get_schema(ns[t])
    except Exception as e: return f"`{t}`: {e}."

@patch
def get_schemas(self:InteractiveShell, fs:list):
    "Get schemas from namespace."
    ns = self.user_ns
    return {f:_get_schema(ns,f) for f in fs}
