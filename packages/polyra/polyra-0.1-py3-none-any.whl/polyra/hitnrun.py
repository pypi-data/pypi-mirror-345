#contains code to sample from a polytope using the hit-and-run algorithm
import numpy as np
from tqdm import tqdm

usual_steps=1000
usual_rep=100

def hitnrun(A, b, x0, n=usual_steps, nrep=usual_rep, do_tqdm=False):
    """
    Hit-and-Run algorithm for generating uniform samples from the polytope
    {x : Ax <= b}. Code generated by ChatGPT, but heavily modified.

    Parameters
    ----------
    A : numpy.ndarray
        Matrix defining the polytope.
    b : numpy.ndarray
        Vector defining the polytope.
    x0 : numpy.ndarray
        Initial point in the polytope.
    n : int
        Number of samples to generate.
    nrep : int
        Number of samples per iteration. Use higher value to accelerate the generation of points.

    Returns
    -------
    numpy.ndarray
        Samples from the polytope.

    """
    dimension = int(A.shape[1])
    assert len(x0) == dimension, "Initial point must have the same dimension as the polytope."

    # Initialize the samples
    samples = np.zeros((n*nrep-(nrep-1), dimension))
    samples[0] = x0

    lasti=0

    loop=range(1, n)
    if do_tqdm:
        loop = tqdm(loop, desc="Hit-and-Run")

    # Generate samples
    for i in loop:
        # Generate a random direction
        d = np.random.randn(dimension)
        d /= np.linalg.norm(d)

        # Compute the bounds on the step size
        max_step = np.inf
        min_step = -np.inf
        for j in range(A.shape[0]):
            prod = A[j] @ d
            if prod > 0:
                max_step = min(max_step, (b[j] - A[j] @ samples[lasti]) / (A[j] @ d))
            elif prod < 0:
                min_step = max(min_step, (b[j] - A[j] @ samples[lasti]) / (A[j] @ d))

        max_step=min(max_step,1000000)
        min_step=max(min_step,-1000000)

        samples[lasti+1:lasti+nrep+1]=(samples[lasti][:,None]+d[:,None]*np.random.uniform(min_step, max_step,nrep)).T

        lasti+=nrep

    return samples




