import os
import re
from typing import Any, Dict, List, Optional, Tuple, Type, Union, cast
from pydantic import BaseModel, create_model
import yaml

from .models import (
    PromptYAML, 
    PromptDataModelYAML, 
    Metadata, 
    Prompt, 
    PromptDataModel,
    PromptYAMLBase,)
import glob

class PromptHub:
    """
    Loads structured YAML files into dynamic Pydantic models.
    
    Features:
    - Environment-aware file resolution
    - Supports both basic prompt and model prompt types
    - Dynamic field expansion using Pydantic's `create_model`
    
    Args:
        base (str): Base path to prompt files.
        environment (str, optional): Environment folder inside base.
        common (str, optional): Shared folder inside base.
    """
    def __init__(self, base: str, environment: Optional[str] = None, common: Optional[str] = None):
        self.base = base
        self.env = environment
        self.common = common
    
    def _ensure_yaml_ext(self, name: str, default_ext: str = ".yaml") -> str:
        if name.endswith((".yaml", ".yml")):
            return name
        return f"{name}{default_ext}"
    
    def _get_path_candidates(self, file_name: str) -> List[str]:
        paths: List[str] = []
        if self.env:
            paths.append(os.path.join(self.base, self.env, file_name))
        if self.common:
            paths.append(os.path.join(self.base, self.common, file_name))
        paths.append(os.path.join(self.base, file_name))
        return paths

    def load_yml(self, file_name: str) -> dict:
        """
        Loads a YAML file and returns its contents as a dictionary.
        Args:
            file_name (str): The name of the YAML file to load.
        Returns:
            dict: The contents of the YAML file as a dictionary.
        Raises:
            ValueError: If the YAML file contains invalid syntax.
            FileNotFoundError: If the specified file is not found in any of the 
                               candidate paths.
        Notes:
            This method searches for the file in multiple candidate paths 
            generated by the `_get_path_candidates` method. The first valid 
            YAML file found is loaded and returned.
        """

        paths = self._get_path_candidates(file_name)
        for path in paths:
            if os.path.exists(path):
                try:
                    with open(path, 'r') as f:
                        return yaml.safe_load(f)
                except yaml.YAMLError as e:
                    raise ValueError(f"Invalid YAML in file '{path}': {e}")
        raise FileNotFoundError(f"Prompt file '{file_name}' not found. Searched in: {paths}")
    
    def load_prompt(self, prompt_name: str, expand_prompts: bool = True) -> Union[PromptYAML, type[PromptYAMLBase]]:
        """
        Args:
            prompt_name (str): The name of the prompt to load. The file extension will be ensured to be `.yml`.
            expand_prompts (bool, optional): If True, dynamically builds and returns a model representation 
                of the prompt. Defaults to True.
        Returns:
            Union[PromptYAML, type[PromptYAMLBase]]: The loaded prompt data. If `expand_prompts` is True, 
                a dynamically built model is returned. Otherwise, a `PromptYAML` object is returned.
        Raises:
            ValueError: If the metadata is missing in the prompt file.
            ValueError: If the metadata type is not "prompt".
            ValueError: If no prompts are found in the prompt file.
        """
        data =  self.load_yml(self._ensure_yaml_ext(prompt_name))
        
        metadata = data.get("metadata", {})
        if not metadata:
            raise ValueError("Metadata not found in the prompt file.")
        if metadata.get("type") != "prompt":
            raise ValueError(f"Invalid prompt type: {metadata.get('type')}")
        if not data.get("prompts"):
            raise ValueError("No prompts found in the prompt file.")
        
        if expand_prompts:
            return self._build_dynamic_model(data, Prompt)
        
        _data = PromptYAML(**data)
        return _data
    
    def load_model_prompt(self, model_prompt: str, expand_prompts: bool = True) -> Union[PromptDataModelYAML, type[PromptYAMLBase]]:
        """
        Loads a model prompt from a YAML file and validates its structure.
        Args:
            model_prompt (str): The file path to the YAML file containing the model prompt.
            expand_prompts (bool, optional): If True, dynamically builds and returns a 
                PromptDataModel instance. If False, returns a PromptDataModelYAML instance. 
                Defaults to True.
        Returns:
            Union[PromptDataModelYAML, type[PromptYAMLBase]]: The loaded and validated 
            prompt data, either as a dynamically built model or a static YAML model.
        Raises:
            ValueError: If the metadata is missing from the YAML file.
            ValueError: If the metadata type is not "model_prompt".
            ValueError: If no prompts are found in the YAML file.
        """

        data = self.load_yml(self._ensure_yaml_ext(model_prompt))
        
        metadata = data.get("metadata", {})
        if not metadata:
            raise ValueError("Metadata not found in the prompt file.")
        if metadata.get("type") != "model_prompt":
            raise ValueError(f"Invalid prompt type: {metadata.get('type')}")
        if not data.get("prompts"):
            raise ValueError("No prompts found in the prompt file.")
        
        if expand_prompts:
            return self._build_dynamic_model(data, PromptDataModel)
        
        _data = PromptDataModelYAML(**data)
        return _data

    def _build_dynamic_model(
        self, yaml_data: dict, model_type: Type[Union[PromptDataModel, Prompt]]
    ) -> Type[PromptYAMLBase]:
        prompt_fields: Dict[str, Tuple[Type[Any], Any]] = {}
        parsed_prompts = [model_type(**prompt) for prompt in yaml_data["prompts"]]
        prompt_fields = {
            _prompt.pid.replace(" ", "_").lower(): (model_type, _prompt)
            for _prompt in parsed_prompts
        }
        if model_type is PromptDataModel:
            prompt_fields["prompt_model_dict"] = (Dict[str, PromptDataModel], {
                _prompt.model_attribute_id: _prompt for _prompt in cast(List[PromptDataModel], parsed_prompts)
            })
        
        prompt_fields["prompt_dict"] = (Dict[str, Prompt], {
            _prompt.pid:_prompt   for _prompt in cast(List[Prompt], parsed_prompts)
        })
        
        metadata = Metadata(**yaml_data["metadata"])
        safe_name = re.sub(r'\W|^(?=\d)', '_', metadata.name).lower()
        DynamicModel = create_model(
            "prompt_" + safe_name,
            __base__=PromptYAMLBase,
            **prompt_fields,  # type: ignore
        )
        return DynamicModel(version=yaml_data.get("version", "1.0"), metadata=metadata)
        
    def list_prompts(self) -> List[str]:
        """
        List all available YAML prompt files from the path candidates.
        Only includes files with `.yaml` or `.yml` extensions.
        """
        seen = set()
        all_prompts = []

        # Check base path and its environment/common subfolders if present
        search_dirs = []
        if self.env:
            search_dirs.append(os.path.join(self.base, self.env))
        if self.common:
            search_dirs.append(os.path.join(self.base, self.common))
        search_dirs.append(self.base)  # Always include base

        for dir_path in search_dirs:
            if os.path.exists(dir_path):
                for file_path in glob.glob(os.path.join(dir_path, "*.yml")) + glob.glob(os.path.join(dir_path, "*.yaml")):
                    file_name = os.path.basename(file_path)
                    if file_name not in seen:
                        all_prompts.append(file_name)
                        seen.add(file_name)

        return all_prompts