import multiprocessing
import tornado.web
import zmq
from _typeshed import Incomplete
from meshcat.servers.zmqserver import StaticFileHandlerNoCache, WebSocketHandler, ZMQWebSocketBridge
from typing import Sequence
from zmq.eventloop.zmqstream import ZMQStream

DEFAULT_COMM_PORT: int
WAIT_COM_TIMEOUT: float

class MyFileHandler(StaticFileHandlerNoCache):
    default_path: Incomplete
    default_filename: Incomplete
    fallback_path: Incomplete
    def initialize(self, default_path: str, default_filename: str, fallback_path: str) -> None: ...
    def validate_absolute_path(self, root: str, absolute_path: str) -> str | None: ...

def handle_web(self, message: str) -> None: ...

class ZMQWebSocketIpythonBridge(ZMQWebSocketBridge):
    comm_pool: set[bytes]
    watch_pool: set[bytes]
    comm_msg: dict[bytes, str]
    websocket_msg: list[str]
    is_waiting_ready_msg: bool
    def __init__(self, zmq_url: str | None = None, comm_url: str | None = None, host: str = '127.0.0.1', port: int | None = None) -> None: ...
    def setup_comm(self, url: str) -> tuple[zmq.Socket, ZMQStream, str]: ...
    def make_app(self) -> tornado.web.Application: ...
    def wait_for_websockets(self) -> None: ...
    def watchdog_comm(self) -> None: ...
    def handle_zmq(self, frames: Sequence[bytes]) -> None: ...
    def handle_comm(self, frames: Sequence[bytes]) -> None: ...
    def forward_to_websockets(self, frames: Sequence[bytes]) -> None: ...
    def forward_to_comm(self, comm_id: bytes, message: bytes) -> None: ...
    def send_scene(self, websocket: WebSocketHandler | None = None, comm_id: bytes | None = None) -> None: ...

def start_meshcat_server(verbose: bool = False) -> tuple[multiprocessing.Process, str, str, str]: ...
def start_meshcat_server_standalone() -> None: ...
