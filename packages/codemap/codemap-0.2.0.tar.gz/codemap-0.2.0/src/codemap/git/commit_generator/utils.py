"""Linting functionality for commit messages."""

from __future__ import annotations

import logging
from typing import TYPE_CHECKING, Any, cast

from codemap.git.commit_linter import CommitLinter
from codemap.utils.cli_utils import loading_spinner

from .prompts import get_lint_prompt_template, prepare_lint_prompt
from .schemas import DiffChunk, DiffChunkData, adapt_chunk_access

if TYPE_CHECKING:
	from pathlib import Path

	from .generator import CommitMessageGenerator

logger = logging.getLogger(__name__)


def lint_commit_message(message: str, repo_root: Path) -> tuple[bool, list[str]]:
	"""
	Lint a commit message using the CommitLinter.

	Args:
	    message: Commit message to lint
	    repo_root: Repository root path

	Returns:
	    Tuple of (is_valid, list_of_messages)

	"""
	try:
		# Create a linter using the commit convention config from config_loader
		linter = CommitLinter(config_path=str(repo_root / ".codemap.yml"))
		return linter.lint(message)
	except Exception:
		logger.exception("Error during commit message linting")
		# Return valid=True to avoid blocking the process on linter errors
		return True, []


def clean_message_for_linting(message: str) -> str:
	"""
	Clean a message before linting.

	Args:
	    message: Message to clean

	Returns:
	    Cleaned message

	"""
	# Basic cleaning
	message = message.strip()

	# Remove markdown code blocks and inline code that might come from LLM
	message = message.replace("```", "").replace("`", "")

	# Remove common prefixes the LLM might add
	prefixes_to_remove = ["commit message:", "message:", "response:"]
	for prefix in prefixes_to_remove:
		if message.lower().startswith(prefix):
			message = message[len(prefix) :].strip()

	# Remove multi-line formatting by joining lines (keep message in single paragraph)
	return " ".join(message.splitlines())


def generate_message_with_linting(
	chunk: DiffChunk | DiffChunkData,
	generator: CommitMessageGenerator,
	repo_root: Path,
	max_retries: int = 3,
) -> tuple[str, bool, bool]:
	"""
	Generate a commit message with linting.

	Args:
	    chunk: Diff chunk to generate message for
	    generator: CommitMessageGenerator instance
	    repo_root: Repository root path
	    max_retries: Maximum number of regeneration retries for invalid messages

	Returns:
	    Tuple of (message, was_generated_by_llm, passed_linting)

	"""
	# First attempt to generate a message
	message, used_llm = generator.generate_message(chunk)

	# If not generated by LLM, skip linting
	if not used_llm:
		logger.debug("Message was not generated by LLM, skipping linting.")
		return message, used_llm, True

	# Clean the message before linting
	message = clean_message_for_linting(message)

	# Lint the message
	is_valid, lint_messages = lint_commit_message(message, repo_root)

	# If valid, return immediately
	if is_valid:
		logger.debug("Generated message passed linting checks.")
		return message, used_llm, True

	# Log the linting issues
	logger.warning("Commit message failed linting: %s", message)
	for lint_msg in lint_messages:
		logger.warning("Lint issue: %s", lint_msg)

	# Try to regenerate with more explicit instructions
	retries_left = max_retries
	regenerated_message = message

	# Add a loading spinner for regeneration
	while retries_left > 0 and not is_valid:
		retries_left -= 1

		try:
			# Create a prompt with the lint feedback
			chunk_dict = adapt_chunk_access(chunk)
			diff_content = cast("dict[str, Any]", chunk_dict).get("content", "")

			# Prepare the enhanced prompt for regeneration
			lint_template = get_lint_prompt_template()
			enhanced_prompt = prepare_lint_prompt(
				template=lint_template,
				diff_content=diff_content,
				file_info=generator.extract_file_info(chunk),
				convention=generator.get_commit_convention(),
				lint_messages=lint_messages,
			)

			# Use a loading spinner to show regeneration progress
			with loading_spinner(f"Commit message failed linting, regenerating (attempts left: {retries_left})..."):
				# Use the client to generate text with enhanced prompt
				result = generator.client.generate_text(prompt=enhanced_prompt, json_schema=None)
				regenerated_message = generator.format_json_to_commit_message(result)

			# Lint the regenerated message
			is_valid, lint_messages = lint_commit_message(regenerated_message, repo_root)

			if is_valid:
				logger.info("Successfully regenerated a valid commit message.")
				break

			logger.warning("Regenerated message still failed linting: %s", regenerated_message)
			for lint_msg in lint_messages:
				logger.warning("Lint issue: %s", lint_msg)

		except Exception:
			logger.exception("Error during message regeneration")
			# Break out of the loop on error
			break

	# If we exhausted retries or had an error, return the last message with linting status
	if not is_valid and retries_left == 0:
		logger.warning("Exhausted all regeneration attempts. Using the last generated message.")

	return regenerated_message, used_llm, is_valid
