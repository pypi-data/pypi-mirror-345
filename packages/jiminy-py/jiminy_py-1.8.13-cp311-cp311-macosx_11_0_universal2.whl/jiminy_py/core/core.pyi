from jiminy_py.core import AbstractConstraint as AbstractConstraint, AbstractController as AbstractController, AbstractMotor as AbstractMotor, AbstractSensor as AbstractSensor, BadControlFlow as BadControlFlow, BaseConstraint as BaseConstraint, BaseController as BaseController, BaseFunctionalController as BaseFunctionalController, ConstraintTree as ConstraintTree, ContactSensor as ContactSensor, CouplingForce as CouplingForce, CouplingForceVector as CouplingForceVector, DistanceConstraint as DistanceConstraint, EffortSensor as EffortSensor, EncoderSensor as EncoderSensor, Engine as Engine, ForceSensor as ForceSensor, FrameConstraint as FrameConstraint, FunctionalController as FunctionalController, GJKInitialGuess as GJKInitialGuess, HeightmapFunction as HeightmapFunction, HeightmapType as HeightmapType, ImpulseForce as ImpulseForce, ImpulseForceVector as ImpulseForceVector, ImuSensor as ImuSensor, JointConstraint as JointConstraint, JointModelType as JointModelType, LogicError as LogicError, LookupError as LookupError, Model as Model, NotImplementedError as NotImplementedError, OSError as OSError, PCG32 as PCG32, PeriodicFourierProcess as PeriodicFourierProcess, PeriodicGaussianProcess as PeriodicGaussianProcess, PeriodicPerlinProcess1D as PeriodicPerlinProcess1D, PeriodicPerlinProcess2D as PeriodicPerlinProcess2D, PeriodicPerlinProcess3D as PeriodicPerlinProcess3D, PeriodicTabularProcess as PeriodicTabularProcess, ProfileForce as ProfileForce, ProfileForceVector as ProfileForceVector, RandomPerlinProcess1D as RandomPerlinProcess1D, RandomPerlinProcess2D as RandomPerlinProcess2D, RandomPerlinProcess3D as RandomPerlinProcess3D, Robot as Robot, RobotState as RobotState, SensorMeasurementTree as SensorMeasurementTree, SimpleMotor as SimpleMotor, SphereConstraint as SphereConstraint, StepperState as StepperState, TimeStateBoolFunctor as TimeStateBoolFunctor, TimeStateForceFunctor as TimeStateForceFunctor, WheelConstraint as WheelConstraint
from typing import Any, overload

__raw_version__: str
__version__: str

def aba(*args, **kwargs): ...
def array_copyto(*args, **kwargs): ...
def build_geom_from_urdf(*args, **kwargs): ...
def build_models_from_urdf(*args, **kwargs): ...
def computeJMinvJt(*args, **kwargs): ...
def computeKineticEnergy(*args, **kwargs): ...
def crba(*args, **kwargs): ...
def discretize_heightmap(*args, **kwargs): ...
def get_frame_indices(*args, **kwargs): ...
def get_joint_indices(*args, **kwargs): ...
def get_joint_position_first_index(*args, **kwargs): ...
def get_joint_type(*args, **kwargs): ...
def interpolate_positions(*args, **kwargs): ...
def is_position_valid(*args, **kwargs): ...
def load_heightmap_from_binary(*args, **kwargs): ...
def load_robot_from_binary(*args, **kwargs): ...
def merge_heightmaps(*args, **kwargs): ...
def multi_array_copyto(*args, **kwargs): ...
def normal(*args, **kwargs): ...
def periodic_perlin_ground(*args, **kwargs): ...
def periodic_stairs_ground(*args, **kwargs): ...
def query_heightmap(*args, **kwargs): ...
def random_perlin_ground(*args, **kwargs): ...
def random_tile_ground(*args, **kwargs): ...
def rnea(*args, **kwargs): ...
def save_robot_to_binary(*args, **kwargs): ...
def seed(unsignedint) -> Any: ...
@overload
def sharedMemory(bool) -> Any: ...
@overload
def sharedMemory() -> Any: ...
def solveJMinvJtv(*args, **kwargs): ...
def sum_heightmaps(*args, **kwargs): ...
def unidirectional_periodic_perlin_ground(*args, **kwargs): ...
def unidirectional_random_perlin_ground(*args, **kwargs): ...
def uniform(*args, **kwargs): ...
