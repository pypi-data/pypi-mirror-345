"""This file was code generated by turms. If you want to change the contents of this file, you should make sure to add the MergeProcessor to your config will keep your changes when you re-run turms)."""

from typing_extensions import Literal
from typing import (
    Any,
    Union,
    List,
    Iterator,
    Tuple,
    AsyncIterator,
    Optional,
    Annotated,
    Iterable,
)
from datetime import datetime
from rekuest_next.funcs import subscribe, execute, asubscribe, aexecute
from rekuest_next.scalars import (
    Args,
    Identifier,
    ActionHash,
    InstanceId,
    ValidatorFunction,
    SearchQuery,
)
from rekuest_next.traits.ports import (
    ValidatorInputTrait,
    DefinitionInputTrait,
    PortTrait,
    ReturnWidgetInputTrait,
    WidgetInputTrait,
)
from enum import Enum
from pydantic import BaseModel, Field, ConfigDict
from rekuest_next.rath import RekuestNextRath
from rath.scalars import ID


class AssignWidgetKind(str, Enum):
    """The kind of assign widget."""

    SEARCH = "SEARCH"
    CHOICE = "CHOICE"
    SLIDER = "SLIDER"
    CUSTOM = "CUSTOM"
    STRING = "STRING"
    STATE_CHOICE = "STATE_CHOICE"


class PortKind(str, Enum):
    """The kind of port."""

    INT = "INT"
    STRING = "STRING"
    STRUCTURE = "STRUCTURE"
    LIST = "LIST"
    BOOL = "BOOL"
    DICT = "DICT"
    FLOAT = "FLOAT"
    DATE = "DATE"
    UNION = "UNION"
    ENUM = "ENUM"
    MODEL = "MODEL"
    MEMORY_STRUCTURE = "MEMORY_STRUCTURE"


class EffectKind(str, Enum):
    """The kind of effect."""

    MESSAGE = "MESSAGE"
    HIDE = "HIDE"
    CUSTOM = "CUSTOM"


class ReturnWidgetKind(str, Enum):
    """The kind of return widget."""

    CHOICE = "CHOICE"
    CUSTOM = "CUSTOM"


class UIChildKind(str, Enum):
    """No documentation"""

    GRID = "GRID"
    SPLIT = "SPLIT"
    RESERVATION = "RESERVATION"
    STATE = "STATE"


class Ordering(str, Enum):
    """No documentation"""

    ASC = "ASC"
    DESC = "DESC"


class ActionKind(str, Enum):
    """The kind of action."""

    FUNCTION = "FUNCTION"
    GENERATOR = "GENERATOR"


class DemandKind(str, Enum):
    """No documentation"""

    ARGS = "ARGS"
    RETURNS = "RETURNS"


class AssignationEventKind(str, Enum):
    """The event kind of the assignationevent"""

    BOUND = "BOUND"
    QUEUED = "QUEUED"
    ASSIGN = "ASSIGN"
    PROGRESS = "PROGRESS"
    DISCONNECTED = "DISCONNECTED"
    YIELD = "YIELD"
    DONE = "DONE"
    LOG = "LOG"
    CANCELING = "CANCELING"
    CANCELLED = "CANCELLED"
    INTERUPTING = "INTERUPTING"
    INTERUPTED = "INTERUPTED"
    ERROR = "ERROR"
    CRITICAL = "CRITICAL"


class LogLevel(str, Enum):
    """No documentation"""

    DEBUG = "DEBUG"
    INFO = "INFO"
    ERROR = "ERROR"
    WARN = "WARN"
    CRITICAL = "CRITICAL"


class PanelKind(str, Enum):
    """No documentation"""

    STATE = "STATE"
    ASSIGN = "ASSIGN"


class HookKind(str, Enum):
    """No documentation"""

    CLEANUP = "CLEANUP"
    INIT = "INIT"


class StrFilterLookup(BaseModel):
    """No documentation"""

    exact: Optional[str] = None
    i_exact: Optional[str] = Field(alias="iExact", default=None)
    contains: Optional[str] = None
    i_contains: Optional[str] = Field(alias="iContains", default=None)
    in_list: Optional[Tuple[str, ...]] = Field(alias="inList", default=None)
    gt: Optional[str] = None
    gte: Optional[str] = None
    lt: Optional[str] = None
    lte: Optional[str] = None
    starts_with: Optional[str] = Field(alias="startsWith", default=None)
    i_starts_with: Optional[str] = Field(alias="iStartsWith", default=None)
    ends_with: Optional[str] = Field(alias="endsWith", default=None)
    i_ends_with: Optional[str] = Field(alias="iEndsWith", default=None)
    range: Optional[Tuple[str, ...]] = None
    is_null: Optional[bool] = Field(alias="isNull", default=None)
    regex: Optional[str] = None
    i_regex: Optional[str] = Field(alias="iRegex", default=None)
    n_exact: Optional[str] = Field(alias="nExact", default=None)
    n_i_exact: Optional[str] = Field(alias="nIExact", default=None)
    n_contains: Optional[str] = Field(alias="nContains", default=None)
    n_i_contains: Optional[str] = Field(alias="nIContains", default=None)
    n_in_list: Optional[Tuple[str, ...]] = Field(alias="nInList", default=None)
    n_gt: Optional[str] = Field(alias="nGt", default=None)
    n_gte: Optional[str] = Field(alias="nGte", default=None)
    n_lt: Optional[str] = Field(alias="nLt", default=None)
    n_lte: Optional[str] = Field(alias="nLte", default=None)
    n_starts_with: Optional[str] = Field(alias="nStartsWith", default=None)
    n_i_starts_with: Optional[str] = Field(alias="nIStartsWith", default=None)
    n_ends_with: Optional[str] = Field(alias="nEndsWith", default=None)
    n_i_ends_with: Optional[str] = Field(alias="nIEndsWith", default=None)
    n_range: Optional[Tuple[str, ...]] = Field(alias="nRange", default=None)
    n_is_null: Optional[bool] = Field(alias="nIsNull", default=None)
    n_regex: Optional[str] = Field(alias="nRegex", default=None)
    n_i_regex: Optional[str] = Field(alias="nIRegex", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class OffsetPaginationInput(BaseModel):
    """No documentation"""

    offset: int
    limit: int
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class PortDemandInput(BaseModel):
    """The input for creating a port demand."""

    kind: DemandKind
    "The kind of the demand. You can ask for args or returns"
    matches: Optional[Tuple["PortMatchInput", ...]] = None
    "The matches of the demand. "
    force_length: Optional[int] = Field(alias="forceLength", default=None)
    "Require that the action has a specific number of ports. This is used to identify the demand in the system."
    force_non_nullable_length: Optional[int] = Field(
        alias="forceNonNullableLength", default=None
    )
    "Require that the action has a specific number of non-nullable ports. This is used to identify the demand in the system."
    force_structure_length: Optional[int] = Field(
        alias="forceStructureLength", default=None
    )
    "Require that the action has a specific number of structure ports. This is used to identify the demand in the system."
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class PortMatchInput(BaseModel):
    """The input for creating a port match."""

    at: Optional[int] = None
    "The index of the port to match. "
    key: Optional[str] = None
    "The key of the port to match."
    kind: Optional[PortKind] = None
    "The kind of the port to match. "
    identifier: Optional[str] = None
    "The identifier of the port to match. "
    nullable: Optional[bool] = None
    "Whether the port is nullable. "
    children: Optional[Tuple["PortMatchInput", ...]] = None
    "The matches for the children of the port to match. "
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ActionOrder(BaseModel):
    """No documentation"""

    defined_at: Optional[Ordering] = Field(alias="definedAt", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ShortcutFilter(BaseModel):
    """No documentation"""

    search: Optional[str] = None
    ids: Optional[Tuple[ID, ...]] = None
    demands: Optional[Tuple[PortDemandInput, ...]] = None
    toolbox: Optional[ID] = None
    and_: Optional["ShortcutFilter"] = Field(alias="AND", default=None)
    or_: Optional["ShortcutFilter"] = Field(alias="OR", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ShortcutOrder(BaseModel):
    """No documentation"""

    name: Optional[Ordering] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ToolboxFilter(BaseModel):
    """No documentation"""

    search: Optional[str] = None
    name: Optional[StrFilterLookup] = None
    ids: Optional[Tuple[ID, ...]] = None
    and_: Optional["ToolboxFilter"] = Field(alias="AND", default=None)
    or_: Optional["ToolboxFilter"] = Field(alias="OR", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ToolboxOrder(BaseModel):
    """No documentation"""

    name: Optional[Ordering] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreateImplementationInput(BaseModel):
    """The input for creating a implementation."""

    implementation: "ImplementationInput"
    instance_id: InstanceId = Field(alias="instanceId")
    extension: str
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ImplementationInput(BaseModel):
    """A implementation is a blueprint for a action. It is composed of a definition, a list of dependencies, and a list of params."""

    definition: "DefinitionInput"
    dependencies: Tuple["DependencyInput", ...]
    interface: Optional[str] = None
    params: Optional[Any] = None
    dynamic: bool
    logo: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DefinitionInput(DefinitionInputTrait, BaseModel):
    """A definition

    Definitions are the building implementation for Actions and provide the
    information needed to create a action. They are primarly composed of a name,
    a description, and a list of ports.

    Definitions provide a protocol of input and output, and do not contain
    any information about the actual implementation of the action ( this is handled
    by a implementation that implements a action).




    """

    description: Optional[str] = None
    "The description of the definition. This is the text that is displayed in the UI"
    collections: Tuple[str, ...]
    "The collections of the definition. This is used to group definitions together in the UI"
    name: str
    "The name of the actions. This is used to uniquely identify the definition"
    stateful: bool
    "Whether the definition is stateful or not. If the definition is stateful, it can be used to create a stateful action. If the definition is not stateful, it cannot be used to create a stateful action"
    port_groups: Tuple["PortGroupInput", ...] = Field(alias="portGroups")
    "The port groups of the definition. This is used to group ports together in the UI"
    args: Tuple["PortInput", ...]
    "The args of the definition. This is the input ports of the definition"
    returns: Tuple["PortInput", ...]
    "The returns of the definition. This is the output ports of the definition"
    kind: ActionKind
    "The kind of the definition. This is the type of the definition. Can be either a function or a generator"
    is_test_for: Tuple[str, ...] = Field(alias="isTestFor")
    "The tests for the definition. This is used to group definitions together in the UI"
    interfaces: Tuple[str, ...]
    "The interfaces of the definition. This is used to group definitions together in the UI"
    is_dev: bool = Field(alias="isDev")
    "Whether the definition is a dev definition or not. If the definition is a dev definition, it can be used to create a dev action. If the definition is not a dev definition, it cannot be used to create a dev action"
    logo: Optional[str] = None
    "The logo of the definition. This is used to display the logo in the UI"
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class PortGroupInput(BaseModel):
    """A Port Group is a group of ports that are related to each other. It is used to group ports together in the UI and provide a better user experience."""

    key: str
    "The key of the port group. This is used to uniquely identify the port group"
    title: Optional[str] = None
    description: Optional[str] = None
    effects: Optional[Tuple["EffectInput", ...]] = None
    ports: Optional[Tuple[str, ...]] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class EffectInput(BaseModel):
    """
                 An effect is a way to modify a port based on a condition. For example,
    you could have an effect that sets a port to null if another port is null.

    Or, you could have an effect that hides the port if another port meets a condition.
    E.g when the user selects a certain option in a dropdown, another port is hidden.


    """

    function: ValidatorFunction
    dependencies: Optional[Tuple[str, ...]] = None
    message: Optional[str] = None
    kind: EffectKind
    hook: Optional[str] = None
    ward: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class PortInput(PortTrait, BaseModel):
    """Port

    A Port is a single input or output of a action. It is composed of a key and a kind
    which are used to uniquely identify the port.

    If the Port is a structure, we need to define a identifier and scope,
    Identifiers uniquely identify a specific type of model for the scopes (e.g
    all the ports that have the identifier "@mikro/image" are of the same type, and
    are hence compatible with each other). Scopes are used to define in which context
    the identifier is valid (e.g. a port with the identifier "@mikro/image" and the
    scope "local", can only be wired to other ports that have the same identifier and
    are running in the same app). Global ports are ports that have the scope "global",
    and can be wired to any other port that has the same identifier, as there exists a
    mechanism to resolve and retrieve the object for each app. Please check the rekuest
    documentation for more information on how this works.


    """

    validators: Optional[Tuple["ValidatorInput", ...]] = None
    key: str
    label: Optional[str] = None
    kind: PortKind
    description: Optional[str] = None
    identifier: Optional[str] = None
    nullable: bool
    effects: Optional[Tuple[EffectInput, ...]] = None
    default: Optional[Any] = None
    children: Optional[Tuple["PortInput", ...]] = None
    choices: Optional[Tuple["ChoiceInput", ...]] = None
    assign_widget: Optional["AssignWidgetInput"] = Field(
        alias="assignWidget", default=None
    )
    return_widget: Optional["ReturnWidgetInput"] = Field(
        alias="returnWidget", default=None
    )
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ValidatorInput(ValidatorInputTrait, BaseModel):
    """
    A validating function for a port. Can specify a function that will run when validating values of the port.
    If outside dependencies are needed they need to be specified in the dependencies field. With the .. syntax
    when transversing the tree of ports.

    """

    function: ValidatorFunction
    dependencies: Optional[Tuple[str, ...]] = None
    label: Optional[str] = None
    error_message: Optional[str] = Field(alias="errorMessage", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ChoiceInput(BaseModel):
    """
    A choice is a value that can be selected in a dropdown.

    It is composed of a value, a label, and a description. The value is the
    value that is returned when the choice is selected. The label is the
    text that is displayed in the dropdown. The description is the text
    that is displayed when the user hovers over the choice.

    """

    value: Any
    label: str
    image: Optional[str] = None
    description: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class AssignWidgetInput(WidgetInputTrait, BaseModel):
    """No documentation"""

    as_paragraph: Optional[bool] = Field(alias="asParagraph", default=None)
    "Whether to display the input as a paragraph or not. This is used for text inputs and dropdowns"
    kind: AssignWidgetKind
    query: Optional[SearchQuery] = None
    choices: Optional[Tuple[ChoiceInput, ...]] = None
    min: Optional[float] = None
    max: Optional[float] = None
    step: Optional[float] = None
    placeholder: Optional[str] = None
    hook: Optional[str] = None
    ward: Optional[str] = None
    fallback: Optional["AssignWidgetInput"] = None
    filters: Optional[Tuple[PortInput, ...]] = None
    dependencies: Optional[Tuple[str, ...]] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ReturnWidgetInput(ReturnWidgetInputTrait, BaseModel):
    """A Return Widget is a UI element that is used to display the value of a port.

    Return Widgets get displayed both if we show the return values of an assignment,
    but also when we inspect the given arguments of a previous run task. Their primary
    usecase is to adequately display the value of a port, in a user readable way.

    Return Widgets are often overwriten by the underlying UI framework (e.g. Orkestrator)
    to provide a better user experience. For example, a return widget that displays a
    date could be overwriten to display a calendar widget.

    Return Widgets provide more a way to customize this overwriten behavior.

    """

    kind: ReturnWidgetKind
    query: Optional[SearchQuery] = None
    choices: Optional[Tuple[ChoiceInput, ...]] = None
    min: Optional[int] = None
    max: Optional[int] = None
    step: Optional[int] = None
    placeholder: Optional[str] = None
    hook: Optional[str] = None
    ward: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class DependencyInput(BaseModel):
    """A dependency for a implementation. By defining dependencies, you can
    create a dependency graph for your implementations and actions"""

    hash: Optional[ActionHash] = None
    reference: Optional[str] = None
    binds: Optional["BindsInput"] = None
    optional: bool
    viable_instances: Optional[int] = Field(alias="viableInstances", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class BindsInput(BaseModel):
    """No documentation"""

    implementations: Optional[Tuple[str, ...]] = None
    clients: Optional[Tuple[str, ...]] = None
    desired_instances: int = Field(alias="desiredInstances")
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class SetExtensionImplementationsInput(BaseModel):
    """The input for setting extension implementations."""

    implementations: Tuple[ImplementationInput, ...]
    "The implementations to set. This is used to identify the implementations in the system."
    instance_id: InstanceId = Field(alias="instanceId")
    extension: str
    run_cleanup: bool = Field(alias="runCleanup")
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class AssignInput(BaseModel):
    """The input for assigning args to a action."""

    instance_id: InstanceId = Field(alias="instanceId")
    action: Optional[ID] = None
    implementation: Optional[ID] = None
    agent: Optional[ID] = None
    action_hash: Optional[ActionHash] = Field(alias="actionHash", default=None)
    reservation: Optional[ID] = None
    interface: Optional[str] = None
    hooks: Optional[Tuple["HookInput", ...]] = None
    args: Args
    reference: Optional[str] = None
    parent: Optional[ID] = None
    cached: bool
    log: bool
    ephemeral: bool
    is_hook: Optional[bool] = Field(alias="isHook", default=None)
    step: Optional[bool] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class HookInput(BaseModel):
    """A hook is a function that is called when a action has reached a specific lifecycle point. Hooks are jsut actions that take an assignation as input and return a value."""

    kind: HookKind
    hash: ActionHash
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CancelInput(BaseModel):
    """The input for canceling an assignation."""

    assignation: ID
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class InterruptInput(BaseModel):
    """The input for interrupting an assignation."""

    assignation: ID
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ReserveInput(BaseModel):
    """The input for reserving a action."""

    reference: Optional[str] = None
    instance_id: InstanceId = Field(alias="instanceId")
    action: Optional[ID] = None
    implementation: Optional[ID] = None
    title: Optional[str] = None
    hash: Optional[ActionHash] = None
    binds: Optional[BindsInput] = None
    assignation_id: Optional[ID] = Field(alias="assignationId", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class UnreserveInput(BaseModel):
    """No documentation"""

    reservation: ID
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class AgentInput(BaseModel):
    """No documentation"""

    instance_id: InstanceId = Field(alias="instanceId")
    "The instance ID of the agent. This is used to identify the agent in the system."
    name: Optional[str] = None
    "The name of the agent. This is used to identify the agent in the system."
    extensions: Optional[Tuple[str, ...]] = None
    "The extensions of the agent. This is used to identify the agent in the system."
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreateTestCaseInput(BaseModel):
    """No documentation"""

    action: ID
    tester: ID
    description: Optional[str] = None
    name: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreateTestResultInput(BaseModel):
    """No documentation"""

    case: ID
    tester: ID
    implementation: ID
    passed: bool
    result: Optional[str] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class UnshelveMemoryDrawerInput(BaseModel):
    """No documentation"""

    instance_id: InstanceId = Field(alias="instanceId")
    "The instance ID of the agent. This is used to identify the agent in the system."
    resource_id: str = Field(alias="resourceId")
    "The resource ID of the drawer."
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreateDashboardInput(BaseModel):
    """The input for creating a dashboard."""

    name: Optional[str] = None
    panels: Optional[Tuple[ID, ...]] = None
    tree: Optional["UITreeInput"] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class UITreeInput(BaseModel):
    """No documentation"""

    child: "UIChildInput"
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class UIChildInput(BaseModel):
    """No documentation"""

    state: Optional[str] = None
    kind: UIChildKind
    hidden: Optional[bool] = None
    children: Optional[Tuple["UIChildInput", ...]] = None
    left: Optional["UIChildInput"] = None
    right: Optional["UIChildInput"] = None
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreateStateSchemaInput(BaseModel):
    """The input for creating a state schema."""

    state_schema: "StateSchemaInput" = Field(alias="stateSchema")
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class StateSchemaInput(BaseModel):
    """The input for creating a state schema."""

    ports: Tuple[PortInput, ...]
    name: str
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreatePanelInput(BaseModel):
    """No documentation"""

    name: str
    kind: PanelKind
    state: Optional[ID] = None
    state_key: Optional[str] = Field(alias="stateKey", default=None)
    reservation: Optional[ID] = None
    instance_id: Optional[InstanceId] = Field(alias="instanceId", default=None)
    state_accessors: Optional[Tuple[str, ...]] = Field(
        alias="stateAccessors", default=None
    )
    interface: Optional[str] = None
    args: Optional[Args] = None
    submit_on_change: Optional[bool] = Field(alias="submitOnChange", default=None)
    submit_on_load: Optional[bool] = Field(alias="submitOnLoad", default=None)
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class SetStateInput(BaseModel):
    """The input for setting a state schema."""

    state_schema: ID = Field(alias="stateSchema")
    instance_id: InstanceId = Field(alias="instanceId")
    value: Args
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class UpdateStateInput(BaseModel):
    """The input for updating a state schema."""

    state_schema: ID = Field(alias="stateSchema")
    instance_id: InstanceId = Field(alias="instanceId")
    patches: Tuple[Args, ...]
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CreateShortcutInput(BaseModel):
    """The input for creating a shortcut."""

    toolbox: Optional[ID] = None
    "The toolbox ID to create the shortcut in. If not provided, the shortcut will be created in the default toolbox."
    name: str
    description: Optional[str] = None
    action: ID
    implementation: Optional[ID] = None
    args: Args
    allow_quick: bool = Field(alias="allowQuick")
    use_returns: bool = Field(alias="useReturns")
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class CollectInput(BaseModel):
    """The input for collecting a shelved item in a drawer."""

    drawers: Tuple[ID, ...]
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class ShelveInMemoryDrawerInput(BaseModel):
    """No documentation"""

    instance_id: InstanceId = Field(alias="instanceId")
    "The instance ID of the agent. This is used to identify the agent in the system."
    identifier: Identifier
    "The identifier of the drawer. This is used to identify the drawer in the system."
    resource_id: str = Field(alias="resourceId")
    "The resource ID of the drawer."
    label: Optional[str] = None
    "The label of the drawer. This is used to identify the drawer in the system."
    description: Optional[str] = None
    "The description of the drawer. This is used to identify the drawer in the system."
    model_config = ConfigDict(
        frozen=True, extra="forbid", populate_by_name=True, use_enum_values=True
    )


class TestCaseAction(BaseModel):
    """No documentation"""

    typename: Literal["Action"] = Field(
        alias="__typename", default="Action", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class TestCase(BaseModel):
    """No documentation"""

    typename: Literal["TestCase"] = Field(
        alias="__typename", default="TestCase", exclude=True
    )
    id: ID
    action: TestCaseAction
    is_benchmark: bool = Field(alias="isBenchmark")
    description: str
    name: str
    model_config = ConfigDict(frozen=True)


class TestResultCase(BaseModel):
    """No documentation"""

    typename: Literal["TestCase"] = Field(
        alias="__typename", default="TestCase", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class TestResult(BaseModel):
    """No documentation"""

    typename: Literal["TestResult"] = Field(
        alias="__typename", default="TestResult", exclude=True
    )
    id: ID
    case: TestResultCase
    passed: bool
    model_config = ConfigDict(frozen=True)


class ChildPortNestedChildren(PortTrait, BaseModel):
    """No documentation"""

    typename: Literal["Port"] = Field(alias="__typename", default="Port", exclude=True)
    identifier: Optional[Identifier] = Field(default=None)
    nullable: bool
    kind: PortKind
    model_config = ConfigDict(frozen=True)


class ChildPortNested(PortTrait, BaseModel):
    """No documentation"""

    typename: Literal["Port"] = Field(alias="__typename", default="Port", exclude=True)
    key: str
    kind: PortKind
    children: Optional[Tuple[ChildPortNestedChildren, ...]] = Field(default=None)
    identifier: Optional[Identifier] = Field(default=None)
    nullable: bool
    default: Optional[Any] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class CustomEffect(BaseModel):
    """No documentation"""

    typename: Literal["CustomEffect"] = Field(
        alias="__typename", default="CustomEffect", exclude=True
    )
    kind: EffectKind
    hook: str
    ward: str
    model_config = ConfigDict(frozen=True)


class MessageEffect(BaseModel):
    """No documentation"""

    typename: Literal["MessageEffect"] = Field(
        alias="__typename", default="MessageEffect", exclude=True
    )
    kind: EffectKind
    message: str
    model_config = ConfigDict(frozen=True)


class StringAssignWidget(BaseModel):
    """No documentation"""

    typename: Literal["StringAssignWidget"] = Field(
        alias="__typename", default="StringAssignWidget", exclude=True
    )
    kind: AssignWidgetKind
    placeholder: str
    as_paragraph: bool = Field(alias="asParagraph")
    model_config = ConfigDict(frozen=True)


class SliderAssignWidget(BaseModel):
    """No documentation"""

    typename: Literal["SliderAssignWidget"] = Field(
        alias="__typename", default="SliderAssignWidget", exclude=True
    )
    kind: AssignWidgetKind
    min: Optional[float] = Field(default=None)
    max: Optional[float] = Field(default=None)
    step: Optional[float] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class SearchAssignWidget(BaseModel):
    """No documentation"""

    typename: Literal["SearchAssignWidget"] = Field(
        alias="__typename", default="SearchAssignWidget", exclude=True
    )
    kind: AssignWidgetKind
    query: str
    ward: str
    dependencies: Optional[Tuple[str, ...]] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class CustomAssignWidget(BaseModel):
    """No documentation"""

    typename: Literal["CustomAssignWidget"] = Field(
        alias="__typename", default="CustomAssignWidget", exclude=True
    )
    ward: str
    hook: str
    model_config = ConfigDict(frozen=True)


class ChoiceAssignWidgetChoices(BaseModel):
    """No documentation"""

    typename: Literal["Choice"] = Field(
        alias="__typename", default="Choice", exclude=True
    )
    value: str
    label: str
    description: Optional[str] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class ChoiceAssignWidget(BaseModel):
    """No documentation"""

    typename: Literal["ChoiceAssignWidget"] = Field(
        alias="__typename", default="ChoiceAssignWidget", exclude=True
    )
    kind: AssignWidgetKind
    choices: Optional[Tuple[ChoiceAssignWidgetChoices, ...]] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class CustomReturnWidget(BaseModel):
    """No documentation"""

    typename: Literal["CustomReturnWidget"] = Field(
        alias="__typename", default="CustomReturnWidget", exclude=True
    )
    kind: ReturnWidgetKind
    hook: str
    ward: str
    model_config = ConfigDict(frozen=True)


class ChoiceReturnWidgetChoices(BaseModel):
    """No documentation"""

    typename: Literal["Choice"] = Field(
        alias="__typename", default="Choice", exclude=True
    )
    label: str
    value: str
    description: Optional[str] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class ChoiceReturnWidget(BaseModel):
    """No documentation"""

    typename: Literal["ChoiceReturnWidget"] = Field(
        alias="__typename", default="ChoiceReturnWidget", exclude=True
    )
    choices: Optional[Tuple[ChoiceReturnWidgetChoices, ...]] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class AgentRegistryApp(BaseModel):
    """No documentation"""

    typename: Literal["App"] = Field(alias="__typename", default="App", exclude=True)
    id: ID
    model_config = ConfigDict(frozen=True)


class AgentRegistryUser(BaseModel):
    """No documentation"""

    typename: Literal["User"] = Field(alias="__typename", default="User", exclude=True)
    id: ID
    model_config = ConfigDict(frozen=True)


class AgentRegistry(BaseModel):
    """No documentation"""

    typename: Literal["Registry"] = Field(
        alias="__typename", default="Registry", exclude=True
    )
    app: AgentRegistryApp
    user: AgentRegistryUser
    model_config = ConfigDict(frozen=True)


class AgentMemoryshelve(BaseModel):
    """No documentation"""

    typename: Literal["MemoryShelve"] = Field(
        alias="__typename", default="MemoryShelve", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class Agent(BaseModel):
    """No documentation"""

    typename: Literal["Agent"] = Field(
        alias="__typename", default="Agent", exclude=True
    )
    id: ID
    registry: AgentRegistry
    memory_shelve: Optional[AgentMemoryshelve] = Field(
        default=None, alias="memoryShelve"
    )
    model_config = ConfigDict(frozen=True)


class PanelState(BaseModel):
    """No documentation"""

    typename: Literal["State"] = Field(
        alias="__typename", default="State", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class PanelReservation(BaseModel):
    """No documentation"""

    typename: Literal["Reservation"] = Field(
        alias="__typename", default="Reservation", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class Panel(BaseModel):
    """No documentation"""

    typename: Literal["Panel"] = Field(
        alias="__typename", default="Panel", exclude=True
    )
    id: ID
    kind: PanelKind
    state: Optional[PanelState] = Field(default=None)
    reservation: Optional[PanelReservation] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class ReservationAction(BaseModel):
    """No documentation"""

    typename: Literal["Action"] = Field(
        alias="__typename", default="Action", exclude=True
    )
    id: ID
    hash: ActionHash
    model_config = ConfigDict(frozen=True)


class ReservationWaiter(BaseModel):
    """No documentation"""

    typename: Literal["Waiter"] = Field(
        alias="__typename", default="Waiter", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class Reservation(BaseModel):
    """No documentation"""

    typename: Literal["Reservation"] = Field(
        alias="__typename", default="Reservation", exclude=True
    )
    id: ID
    action: ReservationAction
    waiter: ReservationWaiter
    reference: str
    updated_at: datetime = Field(alias="updatedAt")
    model_config = ConfigDict(frozen=True)


class DashboardUitreeChildBase(BaseModel):
    """No documentation"""

    model_config = ConfigDict(frozen=True)


class DashboardUitreeChildBaseUIGrid(DashboardUitreeChildBase, BaseModel):
    """No documentation"""

    typename: Literal["UIGrid"] = Field(
        alias="__typename", default="UIGrid", exclude=True
    )


class DashboardUitreeChildBaseUISplit(DashboardUitreeChildBase, BaseModel):
    """No documentation"""

    typename: Literal["UISplit"] = Field(
        alias="__typename", default="UISplit", exclude=True
    )


class DashboardUitreeChildBaseUIState(DashboardUitreeChildBase, BaseModel):
    """No documentation"""

    typename: Literal["UIState"] = Field(
        alias="__typename", default="UIState", exclude=True
    )


class DashboardUitreeChildBaseCatchAll(DashboardUitreeChildBase, BaseModel):
    """Catch all class for DashboardUitreeChildBase"""

    typename: str = Field(alias="__typename", exclude=True)


class DashboardUitree(BaseModel):
    """No documentation"""

    typename: Literal["UITree"] = Field(
        alias="__typename", default="UITree", exclude=True
    )
    child: Union[
        Annotated[
            Union[
                DashboardUitreeChildBaseUIGrid,
                DashboardUitreeChildBaseUISplit,
                DashboardUitreeChildBaseUIState,
            ],
            Field(discriminator="typename"),
        ],
        DashboardUitreeChildBaseCatchAll,
    ]
    model_config = ConfigDict(frozen=True)


class DashboardPanelsState(BaseModel):
    """No documentation"""

    typename: Literal["State"] = Field(
        alias="__typename", default="State", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class DashboardPanelsReservation(BaseModel):
    """No documentation"""

    typename: Literal["Reservation"] = Field(
        alias="__typename", default="Reservation", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class DashboardPanels(BaseModel):
    """No documentation"""

    typename: Literal["Panel"] = Field(
        alias="__typename", default="Panel", exclude=True
    )
    id: ID
    state: Optional[DashboardPanelsState] = Field(default=None)
    reservation: Optional[DashboardPanelsReservation] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class Dashboard(BaseModel):
    """No documentation"""

    typename: Literal["Dashboard"] = Field(
        alias="__typename", default="Dashboard", exclude=True
    )
    id: ID
    name: Optional[str] = Field(default=None)
    ui_tree: Optional[DashboardUitree] = Field(default=None, alias="uiTree")
    panels: Optional[Tuple[DashboardPanels, ...]] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class AssignationParent(BaseModel):
    """No documentation"""

    typename: Literal["Assignation"] = Field(
        alias="__typename", default="Assignation", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class AssignationEvents(BaseModel):
    """No documentation"""

    typename: Literal["AssignationEvent"] = Field(
        alias="__typename", default="AssignationEvent", exclude=True
    )
    id: ID
    returns: Optional[Any] = Field(default=None)
    level: Optional[LogLevel] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class AssignationInstructs(BaseModel):
    """No documentation"""

    typename: Literal["AssignationInstruct"] = Field(
        alias="__typename", default="AssignationInstruct", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class Assignation(BaseModel):
    """No documentation"""

    typename: Literal["Assignation"] = Field(
        alias="__typename", default="Assignation", exclude=True
    )
    args: Any
    id: ID
    parent: Optional[AssignationParent] = Field(default=None)
    "A parent assignation is the next assignation in the chain of assignations that caused this assignation to be created. Parents can be created by intent or by the system. If null, this assignation is the parent"
    id: ID
    latest_event_kind: AssignationEventKind = Field(alias="latestEventKind")
    "The status of this assignation"
    events: Tuple[AssignationEvents, ...]
    instructs: Tuple[AssignationInstructs, ...]
    reference: Optional[str] = Field(default=None)
    updated_at: datetime = Field(alias="updatedAt")
    model_config = ConfigDict(frozen=True)


class AssignationEvent(BaseModel):
    """No documentation"""

    typename: Literal["AssignationEvent"] = Field(
        alias="__typename", default="AssignationEvent", exclude=True
    )
    id: ID
    kind: AssignationEventKind
    returns: Optional[Any] = Field(default=None)
    reference: str
    message: Optional[str] = Field(default=None)
    progress: Optional[int] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class Toolbox(BaseModel):
    """No documentation"""

    typename: Literal["Toolbox"] = Field(
        alias="__typename", default="Toolbox", exclude=True
    )
    id: ID
    name: str
    description: str
    model_config = ConfigDict(frozen=True)


class ListToolbox(BaseModel):
    """No documentation"""

    typename: Literal["Toolbox"] = Field(
        alias="__typename", default="Toolbox", exclude=True
    )
    id: ID
    name: str
    description: str
    model_config = ConfigDict(frozen=True)


class PrimaryAction(BaseModel):
    """No documentation"""

    typename: Literal["Action"] = Field(
        alias="__typename", default="Action", exclude=True
    )
    name: str
    id: ID
    hash: ActionHash
    description: Optional[str] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class ChildPort(PortTrait, BaseModel):
    """No documentation"""

    typename: Literal["Port"] = Field(alias="__typename", default="Port", exclude=True)
    key: str
    kind: PortKind
    identifier: Optional[Identifier] = Field(default=None)
    children: Optional[Tuple[ChildPortNested, ...]] = Field(default=None)
    nullable: bool
    default: Optional[Any] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class PortEffectBase(BaseModel):
    """No documentation"""

    kind: EffectKind
    dependencies: Tuple[str, ...]
    function: ValidatorFunction


class PortEffectCatch(PortEffectBase):
    """Catch all class for PortEffectBase"""

    typename: str = Field(alias="__typename", exclude=True)
    "No documentation"
    kind: EffectKind
    dependencies: Tuple[str, ...]
    function: ValidatorFunction


class PortEffectCustomEffect(CustomEffect, PortEffectBase, BaseModel):
    """No documentation"""

    typename: Literal["CustomEffect"] = Field(
        alias="__typename", default="CustomEffect", exclude=True
    )


class PortEffectMessageEffect(MessageEffect, PortEffectBase, BaseModel):
    """No documentation"""

    typename: Literal["MessageEffect"] = Field(
        alias="__typename", default="MessageEffect", exclude=True
    )


class PortAssignWidgetBase(BaseModel):
    """No documentation"""

    kind: AssignWidgetKind


class PortAssignWidgetCatch(PortAssignWidgetBase):
    """Catch all class for PortAssignWidgetBase"""

    typename: str = Field(alias="__typename", exclude=True)
    "No documentation"
    kind: AssignWidgetKind


class PortAssignWidgetSliderAssignWidget(
    SliderAssignWidget, PortAssignWidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["SliderAssignWidget"] = Field(
        alias="__typename", default="SliderAssignWidget", exclude=True
    )


class PortAssignWidgetChoiceAssignWidget(
    ChoiceAssignWidget, PortAssignWidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["ChoiceAssignWidget"] = Field(
        alias="__typename", default="ChoiceAssignWidget", exclude=True
    )


class PortAssignWidgetSearchAssignWidget(
    SearchAssignWidget, PortAssignWidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["SearchAssignWidget"] = Field(
        alias="__typename", default="SearchAssignWidget", exclude=True
    )


class PortAssignWidgetStateChoiceAssignWidget(PortAssignWidgetBase, BaseModel):
    """No documentation"""

    typename: Literal["StateChoiceAssignWidget"] = Field(
        alias="__typename", default="StateChoiceAssignWidget", exclude=True
    )


class PortAssignWidgetStringAssignWidget(
    StringAssignWidget, PortAssignWidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["StringAssignWidget"] = Field(
        alias="__typename", default="StringAssignWidget", exclude=True
    )


class PortAssignWidgetCustomAssignWidget(
    CustomAssignWidget, PortAssignWidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["CustomAssignWidget"] = Field(
        alias="__typename", default="CustomAssignWidget", exclude=True
    )


class ReturnWidgetBase(BaseModel):
    """No documentation"""

    kind: ReturnWidgetKind


class ReturnWidgetCatch(ReturnWidgetBase):
    """Catch all class for ReturnWidgetBase"""

    typename: str = Field(alias="__typename", exclude=True)
    "No documentation"
    kind: ReturnWidgetKind


class ReturnWidgetCustomReturnWidget(CustomReturnWidget, ReturnWidgetBase, BaseModel):
    """No documentation"""

    typename: Literal["CustomReturnWidget"] = Field(
        alias="__typename", default="CustomReturnWidget", exclude=True
    )


class ReturnWidgetChoiceReturnWidget(ChoiceReturnWidget, ReturnWidgetBase, BaseModel):
    """No documentation"""

    typename: Literal["ChoiceReturnWidget"] = Field(
        alias="__typename", default="ChoiceReturnWidget", exclude=True
    )


class AssignationChangeEvent(BaseModel):
    """No documentation"""

    typename: Literal["AssignationChangeEvent"] = Field(
        alias="__typename", default="AssignationChangeEvent", exclude=True
    )
    create: Optional[Assignation] = Field(default=None)
    event: Optional[AssignationEvent] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class PortAssignwidgetBase(BaseModel):
    """No documentation"""

    model_config = ConfigDict(frozen=True)


class PortAssignwidgetBaseSliderAssignWidget(
    PortAssignWidgetSliderAssignWidget, PortAssignwidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["SliderAssignWidget"] = Field(
        alias="__typename", default="SliderAssignWidget", exclude=True
    )


class PortAssignwidgetBaseChoiceAssignWidget(
    PortAssignWidgetChoiceAssignWidget, PortAssignwidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["ChoiceAssignWidget"] = Field(
        alias="__typename", default="ChoiceAssignWidget", exclude=True
    )


class PortAssignwidgetBaseSearchAssignWidget(
    PortAssignWidgetSearchAssignWidget, PortAssignwidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["SearchAssignWidget"] = Field(
        alias="__typename", default="SearchAssignWidget", exclude=True
    )


class PortAssignwidgetBaseStateChoiceAssignWidget(
    PortAssignWidgetStateChoiceAssignWidget, PortAssignwidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["StateChoiceAssignWidget"] = Field(
        alias="__typename", default="StateChoiceAssignWidget", exclude=True
    )


class PortAssignwidgetBaseStringAssignWidget(
    PortAssignWidgetStringAssignWidget, PortAssignwidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["StringAssignWidget"] = Field(
        alias="__typename", default="StringAssignWidget", exclude=True
    )


class PortAssignwidgetBaseCustomAssignWidget(
    PortAssignWidgetCustomAssignWidget, PortAssignwidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["CustomAssignWidget"] = Field(
        alias="__typename", default="CustomAssignWidget", exclude=True
    )


class PortAssignwidgetBaseCatchAll(PortAssignwidgetBase, BaseModel):
    """Catch all class for PortAssignwidgetBase"""

    typename: str = Field(alias="__typename", exclude=True)


class PortReturnwidgetBase(BaseModel):
    """No documentation"""

    model_config = ConfigDict(frozen=True)


class PortReturnwidgetBaseCustomReturnWidget(
    ReturnWidgetCustomReturnWidget, PortReturnwidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["CustomReturnWidget"] = Field(
        alias="__typename", default="CustomReturnWidget", exclude=True
    )


class PortReturnwidgetBaseChoiceReturnWidget(
    ReturnWidgetChoiceReturnWidget, PortReturnwidgetBase, BaseModel
):
    """No documentation"""

    typename: Literal["ChoiceReturnWidget"] = Field(
        alias="__typename", default="ChoiceReturnWidget", exclude=True
    )


class PortReturnwidgetBaseCatchAll(PortReturnwidgetBase, BaseModel):
    """Catch all class for PortReturnwidgetBase"""

    typename: str = Field(alias="__typename", exclude=True)


class PortValidators(BaseModel):
    """No documentation"""

    typename: Literal["Validator"] = Field(
        alias="__typename", default="Validator", exclude=True
    )
    function: ValidatorFunction
    error_message: Optional[str] = Field(default=None, alias="errorMessage")
    dependencies: Optional[Tuple[str, ...]] = Field(default=None)
    label: Optional[str] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class PortEffectsBase(BaseModel):
    """No documentation"""

    model_config = ConfigDict(frozen=True)


class PortEffectsBaseCustomEffect(PortEffectCustomEffect, PortEffectsBase, BaseModel):
    """No documentation"""

    typename: Literal["CustomEffect"] = Field(
        alias="__typename", default="CustomEffect", exclude=True
    )


class PortEffectsBaseMessageEffect(PortEffectMessageEffect, PortEffectsBase, BaseModel):
    """No documentation"""

    typename: Literal["MessageEffect"] = Field(
        alias="__typename", default="MessageEffect", exclude=True
    )


class PortEffectsBaseCatchAll(PortEffectsBase, BaseModel):
    """Catch all class for PortEffectsBase"""

    typename: str = Field(alias="__typename", exclude=True)


class Port(PortTrait, BaseModel):
    """No documentation"""

    typename: Literal["Port"] = Field(alias="__typename", default="Port", exclude=True)
    key: str
    label: Optional[str] = Field(default=None)
    nullable: bool
    description: Optional[str] = Field(default=None)
    default: Optional[Any] = Field(default=None)
    kind: PortKind
    identifier: Optional[Identifier] = Field(default=None)
    children: Optional[Tuple[ChildPort, ...]] = Field(default=None)
    assign_widget: Optional[
        Union[
            Annotated[
                Union[
                    PortAssignwidgetBaseSliderAssignWidget,
                    PortAssignwidgetBaseChoiceAssignWidget,
                    PortAssignwidgetBaseSearchAssignWidget,
                    PortAssignwidgetBaseStateChoiceAssignWidget,
                    PortAssignwidgetBaseStringAssignWidget,
                    PortAssignwidgetBaseCustomAssignWidget,
                ],
                Field(discriminator="typename"),
            ],
            PortAssignwidgetBaseCatchAll,
        ]
    ] = Field(default=None, alias="assignWidget")
    return_widget: Optional[
        Union[
            Annotated[
                Union[
                    PortReturnwidgetBaseCustomReturnWidget,
                    PortReturnwidgetBaseChoiceReturnWidget,
                ],
                Field(discriminator="typename"),
            ],
            PortReturnwidgetBaseCatchAll,
        ]
    ] = Field(default=None, alias="returnWidget")
    validators: Optional[Tuple[PortValidators, ...]] = Field(default=None)
    effects: Optional[
        Tuple[
            Union[
                Annotated[
                    Union[PortEffectsBaseCustomEffect, PortEffectsBaseMessageEffect],
                    Field(discriminator="typename"),
                ],
                PortEffectsBaseCatchAll,
            ],
            ...,
        ]
    ] = Field(default=None)
    model_config = ConfigDict(frozen=True)


class ListShortcutAction(BaseModel):
    """No documentation"""

    typename: Literal["Action"] = Field(
        alias="__typename", default="Action", exclude=True
    )
    id: ID
    hash: ActionHash
    model_config = ConfigDict(frozen=True)


class ListShortcut(BaseModel):
    """No documentation"""

    typename: Literal["Shortcut"] = Field(
        alias="__typename", default="Shortcut", exclude=True
    )
    id: ID
    name: str
    description: Optional[str] = Field(default=None)
    action: ListShortcutAction
    saved_args: Any = Field(alias="savedArgs")
    args: Tuple[Port, ...]
    returns: Tuple[Port, ...]
    allow_quick: bool = Field(alias="allowQuick")
    use_returns: bool = Field(alias="useReturns")
    model_config = ConfigDict(frozen=True)


class StateSchema(BaseModel):
    """No documentation"""

    typename: Literal["StateSchema"] = Field(
        alias="__typename", default="StateSchema", exclude=True
    )
    id: ID
    name: str
    ports: Tuple[Port, ...]
    model_config = ConfigDict(frozen=True)


class DefinitionCollections(BaseModel):
    """No documentation"""

    typename: Literal["Collection"] = Field(
        alias="__typename", default="Collection", exclude=True
    )
    name: str
    model_config = ConfigDict(frozen=True)


class DefinitionIstestfor(BaseModel):
    """No documentation"""

    typename: Literal["Action"] = Field(
        alias="__typename", default="Action", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class DefinitionPortgroups(BaseModel):
    """No documentation"""

    typename: Literal["PortGroup"] = Field(
        alias="__typename", default="PortGroup", exclude=True
    )
    key: str
    model_config = ConfigDict(frozen=True)


class Definition(BaseModel):
    """No documentation"""

    typename: Literal["Action"] = Field(
        alias="__typename", default="Action", exclude=True
    )
    args: Tuple[Port, ...]
    returns: Tuple[Port, ...]
    kind: ActionKind
    name: str
    description: Optional[str] = Field(default=None)
    interfaces: Tuple[str, ...]
    collections: Tuple[DefinitionCollections, ...]
    is_dev: bool = Field(alias="isDev")
    is_test_for: Tuple[DefinitionIstestfor, ...] = Field(alias="isTestFor")
    port_groups: Tuple[DefinitionPortgroups, ...] = Field(alias="portGroups")
    stateful: bool
    model_config = ConfigDict(frozen=True)


class StateAgent(BaseModel):
    """No documentation"""

    typename: Literal["Agent"] = Field(
        alias="__typename", default="Agent", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class State(BaseModel):
    """No documentation"""

    typename: Literal["State"] = Field(
        alias="__typename", default="State", exclude=True
    )
    id: ID
    value: Args
    state_schema: StateSchema = Field(alias="stateSchema")
    agent: StateAgent
    model_config = ConfigDict(frozen=True)


class Action(Definition, BaseModel):
    """No documentation"""

    typename: Literal["Action"] = Field(
        alias="__typename", default="Action", exclude=True
    )
    hash: ActionHash
    id: ID
    model_config = ConfigDict(frozen=True)


class Shortcut(BaseModel):
    """No documentation"""

    typename: Literal["Shortcut"] = Field(
        alias="__typename", default="Shortcut", exclude=True
    )
    id: ID
    name: str
    description: Optional[str] = Field(default=None)
    action: Action
    saved_args: Any = Field(alias="savedArgs")
    args: Tuple[Port, ...]
    returns: Tuple[Port, ...]
    use_returns: bool = Field(alias="useReturns")
    model_config = ConfigDict(frozen=True)


class ImplementationAgentRegistry(BaseModel):
    """No documentation"""

    typename: Literal["Registry"] = Field(
        alias="__typename", default="Registry", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class ImplementationAgent(BaseModel):
    """No documentation"""

    typename: Literal["Agent"] = Field(
        alias="__typename", default="Agent", exclude=True
    )
    registry: ImplementationAgentRegistry
    model_config = ConfigDict(frozen=True)


class Implementation(BaseModel):
    """No documentation"""

    typename: Literal["Implementation"] = Field(
        alias="__typename", default="Implementation", exclude=True
    )
    id: ID
    agent: ImplementationAgent
    action: Action
    params: Any
    extension: str
    interface: str
    model_config = ConfigDict(frozen=True)


class Create_testcaseMutation(BaseModel):
    """No documentation found for this operation."""

    create_test_case: TestCase = Field(alias="createTestCase")

    class Arguments(BaseModel):
        """Arguments for create_testcase"""

        input: CreateTestCaseInput

    class Meta:
        """Meta class for create_testcase"""

        document = "fragment TestCase on TestCase {\n  id\n  action {\n    id\n    __typename\n  }\n  isBenchmark\n  description\n  name\n  __typename\n}\n\nmutation create_testcase($input: CreateTestCaseInput!) {\n  createTestCase(input: $input) {\n    ...TestCase\n    __typename\n  }\n}"


class Create_testresultMutation(BaseModel):
    """No documentation found for this operation."""

    create_test_result: TestResult = Field(alias="createTestResult")

    class Arguments(BaseModel):
        """Arguments for create_testresult"""

        input: CreateTestResultInput

    class Meta:
        """Meta class for create_testresult"""

        document = "fragment TestResult on TestResult {\n  id\n  case {\n    id\n    __typename\n  }\n  passed\n  __typename\n}\n\nmutation create_testresult($input: CreateTestResultInput!) {\n  createTestResult(input: $input) {\n    ...TestResult\n    __typename\n  }\n}"


class SetStateMutation(BaseModel):
    """No documentation found for this operation."""

    set_state: State = Field(alias="setState")

    class Arguments(BaseModel):
        """Arguments for SetState"""

        input: SetStateInput

    class Meta:
        """Meta class for SetState"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment StateSchema on StateSchema {\n  id\n  name\n  ports {\n    ...Port\n    __typename\n  }\n  __typename\n}\n\nfragment State on State {\n  id\n  value\n  stateSchema {\n    ...StateSchema\n    __typename\n  }\n  agent {\n    id\n    __typename\n  }\n  __typename\n}\n\nmutation SetState($input: SetStateInput!) {\n  setState(input: $input) {\n    ...State\n    __typename\n  }\n}"


class UpdateStateMutation(BaseModel):
    """No documentation found for this operation."""

    update_state: State = Field(alias="updateState")

    class Arguments(BaseModel):
        """Arguments for UpdateState"""

        input: UpdateStateInput

    class Meta:
        """Meta class for UpdateState"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment StateSchema on StateSchema {\n  id\n  name\n  ports {\n    ...Port\n    __typename\n  }\n  __typename\n}\n\nfragment State on State {\n  id\n  value\n  stateSchema {\n    ...StateSchema\n    __typename\n  }\n  agent {\n    id\n    __typename\n  }\n  __typename\n}\n\nmutation UpdateState($input: UpdateStateInput!) {\n  updateState(input: $input) {\n    ...State\n    __typename\n  }\n}"


class EnsureAgentMutation(BaseModel):
    """No documentation found for this operation."""

    ensure_agent: Agent = Field(alias="ensureAgent")

    class Arguments(BaseModel):
        """Arguments for EnsureAgent"""

        input: AgentInput

    class Meta:
        """Meta class for EnsureAgent"""

        document = "fragment Agent on Agent {\n  id\n  registry {\n    app {\n      id\n      __typename\n    }\n    user {\n      id\n      __typename\n    }\n    __typename\n  }\n  memoryShelve {\n    id\n    __typename\n  }\n  __typename\n}\n\nmutation EnsureAgent($input: AgentInput!) {\n  ensureAgent(input: $input) {\n    ...Agent\n    __typename\n  }\n}"


class CreatePanelMutation(BaseModel):
    """No documentation found for this operation."""

    create_panel: Panel = Field(alias="createPanel")

    class Arguments(BaseModel):
        """Arguments for CreatePanel"""

        input: CreatePanelInput

    class Meta:
        """Meta class for CreatePanel"""

        document = "fragment Panel on Panel {\n  id\n  kind\n  state {\n    id\n    __typename\n  }\n  reservation {\n    id\n    __typename\n  }\n  __typename\n}\n\nmutation CreatePanel($input: CreatePanelInput!) {\n  createPanel(input: $input) {\n    ...Panel\n    __typename\n  }\n}"


class ReserveMutation(BaseModel):
    """No documentation found for this operation."""

    reserve: Reservation

    class Arguments(BaseModel):
        """Arguments for reserve"""

        input: ReserveInput

    class Meta:
        """Meta class for reserve"""

        document = "fragment Reservation on Reservation {\n  id\n  action {\n    id\n    hash\n    __typename\n  }\n  waiter {\n    id\n    __typename\n  }\n  reference\n  updatedAt\n  __typename\n}\n\nmutation reserve($input: ReserveInput!) {\n  reserve(input: $input) {\n    ...Reservation\n    __typename\n  }\n}"


class UnreserveMutation(BaseModel):
    """No documentation found for this operation."""

    unreserve: str

    class Arguments(BaseModel):
        """Arguments for unreserve"""

        input: UnreserveInput

    class Meta:
        """Meta class for unreserve"""

        document = "mutation unreserve($input: UnreserveInput!) {\n  unreserve(input: $input)\n}"


class CreateShortcutMutation(BaseModel):
    """No documentation found for this operation."""

    create_shortcut: Shortcut = Field(alias="createShortcut")

    class Arguments(BaseModel):
        """Arguments for CreateShortcut"""

        input: CreateShortcutInput

    class Meta:
        """Meta class for CreateShortcut"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment Definition on Action {\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  kind\n  name\n  description\n  interfaces\n  collections {\n    name\n    __typename\n  }\n  isDev\n  isTestFor {\n    id\n    __typename\n  }\n  portGroups {\n    key\n    __typename\n  }\n  stateful\n  __typename\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment Action on Action {\n  hash\n  id\n  ...Definition\n  __typename\n}\n\nfragment Shortcut on Shortcut {\n  id\n  name\n  description\n  action {\n    ...Action\n    __typename\n  }\n  savedArgs\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  useReturns\n  __typename\n}\n\nmutation CreateShortcut($input: CreateShortcutInput!) {\n  createShortcut(input: $input) {\n    ...Shortcut\n    __typename\n  }\n}"


class AssignMutation(BaseModel):
    """No documentation found for this operation."""

    assign: Assignation

    class Arguments(BaseModel):
        """Arguments for assign"""

        input: AssignInput

    class Meta:
        """Meta class for assign"""

        document = "fragment Assignation on Assignation {\n  args\n  id\n  parent {\n    id\n    __typename\n  }\n  id\n  latestEventKind\n  events {\n    id\n    returns\n    level\n    __typename\n  }\n  instructs {\n    id\n    __typename\n  }\n  reference\n  updatedAt\n  __typename\n}\n\nmutation assign($input: AssignInput!) {\n  assign(input: $input) {\n    ...Assignation\n    __typename\n  }\n}"


class CancelMutation(BaseModel):
    """No documentation found for this operation."""

    cancel: Assignation

    class Arguments(BaseModel):
        """Arguments for cancel"""

        input: CancelInput

    class Meta:
        """Meta class for cancel"""

        document = "fragment Assignation on Assignation {\n  args\n  id\n  parent {\n    id\n    __typename\n  }\n  id\n  latestEventKind\n  events {\n    id\n    returns\n    level\n    __typename\n  }\n  instructs {\n    id\n    __typename\n  }\n  reference\n  updatedAt\n  __typename\n}\n\nmutation cancel($input: CancelInput!) {\n  cancel(input: $input) {\n    ...Assignation\n    __typename\n  }\n}"


class InterruptMutation(BaseModel):
    """No documentation found for this operation."""

    interrupt: Assignation

    class Arguments(BaseModel):
        """Arguments for interrupt"""

        input: InterruptInput

    class Meta:
        """Meta class for interrupt"""

        document = "fragment Assignation on Assignation {\n  args\n  id\n  parent {\n    id\n    __typename\n  }\n  id\n  latestEventKind\n  events {\n    id\n    returns\n    level\n    __typename\n  }\n  instructs {\n    id\n    __typename\n  }\n  reference\n  updatedAt\n  __typename\n}\n\nmutation interrupt($input: InterruptInput!) {\n  interrupt(input: $input) {\n    ...Assignation\n    __typename\n  }\n}"


class CollectMutation(BaseModel):
    """No documentation found for this operation."""

    collect: Tuple[str, ...]
    "Collect data from a assignation"

    class Arguments(BaseModel):
        """Arguments for collect"""

        input: CollectInput

    class Meta:
        """Meta class for collect"""

        document = (
            "mutation collect($input: CollectInput!) {\n  collect(input: $input)\n}"
        )


class CreateDashboardMutation(BaseModel):
    """No documentation found for this operation."""

    create_dashboard: Dashboard = Field(alias="createDashboard")

    class Arguments(BaseModel):
        """Arguments for CreateDashboard"""

        input: CreateDashboardInput

    class Meta:
        """Meta class for CreateDashboard"""

        document = "fragment Dashboard on Dashboard {\n  id\n  name\n  uiTree {\n    child {\n      ... on UIGrid {\n        rowHeight\n        children {\n          x\n          y\n          w\n          h\n        }\n      }\n      __typename\n    }\n    __typename\n  }\n  panels {\n    id\n    state {\n      id\n      __typename\n    }\n    reservation {\n      id\n      __typename\n    }\n    __typename\n  }\n  __typename\n}\n\nmutation CreateDashboard($input: CreateDashboardInput!) {\n  createDashboard(input: $input) {\n    ...Dashboard\n    __typename\n  }\n}"


class ShelveMutationShelveinmemorydrawer(BaseModel):
    """No documentation"""

    typename: Literal["MemoryDrawer"] = Field(
        alias="__typename", default="MemoryDrawer", exclude=True
    )
    id: ID
    model_config = ConfigDict(frozen=True)


class ShelveMutation(BaseModel):
    """No documentation found for this operation."""

    shelve_in_memory_drawer: ShelveMutationShelveinmemorydrawer = Field(
        alias="shelveInMemoryDrawer"
    )

    class Arguments(BaseModel):
        """Arguments for shelve"""

        input: ShelveInMemoryDrawerInput

    class Meta:
        """Meta class for shelve"""

        document = "mutation shelve($input: ShelveInMemoryDrawerInput!) {\n  shelveInMemoryDrawer(input: $input) {\n    id\n    __typename\n  }\n}"


class UnshelveMutation(BaseModel):
    """No documentation found for this operation."""

    unshelve_memory_drawer: str = Field(alias="unshelveMemoryDrawer")

    class Arguments(BaseModel):
        """Arguments for unshelve"""

        input: UnshelveMemoryDrawerInput

    class Meta:
        """Meta class for unshelve"""

        document = "mutation unshelve($input: UnshelveMemoryDrawerInput!) {\n  unshelveMemoryDrawer(input: $input)\n}"


class CreateStateSchemaMutation(BaseModel):
    """No documentation found for this operation."""

    create_state_schema: StateSchema = Field(alias="createStateSchema")

    class Arguments(BaseModel):
        """Arguments for CreateStateSchema"""

        input: CreateStateSchemaInput

    class Meta:
        """Meta class for CreateStateSchema"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment StateSchema on StateSchema {\n  id\n  name\n  ports {\n    ...Port\n    __typename\n  }\n  __typename\n}\n\nmutation CreateStateSchema($input: CreateStateSchemaInput!) {\n  createStateSchema(input: $input) {\n    ...StateSchema\n    __typename\n  }\n}"


class CreateImplementationMutation(BaseModel):
    """No documentation found for this operation."""

    create_implementation: Implementation = Field(alias="createImplementation")

    class Arguments(BaseModel):
        """Arguments for createImplementation"""

        input: CreateImplementationInput

    class Meta:
        """Meta class for createImplementation"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment Definition on Action {\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  kind\n  name\n  description\n  interfaces\n  collections {\n    name\n    __typename\n  }\n  isDev\n  isTestFor {\n    id\n    __typename\n  }\n  portGroups {\n    key\n    __typename\n  }\n  stateful\n  __typename\n}\n\nfragment Action on Action {\n  hash\n  id\n  ...Definition\n  __typename\n}\n\nfragment Implementation on Implementation {\n  id\n  agent {\n    registry {\n      id\n      __typename\n    }\n    __typename\n  }\n  action {\n    ...Action\n    __typename\n  }\n  params\n  extension\n  interface\n  __typename\n}\n\nmutation createImplementation($input: CreateImplementationInput!) {\n  createImplementation(input: $input) {\n    ...Implementation\n    __typename\n  }\n}"


class SetExtensionImplementationsMutation(BaseModel):
    """No documentation found for this operation."""

    set_extension_implementations: Tuple[Implementation, ...] = Field(
        alias="setExtensionImplementations"
    )

    class Arguments(BaseModel):
        """Arguments for SetExtensionImplementations"""

        input: SetExtensionImplementationsInput

    class Meta:
        """Meta class for SetExtensionImplementations"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment Definition on Action {\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  kind\n  name\n  description\n  interfaces\n  collections {\n    name\n    __typename\n  }\n  isDev\n  isTestFor {\n    id\n    __typename\n  }\n  portGroups {\n    key\n    __typename\n  }\n  stateful\n  __typename\n}\n\nfragment Action on Action {\n  hash\n  id\n  ...Definition\n  __typename\n}\n\nfragment Implementation on Implementation {\n  id\n  agent {\n    registry {\n      id\n      __typename\n    }\n    __typename\n  }\n  action {\n    ...Action\n    __typename\n  }\n  params\n  extension\n  interface\n  __typename\n}\n\nmutation SetExtensionImplementations($input: SetExtensionImplementationsInput!) {\n  setExtensionImplementations(input: $input) {\n    ...Implementation\n    __typename\n  }\n}"


class WatchReservationsSubscription(BaseModel):
    """No documentation found for this operation."""

    reservations: Reservation

    class Arguments(BaseModel):
        """Arguments for WatchReservations"""

        instance_id: InstanceId = Field(alias="instanceId")

    class Meta:
        """Meta class for WatchReservations"""

        document = "fragment Reservation on Reservation {\n  id\n  action {\n    id\n    hash\n    __typename\n  }\n  waiter {\n    id\n    __typename\n  }\n  reference\n  updatedAt\n  __typename\n}\n\nsubscription WatchReservations($instanceId: InstanceId!) {\n  reservations(instanceId: $instanceId) {\n    ...Reservation\n    __typename\n  }\n}"


class WatchAssignationsSubscription(BaseModel):
    """No documentation found for this operation."""

    assignations: AssignationChangeEvent

    class Arguments(BaseModel):
        """Arguments for WatchAssignations"""

        instance_id: InstanceId = Field(alias="instanceId")

    class Meta:
        """Meta class for WatchAssignations"""

        document = "fragment AssignationEvent on AssignationEvent {\n  id\n  kind\n  returns\n  reference\n  message\n  progress\n  __typename\n}\n\nfragment Assignation on Assignation {\n  args\n  id\n  parent {\n    id\n    __typename\n  }\n  id\n  latestEventKind\n  events {\n    id\n    returns\n    level\n    __typename\n  }\n  instructs {\n    id\n    __typename\n  }\n  reference\n  updatedAt\n  __typename\n}\n\nfragment AssignationChangeEvent on AssignationChangeEvent {\n  create {\n    ...Assignation\n    __typename\n  }\n  event {\n    ...AssignationEvent\n    __typename\n  }\n  __typename\n}\n\nsubscription WatchAssignations($instanceId: InstanceId!) {\n  assignations(instanceId: $instanceId) {\n    ...AssignationChangeEvent\n    __typename\n  }\n}"


class Get_testcaseQuery(BaseModel):
    """No documentation found for this operation."""

    test_case: TestCase = Field(alias="testCase")

    class Arguments(BaseModel):
        """Arguments for get_testcase"""

        id: ID

    class Meta:
        """Meta class for get_testcase"""

        document = "fragment TestCase on TestCase {\n  id\n  action {\n    id\n    __typename\n  }\n  isBenchmark\n  description\n  name\n  __typename\n}\n\nquery get_testcase($id: ID!) {\n  testCase(id: $id) {\n    ...TestCase\n    __typename\n  }\n}"


class Get_testresultQuery(BaseModel):
    """No documentation found for this operation."""

    test_result: TestResult = Field(alias="testResult")

    class Arguments(BaseModel):
        """Arguments for get_testresult"""

        id: ID

    class Meta:
        """Meta class for get_testresult"""

        document = "fragment TestResult on TestResult {\n  id\n  case {\n    id\n    __typename\n  }\n  passed\n  __typename\n}\n\nquery get_testresult($id: ID!) {\n  testResult(id: $id) {\n    ...TestResult\n    __typename\n  }\n}"


class Search_testcasesQueryOptions(BaseModel):
    """No documentation"""

    typename: Literal["TestCase"] = Field(
        alias="__typename", default="TestCase", exclude=True
    )
    label: str
    value: ID
    model_config = ConfigDict(frozen=True)


class Search_testcasesQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[Search_testcasesQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for search_testcases"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)

    class Meta:
        """Meta class for search_testcases"""

        document = "query search_testcases($search: String, $values: [ID!]) {\n  options: testCases(\n    filters: {name: {iContains: $search}, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    label: name\n    value: id\n    __typename\n  }\n}"


class Search_testresultsQueryOptions(BaseModel):
    """No documentation"""

    typename: Literal["TestResult"] = Field(
        alias="__typename", default="TestResult", exclude=True
    )
    label: datetime
    value: ID
    model_config = ConfigDict(frozen=True)


class Search_testresultsQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[Search_testresultsQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for search_testresults"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)

    class Meta:
        """Meta class for search_testresults"""

        document = "query search_testresults($search: String, $values: [ID!]) {\n  options: testResults(\n    filters: {name: {iContains: $search}, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    label: createdAt\n    value: id\n    __typename\n  }\n}"


class GetMeActionsQueryActions(BaseModel):
    """No documentation"""

    typename: Literal["Action"] = Field(
        alias="__typename", default="Action", exclude=True
    )
    id: ID
    name: str
    model_config = ConfigDict(frozen=True)


class GetMeActionsQuery(BaseModel):
    """No documentation found for this operation."""

    actions: Tuple[GetMeActionsQueryActions, ...]

    class Arguments(BaseModel):
        """Arguments for GetMeActions"""

    class Meta:
        """Meta class for GetMeActions"""

        document = "query GetMeActions {\n  actions {\n    id\n    name\n    __typename\n  }\n}"


class GetAgentQuery(BaseModel):
    """No documentation found for this operation."""

    agent: Agent

    class Arguments(BaseModel):
        """Arguments for GetAgent"""

        id: ID

    class Meta:
        """Meta class for GetAgent"""

        document = "fragment Agent on Agent {\n  id\n  registry {\n    app {\n      id\n      __typename\n    }\n    user {\n      id\n      __typename\n    }\n    __typename\n  }\n  memoryShelve {\n    id\n    __typename\n  }\n  __typename\n}\n\nquery GetAgent($id: ID!) {\n  agent(id: $id) {\n    ...Agent\n    __typename\n  }\n}"


class GetPanelQuery(BaseModel):
    """No documentation found for this operation."""

    panel: Panel

    class Arguments(BaseModel):
        """Arguments for GetPanel"""

        id: ID

    class Meta:
        """Meta class for GetPanel"""

        document = "fragment Panel on Panel {\n  id\n  kind\n  state {\n    id\n    __typename\n  }\n  reservation {\n    id\n    __typename\n  }\n  __typename\n}\n\nquery GetPanel($id: ID!) {\n  panel(id: $id) {\n    ...Panel\n    __typename\n  }\n}"


class Get_reservationQuery(BaseModel):
    """No documentation found for this operation."""

    reservation: Reservation

    class Arguments(BaseModel):
        """Arguments for get_reservation"""

        id: ID

    class Meta:
        """Meta class for get_reservation"""

        document = "fragment Reservation on Reservation {\n  id\n  action {\n    id\n    hash\n    __typename\n  }\n  waiter {\n    id\n    __typename\n  }\n  reference\n  updatedAt\n  __typename\n}\n\nquery get_reservation($id: ID!) {\n  reservation(id: $id) {\n    ...Reservation\n    __typename\n  }\n}"


class ReservationsQuery(BaseModel):
    """No documentation found for this operation."""

    reservations: Tuple[Reservation, ...]

    class Arguments(BaseModel):
        """Arguments for reservations"""

        instance_id: InstanceId

    class Meta:
        """Meta class for reservations"""

        document = "fragment Reservation on Reservation {\n  id\n  action {\n    id\n    hash\n    __typename\n  }\n  waiter {\n    id\n    __typename\n  }\n  reference\n  updatedAt\n  __typename\n}\n\nquery reservations($instance_id: InstanceId!) {\n  reservations(instanceId: $instance_id) {\n    ...Reservation\n    __typename\n  }\n}"


class ListShortcutsQuery(BaseModel):
    """No documentation found for this operation."""

    shortcuts: Tuple[ListShortcut, ...]

    class Arguments(BaseModel):
        """Arguments for ListShortcuts"""

        pagination: Optional[OffsetPaginationInput] = Field(default=None)
        filters: Optional[ShortcutFilter] = Field(default=None)
        order: Optional[ShortcutOrder] = Field(default=None)

    class Meta:
        """Meta class for ListShortcuts"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment ListShortcut on Shortcut {\n  id\n  name\n  description\n  action {\n    id\n    hash\n    __typename\n  }\n  savedArgs\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  allowQuick\n  useReturns\n  __typename\n}\n\nquery ListShortcuts($pagination: OffsetPaginationInput, $filters: ShortcutFilter, $order: ShortcutOrder) {\n  shortcuts(order: $order, pagination: $pagination, filters: $filters) {\n    ...ListShortcut\n    __typename\n  }\n}"


class GetShortcutQuery(BaseModel):
    """No documentation found for this operation."""

    shortcut: Shortcut

    class Arguments(BaseModel):
        """Arguments for GetShortcut"""

        id: ID

    class Meta:
        """Meta class for GetShortcut"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment Definition on Action {\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  kind\n  name\n  description\n  interfaces\n  collections {\n    name\n    __typename\n  }\n  isDev\n  isTestFor {\n    id\n    __typename\n  }\n  portGroups {\n    key\n    __typename\n  }\n  stateful\n  __typename\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment Action on Action {\n  hash\n  id\n  ...Definition\n  __typename\n}\n\nfragment Shortcut on Shortcut {\n  id\n  name\n  description\n  action {\n    ...Action\n    __typename\n  }\n  savedArgs\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  useReturns\n  __typename\n}\n\nquery GetShortcut($id: ID!) {\n  shortcut(id: $id) {\n    ...Shortcut\n    __typename\n  }\n}"


class RequestsQuery(BaseModel):
    """No documentation found for this operation."""

    assignations: Tuple[Assignation, ...]

    class Arguments(BaseModel):
        """Arguments for requests"""

        instance_id: InstanceId

    class Meta:
        """Meta class for requests"""

        document = "fragment Assignation on Assignation {\n  args\n  id\n  parent {\n    id\n    __typename\n  }\n  id\n  latestEventKind\n  events {\n    id\n    returns\n    level\n    __typename\n  }\n  instructs {\n    id\n    __typename\n  }\n  reference\n  updatedAt\n  __typename\n}\n\nquery requests($instance_id: InstanceId!) {\n  assignations(instanceId: $instance_id) {\n    ...Assignation\n    __typename\n  }\n}"


class GetEventQuery(BaseModel):
    """No documentation found for this operation."""

    event: Tuple[AssignationEvent, ...]

    class Arguments(BaseModel):
        """Arguments for GetEvent"""

        id: Optional[ID] = Field(default=None)

    class Meta:
        """Meta class for GetEvent"""

        document = "fragment AssignationEvent on AssignationEvent {\n  id\n  kind\n  returns\n  reference\n  message\n  progress\n  __typename\n}\n\nquery GetEvent($id: ID) {\n  event(id: $id) {\n    ...AssignationEvent\n    __typename\n  }\n}"


class GetDashboardQuery(BaseModel):
    """No documentation found for this operation."""

    dashboard: Dashboard

    class Arguments(BaseModel):
        """Arguments for GetDashboard"""

        id: ID

    class Meta:
        """Meta class for GetDashboard"""

        document = "fragment Dashboard on Dashboard {\n  id\n  name\n  uiTree {\n    child {\n      ... on UIGrid {\n        rowHeight\n        children {\n          x\n          y\n          w\n          h\n        }\n      }\n      __typename\n    }\n    __typename\n  }\n  panels {\n    id\n    state {\n      id\n      __typename\n    }\n    reservation {\n      id\n      __typename\n    }\n    __typename\n  }\n  __typename\n}\n\nquery GetDashboard($id: ID!) {\n  dashboard(id: $id) {\n    ...Dashboard\n    __typename\n  }\n}"


class ListToolboxesQuery(BaseModel):
    """No documentation found for this operation."""

    toolboxes: Tuple[ListToolbox, ...]

    class Arguments(BaseModel):
        """Arguments for ListToolboxes"""

        pagination: Optional[OffsetPaginationInput] = Field(default=None)
        filters: Optional[ToolboxFilter] = Field(default=None)
        order: Optional[ToolboxOrder] = Field(default=None)

    class Meta:
        """Meta class for ListToolboxes"""

        document = "fragment ListToolbox on Toolbox {\n  id\n  name\n  description\n  __typename\n}\n\nquery ListToolboxes($pagination: OffsetPaginationInput, $filters: ToolboxFilter, $order: ToolboxOrder) {\n  toolboxes(order: $order, pagination: $pagination, filters: $filters) {\n    ...ListToolbox\n    __typename\n  }\n}"


class GetToolboxQuery(BaseModel):
    """No documentation found for this operation."""

    toolbox: Toolbox

    class Arguments(BaseModel):
        """Arguments for GetToolbox"""

        id: ID

    class Meta:
        """Meta class for GetToolbox"""

        document = "fragment Toolbox on Toolbox {\n  id\n  name\n  description\n  __typename\n}\n\nquery GetToolbox($id: ID!) {\n  toolbox(id: $id) {\n    ...Toolbox\n    __typename\n  }\n}"


class Get_implementationQuery(BaseModel):
    """No documentation found for this operation."""

    implementation: Implementation

    class Arguments(BaseModel):
        """Arguments for get_implementation"""

        id: ID

    class Meta:
        """Meta class for get_implementation"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment Definition on Action {\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  kind\n  name\n  description\n  interfaces\n  collections {\n    name\n    __typename\n  }\n  isDev\n  isTestFor {\n    id\n    __typename\n  }\n  portGroups {\n    key\n    __typename\n  }\n  stateful\n  __typename\n}\n\nfragment Action on Action {\n  hash\n  id\n  ...Definition\n  __typename\n}\n\nfragment Implementation on Implementation {\n  id\n  agent {\n    registry {\n      id\n      __typename\n    }\n    __typename\n  }\n  action {\n    ...Action\n    __typename\n  }\n  params\n  extension\n  interface\n  __typename\n}\n\nquery get_implementation($id: ID!) {\n  implementation(id: $id) {\n    ...Implementation\n    __typename\n  }\n}"


class Search_implementationsQueryOptions(BaseModel):
    """No documentation"""

    typename: Literal["Implementation"] = Field(
        alias="__typename", default="Implementation", exclude=True
    )
    label: str
    value: ID
    model_config = ConfigDict(frozen=True)


class Search_implementationsQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[Search_implementationsQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for search_implementations"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)

    class Meta:
        """Meta class for search_implementations"""

        document = "query search_implementations($search: String, $values: [ID!]) {\n  options: implementations(\n    filters: {interface: {iContains: $search}, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    label: name\n    value: id\n    __typename\n  }\n}"


class Implementations_forQuery(BaseModel):
    """No documentation found for this operation."""

    implementations: Tuple[Implementation, ...]

    class Arguments(BaseModel):
        """Arguments for implementations_for"""

        hash: ActionHash

    class Meta:
        """Meta class for implementations_for"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment Definition on Action {\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  kind\n  name\n  description\n  interfaces\n  collections {\n    name\n    __typename\n  }\n  isDev\n  isTestFor {\n    id\n    __typename\n  }\n  portGroups {\n    key\n    __typename\n  }\n  stateful\n  __typename\n}\n\nfragment Action on Action {\n  hash\n  id\n  ...Definition\n  __typename\n}\n\nfragment Implementation on Implementation {\n  id\n  agent {\n    registry {\n      id\n      __typename\n    }\n    __typename\n  }\n  action {\n    ...Action\n    __typename\n  }\n  params\n  extension\n  interface\n  __typename\n}\n\nquery implementations_for($hash: ActionHash!) {\n  implementations(filters: {actionHash: $hash}) {\n    ...Implementation\n    __typename\n  }\n}"


class MyImplementationAtQuery(BaseModel):
    """No documentation found for this operation."""

    my_implementation_at: Implementation = Field(alias="myImplementationAt")

    class Arguments(BaseModel):
        """Arguments for MyImplementationAt"""

        instance_id: str = Field(alias="instanceId")
        interface: Optional[str] = Field(default=None)
        action_id: Optional[ID] = Field(alias="actionId", default=None)

    class Meta:
        """Meta class for MyImplementationAt"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment Definition on Action {\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  kind\n  name\n  description\n  interfaces\n  collections {\n    name\n    __typename\n  }\n  isDev\n  isTestFor {\n    id\n    __typename\n  }\n  portGroups {\n    key\n    __typename\n  }\n  stateful\n  __typename\n}\n\nfragment Action on Action {\n  hash\n  id\n  ...Definition\n  __typename\n}\n\nfragment Implementation on Implementation {\n  id\n  agent {\n    registry {\n      id\n      __typename\n    }\n    __typename\n  }\n  action {\n    ...Action\n    __typename\n  }\n  params\n  extension\n  interface\n  __typename\n}\n\nquery MyImplementationAt($instanceId: String!, $interface: String, $actionId: ID) {\n  myImplementationAt(\n    instanceId: $instanceId\n    interface: $interface\n    actionId: $actionId\n  ) {\n    ...Implementation\n    __typename\n  }\n}"


class FindQuery(BaseModel):
    """No documentation found for this operation."""

    action: Action

    class Arguments(BaseModel):
        """Arguments for find"""

        id: Optional[ID] = Field(default=None)
        implementation: Optional[ID] = Field(default=None)
        hash: Optional[ActionHash] = Field(default=None)

    class Meta:
        """Meta class for find"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment Definition on Action {\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  kind\n  name\n  description\n  interfaces\n  collections {\n    name\n    __typename\n  }\n  isDev\n  isTestFor {\n    id\n    __typename\n  }\n  portGroups {\n    key\n    __typename\n  }\n  stateful\n  __typename\n}\n\nfragment Action on Action {\n  hash\n  id\n  ...Definition\n  __typename\n}\n\nquery find($id: ID, $implementation: ID, $hash: ActionHash) {\n  action(id: $id, implementation: $implementation, hash: $hash) {\n    ...Action\n    __typename\n  }\n}"


class RetrieveallQuery(BaseModel):
    """No documentation found for this operation."""

    actions: Tuple[Action, ...]

    class Arguments(BaseModel):
        """Arguments for retrieveall"""

    class Meta:
        """Meta class for retrieveall"""

        document = "fragment StringAssignWidget on StringAssignWidget {\n  __typename\n  kind\n  placeholder\n  asParagraph\n}\n\nfragment SliderAssignWidget on SliderAssignWidget {\n  __typename\n  kind\n  min\n  max\n  step\n}\n\nfragment ChildPortNested on Port {\n  key\n  kind\n  children {\n    identifier\n    nullable\n    kind\n    __typename\n  }\n  identifier\n  nullable\n  default\n  __typename\n}\n\nfragment ChoiceAssignWidget on ChoiceAssignWidget {\n  __typename\n  kind\n  choices {\n    value\n    label\n    description\n    __typename\n  }\n}\n\nfragment CustomEffect on CustomEffect {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment SearchAssignWidget on SearchAssignWidget {\n  __typename\n  kind\n  query\n  ward\n  dependencies\n}\n\nfragment CustomAssignWidget on CustomAssignWidget {\n  __typename\n  ward\n  hook\n}\n\nfragment ChoiceReturnWidget on ChoiceReturnWidget {\n  __typename\n  choices {\n    label\n    value\n    description\n    __typename\n  }\n}\n\nfragment MessageEffect on MessageEffect {\n  __typename\n  kind\n  message\n}\n\nfragment CustomReturnWidget on CustomReturnWidget {\n  __typename\n  kind\n  hook\n  ward\n}\n\nfragment ReturnWidget on ReturnWidget {\n  __typename\n  kind\n  ...CustomReturnWidget\n  ...ChoiceReturnWidget\n}\n\nfragment ChildPort on Port {\n  key\n  kind\n  identifier\n  children {\n    ...ChildPortNested\n    __typename\n  }\n  nullable\n  default\n  __typename\n}\n\nfragment PortEffect on Effect {\n  __typename\n  kind\n  dependencies\n  function\n  ...CustomEffect\n  ...MessageEffect\n}\n\nfragment PortAssignWidget on AssignWidget {\n  __typename\n  kind\n  ...StringAssignWidget\n  ...SearchAssignWidget\n  ...SliderAssignWidget\n  ...ChoiceAssignWidget\n  ...CustomAssignWidget\n}\n\nfragment Port on Port {\n  __typename\n  key\n  label\n  nullable\n  description\n  default\n  kind\n  identifier\n  children {\n    ...ChildPort\n    __typename\n  }\n  assignWidget {\n    ...PortAssignWidget\n    __typename\n  }\n  returnWidget {\n    ...ReturnWidget\n    __typename\n  }\n  validators {\n    function\n    errorMessage\n    dependencies\n    label\n    __typename\n  }\n  effects {\n    ...PortEffect\n    __typename\n  }\n}\n\nfragment Definition on Action {\n  args {\n    ...Port\n    __typename\n  }\n  returns {\n    ...Port\n    __typename\n  }\n  kind\n  name\n  description\n  interfaces\n  collections {\n    name\n    __typename\n  }\n  isDev\n  isTestFor {\n    id\n    __typename\n  }\n  portGroups {\n    key\n    __typename\n  }\n  stateful\n  __typename\n}\n\nfragment Action on Action {\n  hash\n  id\n  ...Definition\n  __typename\n}\n\nquery retrieveall {\n  actions {\n    ...Action\n    __typename\n  }\n}"


class Search_actionsQueryOptions(BaseModel):
    """No documentation"""

    typename: Literal["Action"] = Field(
        alias="__typename", default="Action", exclude=True
    )
    label: str
    value: ID
    model_config = ConfigDict(frozen=True)


class Search_actionsQuery(BaseModel):
    """No documentation found for this operation."""

    options: Tuple[Search_actionsQueryOptions, ...]

    class Arguments(BaseModel):
        """Arguments for search_actions"""

        search: Optional[str] = Field(default=None)
        values: Optional[List[ID]] = Field(default=None)

    class Meta:
        """Meta class for search_actions"""

        document = "query search_actions($search: String, $values: [ID!]) {\n  options: actions(\n    filters: {name: {iContains: $search}, ids: $values}\n    pagination: {limit: 10}\n  ) {\n    label: name\n    value: id\n    __typename\n  }\n}"


class PrimaryActionsQuery(BaseModel):
    """No documentation found for this operation."""

    actions: Tuple[PrimaryAction, ...]

    class Arguments(BaseModel):
        """Arguments for PrimaryActions"""

        pagination: Optional[OffsetPaginationInput] = Field(default=None)
        identifier: Optional[str] = Field(default=None)
        order: Optional[ActionOrder] = Field(default=None)
        search: Optional[str] = Field(default=None)

    class Meta:
        """Meta class for PrimaryActions"""

        document = "fragment PrimaryAction on Action {\n  name\n  id\n  hash\n  description\n  __typename\n}\n\nquery PrimaryActions($pagination: OffsetPaginationInput, $identifier: String, $order: ActionOrder, $search: String) {\n  actions(\n    order: $order\n    pagination: $pagination\n    filters: {demands: [{kind: ARGS, matches: [{at: 0, kind: STRUCTURE, identifier: $identifier}]}], search: $search}\n  ) {\n    ...PrimaryAction\n    __typename\n  }\n}"


async def acreate_testcase(
    action: ID,
    tester: ID,
    description: Optional[str] = None,
    name: Optional[str] = None,
    rath: Optional[RekuestNextRath] = None,
) -> TestCase:
    """create_testcase


    Arguments:
        action: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        tester: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        description: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        TestCase
    """
    return (
        await aexecute(
            Create_testcaseMutation,
            {
                "input": {
                    "action": action,
                    "tester": tester,
                    "description": description,
                    "name": name,
                }
            },
            rath=rath,
        )
    ).create_test_case


def create_testcase(
    action: ID,
    tester: ID,
    description: Optional[str] = None,
    name: Optional[str] = None,
    rath: Optional[RekuestNextRath] = None,
) -> TestCase:
    """create_testcase


    Arguments:
        action: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        tester: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        description: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        TestCase
    """
    return execute(
        Create_testcaseMutation,
        {
            "input": {
                "action": action,
                "tester": tester,
                "description": description,
                "name": name,
            }
        },
        rath=rath,
    ).create_test_case


async def acreate_testresult(
    case: ID,
    tester: ID,
    implementation: ID,
    passed: bool,
    result: Optional[str] = None,
    rath: Optional[RekuestNextRath] = None,
) -> TestResult:
    """create_testresult


    Arguments:
        case: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        tester: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        implementation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        passed: The `Boolean` scalar type represents `true` or `false`. (required)
        result: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        TestResult
    """
    return (
        await aexecute(
            Create_testresultMutation,
            {
                "input": {
                    "case": case,
                    "tester": tester,
                    "implementation": implementation,
                    "passed": passed,
                    "result": result,
                }
            },
            rath=rath,
        )
    ).create_test_result


def create_testresult(
    case: ID,
    tester: ID,
    implementation: ID,
    passed: bool,
    result: Optional[str] = None,
    rath: Optional[RekuestNextRath] = None,
) -> TestResult:
    """create_testresult


    Arguments:
        case: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        tester: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        implementation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        passed: The `Boolean` scalar type represents `true` or `false`. (required)
        result: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        TestResult
    """
    return execute(
        Create_testresultMutation,
        {
            "input": {
                "case": case,
                "tester": tester,
                "implementation": implementation,
                "passed": passed,
                "result": result,
            }
        },
        rath=rath,
    ).create_test_result


async def aset_state(
    state_schema: ID,
    instance_id: InstanceId,
    value: Args,
    rath: Optional[RekuestNextRath] = None,
) -> State:
    """SetState


    Arguments:
        state_schema: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        value: The `Args` scalar type represents a Dictionary of arguments (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        State
    """
    return (
        await aexecute(
            SetStateMutation,
            {
                "input": {
                    "stateSchema": state_schema,
                    "instanceId": instance_id,
                    "value": value,
                }
            },
            rath=rath,
        )
    ).set_state


def set_state(
    state_schema: ID,
    instance_id: InstanceId,
    value: Args,
    rath: Optional[RekuestNextRath] = None,
) -> State:
    """SetState


    Arguments:
        state_schema: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        value: The `Args` scalar type represents a Dictionary of arguments (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        State
    """
    return execute(
        SetStateMutation,
        {
            "input": {
                "stateSchema": state_schema,
                "instanceId": instance_id,
                "value": value,
            }
        },
        rath=rath,
    ).set_state


async def aupdate_state(
    state_schema: ID,
    instance_id: InstanceId,
    patches: Iterable[Args],
    rath: Optional[RekuestNextRath] = None,
) -> State:
    """UpdateState


    Arguments:
        state_schema: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        patches: The `Args` scalar type represents a Dictionary of arguments (required) (list) (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        State
    """
    return (
        await aexecute(
            UpdateStateMutation,
            {
                "input": {
                    "stateSchema": state_schema,
                    "instanceId": instance_id,
                    "patches": patches,
                }
            },
            rath=rath,
        )
    ).update_state


def update_state(
    state_schema: ID,
    instance_id: InstanceId,
    patches: Iterable[Args],
    rath: Optional[RekuestNextRath] = None,
) -> State:
    """UpdateState


    Arguments:
        state_schema: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        patches: The `Args` scalar type represents a Dictionary of arguments (required) (list) (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        State
    """
    return execute(
        UpdateStateMutation,
        {
            "input": {
                "stateSchema": state_schema,
                "instanceId": instance_id,
                "patches": patches,
            }
        },
        rath=rath,
    ).update_state


async def aensure_agent(
    instance_id: InstanceId,
    name: Optional[str] = None,
    extensions: Optional[Iterable[str]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Agent:
    """EnsureAgent


    Arguments:
        instance_id: The instance ID of the agent. This is used to identify the agent in the system.
        name: The name of the agent. This is used to identify the agent in the system.
        extensions: The extensions of the agent. This is used to identify the agent in the system.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Agent
    """
    return (
        await aexecute(
            EnsureAgentMutation,
            {
                "input": {
                    "instanceId": instance_id,
                    "name": name,
                    "extensions": extensions,
                }
            },
            rath=rath,
        )
    ).ensure_agent


def ensure_agent(
    instance_id: InstanceId,
    name: Optional[str] = None,
    extensions: Optional[Iterable[str]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Agent:
    """EnsureAgent


    Arguments:
        instance_id: The instance ID of the agent. This is used to identify the agent in the system.
        name: The name of the agent. This is used to identify the agent in the system.
        extensions: The extensions of the agent. This is used to identify the agent in the system.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Agent
    """
    return execute(
        EnsureAgentMutation,
        {"input": {"instanceId": instance_id, "name": name, "extensions": extensions}},
        rath=rath,
    ).ensure_agent


async def acreate_panel(
    name: str,
    kind: PanelKind,
    state: Optional[ID] = None,
    state_key: Optional[str] = None,
    reservation: Optional[ID] = None,
    instance_id: Optional[InstanceId] = None,
    state_accessors: Optional[Iterable[str]] = None,
    interface: Optional[str] = None,
    args: Optional[Args] = None,
    submit_on_change: Optional[bool] = None,
    submit_on_load: Optional[bool] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Panel:
    """CreatePanel


    Arguments:
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        kind: PanelKind (required)
        state: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        state_key: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        reservation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
        state_accessors: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required) (list)
        interface: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        args: The `Args` scalar type represents a Dictionary of arguments
        submit_on_change: The `Boolean` scalar type represents `true` or `false`.
        submit_on_load: The `Boolean` scalar type represents `true` or `false`.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Panel
    """
    return (
        await aexecute(
            CreatePanelMutation,
            {
                "input": {
                    "name": name,
                    "kind": kind,
                    "state": state,
                    "stateKey": state_key,
                    "reservation": reservation,
                    "instanceId": instance_id,
                    "stateAccessors": state_accessors,
                    "interface": interface,
                    "args": args,
                    "submitOnChange": submit_on_change,
                    "submitOnLoad": submit_on_load,
                }
            },
            rath=rath,
        )
    ).create_panel


def create_panel(
    name: str,
    kind: PanelKind,
    state: Optional[ID] = None,
    state_key: Optional[str] = None,
    reservation: Optional[ID] = None,
    instance_id: Optional[InstanceId] = None,
    state_accessors: Optional[Iterable[str]] = None,
    interface: Optional[str] = None,
    args: Optional[Args] = None,
    submit_on_change: Optional[bool] = None,
    submit_on_load: Optional[bool] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Panel:
    """CreatePanel


    Arguments:
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        kind: PanelKind (required)
        state: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        state_key: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        reservation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
        state_accessors: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required) (list)
        interface: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        args: The `Args` scalar type represents a Dictionary of arguments
        submit_on_change: The `Boolean` scalar type represents `true` or `false`.
        submit_on_load: The `Boolean` scalar type represents `true` or `false`.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Panel
    """
    return execute(
        CreatePanelMutation,
        {
            "input": {
                "name": name,
                "kind": kind,
                "state": state,
                "stateKey": state_key,
                "reservation": reservation,
                "instanceId": instance_id,
                "stateAccessors": state_accessors,
                "interface": interface,
                "args": args,
                "submitOnChange": submit_on_change,
                "submitOnLoad": submit_on_load,
            }
        },
        rath=rath,
    ).create_panel


async def areserve(
    instance_id: InstanceId,
    reference: Optional[str] = "027d7ed7-804b-4683-a6ef-9cd5161fc8b3",
    action: Optional[ID] = None,
    implementation: Optional[ID] = None,
    title: Optional[str] = None,
    hash: Optional[ActionHash] = None,
    binds: Optional[BindsInput] = None,
    assignation_id: Optional[ID] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Reservation:
    """reserve


    Arguments:
        reference: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        action: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        implementation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        title: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        hash: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
        binds:
        assignation_id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Reservation
    """
    return (
        await aexecute(
            ReserveMutation,
            {
                "input": {
                    "reference": reference,
                    "instanceId": instance_id,
                    "action": action,
                    "implementation": implementation,
                    "title": title,
                    "hash": hash,
                    "binds": binds,
                    "assignationId": assignation_id,
                }
            },
            rath=rath,
        )
    ).reserve


def reserve(
    instance_id: InstanceId,
    reference: Optional[str] = "027d7ed7-804b-4683-a6ef-9cd5161fc8b3",
    action: Optional[ID] = None,
    implementation: Optional[ID] = None,
    title: Optional[str] = None,
    hash: Optional[ActionHash] = None,
    binds: Optional[BindsInput] = None,
    assignation_id: Optional[ID] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Reservation:
    """reserve


    Arguments:
        reference: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        action: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        implementation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        title: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        hash: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
        binds:
        assignation_id: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Reservation
    """
    return execute(
        ReserveMutation,
        {
            "input": {
                "reference": reference,
                "instanceId": instance_id,
                "action": action,
                "implementation": implementation,
                "title": title,
                "hash": hash,
                "binds": binds,
                "assignationId": assignation_id,
            }
        },
        rath=rath,
    ).reserve


async def aunreserve(reservation: ID, rath: Optional[RekuestNextRath] = None) -> str:
    """unreserve


    Arguments:
        reservation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        str
    """
    return (
        await aexecute(
            UnreserveMutation, {"input": {"reservation": reservation}}, rath=rath
        )
    ).unreserve


def unreserve(reservation: ID, rath: Optional[RekuestNextRath] = None) -> str:
    """unreserve


    Arguments:
        reservation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        str
    """
    return execute(
        UnreserveMutation, {"input": {"reservation": reservation}}, rath=rath
    ).unreserve


async def acreate_shortcut(
    name: str,
    action: ID,
    args: Args,
    allow_quick: bool,
    use_returns: bool,
    toolbox: Optional[ID] = None,
    description: Optional[str] = None,
    implementation: Optional[ID] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Shortcut:
    """CreateShortcut


    Arguments:
        toolbox: The toolbox ID to create the shortcut in. If not provided, the shortcut will be created in the default toolbox.
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        description: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        action: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        implementation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        args: The `Args` scalar type represents a Dictionary of arguments (required)
        allow_quick: The `Boolean` scalar type represents `true` or `false`. (required)
        use_returns: The `Boolean` scalar type represents `true` or `false`. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Shortcut
    """
    return (
        await aexecute(
            CreateShortcutMutation,
            {
                "input": {
                    "toolbox": toolbox,
                    "name": name,
                    "description": description,
                    "action": action,
                    "implementation": implementation,
                    "args": args,
                    "allowQuick": allow_quick,
                    "useReturns": use_returns,
                }
            },
            rath=rath,
        )
    ).create_shortcut


def create_shortcut(
    name: str,
    action: ID,
    args: Args,
    allow_quick: bool,
    use_returns: bool,
    toolbox: Optional[ID] = None,
    description: Optional[str] = None,
    implementation: Optional[ID] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Shortcut:
    """CreateShortcut


    Arguments:
        toolbox: The toolbox ID to create the shortcut in. If not provided, the shortcut will be created in the default toolbox.
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        description: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        action: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        implementation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        args: The `Args` scalar type represents a Dictionary of arguments (required)
        allow_quick: The `Boolean` scalar type represents `true` or `false`. (required)
        use_returns: The `Boolean` scalar type represents `true` or `false`. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Shortcut
    """
    return execute(
        CreateShortcutMutation,
        {
            "input": {
                "toolbox": toolbox,
                "name": name,
                "description": description,
                "action": action,
                "implementation": implementation,
                "args": args,
                "allowQuick": allow_quick,
                "useReturns": use_returns,
            }
        },
        rath=rath,
    ).create_shortcut


async def aassign(
    instance_id: InstanceId,
    args: Args,
    cached: bool,
    log: bool,
    ephemeral: bool,
    action: Optional[ID] = None,
    implementation: Optional[ID] = None,
    agent: Optional[ID] = None,
    action_hash: Optional[ActionHash] = None,
    reservation: Optional[ID] = None,
    interface: Optional[str] = None,
    hooks: Optional[Iterable[HookInput]] = None,
    reference: Optional[str] = "6b21fcac-8166-410e-be97-0638aa8d9cf7",
    parent: Optional[ID] = None,
    is_hook: Optional[bool] = None,
    step: Optional[bool] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Assignation:
    """assign


    Arguments:
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        action: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        implementation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        agent: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        action_hash: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
        reservation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        interface: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        hooks: A hook is a function that is called when a action has reached a specific lifecycle point. Hooks are jsut actions that take an assignation as input and return a value. (required) (list)
        args: The `Args` scalar type represents a Dictionary of arguments (required)
        reference: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        parent: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        cached: The `Boolean` scalar type represents `true` or `false`. (required)
        log: The `Boolean` scalar type represents `true` or `false`. (required)
        ephemeral: The `Boolean` scalar type represents `true` or `false`. (required)
        is_hook: The `Boolean` scalar type represents `true` or `false`.
        step: The `Boolean` scalar type represents `true` or `false`.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Assignation
    """
    return (
        await aexecute(
            AssignMutation,
            {
                "input": {
                    "instanceId": instance_id,
                    "action": action,
                    "implementation": implementation,
                    "agent": agent,
                    "actionHash": action_hash,
                    "reservation": reservation,
                    "interface": interface,
                    "hooks": hooks,
                    "args": args,
                    "reference": reference,
                    "parent": parent,
                    "cached": cached,
                    "log": log,
                    "ephemeral": ephemeral,
                    "isHook": is_hook,
                    "step": step,
                }
            },
            rath=rath,
        )
    ).assign


def assign(
    instance_id: InstanceId,
    args: Args,
    cached: bool,
    log: bool,
    ephemeral: bool,
    action: Optional[ID] = None,
    implementation: Optional[ID] = None,
    agent: Optional[ID] = None,
    action_hash: Optional[ActionHash] = None,
    reservation: Optional[ID] = None,
    interface: Optional[str] = None,
    hooks: Optional[Iterable[HookInput]] = None,
    reference: Optional[str] = "6b21fcac-8166-410e-be97-0638aa8d9cf7",
    parent: Optional[ID] = None,
    is_hook: Optional[bool] = None,
    step: Optional[bool] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Assignation:
    """assign


    Arguments:
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        action: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        implementation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        agent: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        action_hash: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer
        reservation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        interface: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        hooks: A hook is a function that is called when a action has reached a specific lifecycle point. Hooks are jsut actions that take an assignation as input and return a value. (required) (list)
        args: The `Args` scalar type represents a Dictionary of arguments (required)
        reference: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        parent: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
        cached: The `Boolean` scalar type represents `true` or `false`. (required)
        log: The `Boolean` scalar type represents `true` or `false`. (required)
        ephemeral: The `Boolean` scalar type represents `true` or `false`. (required)
        is_hook: The `Boolean` scalar type represents `true` or `false`.
        step: The `Boolean` scalar type represents `true` or `false`.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Assignation
    """
    return execute(
        AssignMutation,
        {
            "input": {
                "instanceId": instance_id,
                "action": action,
                "implementation": implementation,
                "agent": agent,
                "actionHash": action_hash,
                "reservation": reservation,
                "interface": interface,
                "hooks": hooks,
                "args": args,
                "reference": reference,
                "parent": parent,
                "cached": cached,
                "log": log,
                "ephemeral": ephemeral,
                "isHook": is_hook,
                "step": step,
            }
        },
        rath=rath,
    ).assign


async def acancel(
    assignation: ID, rath: Optional[RekuestNextRath] = None
) -> Assignation:
    """cancel


    Arguments:
        assignation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Assignation
    """
    return (
        await aexecute(
            CancelMutation, {"input": {"assignation": assignation}}, rath=rath
        )
    ).cancel


def cancel(assignation: ID, rath: Optional[RekuestNextRath] = None) -> Assignation:
    """cancel


    Arguments:
        assignation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Assignation
    """
    return execute(
        CancelMutation, {"input": {"assignation": assignation}}, rath=rath
    ).cancel


async def ainterrupt(
    assignation: ID, rath: Optional[RekuestNextRath] = None
) -> Assignation:
    """interrupt


    Arguments:
        assignation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Assignation
    """
    return (
        await aexecute(
            InterruptMutation, {"input": {"assignation": assignation}}, rath=rath
        )
    ).interrupt


def interrupt(assignation: ID, rath: Optional[RekuestNextRath] = None) -> Assignation:
    """interrupt


    Arguments:
        assignation: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Assignation
    """
    return execute(
        InterruptMutation, {"input": {"assignation": assignation}}, rath=rath
    ).interrupt


async def acollect(
    drawers: Iterable[ID], rath: Optional[RekuestNextRath] = None
) -> Tuple[str, ...]:
    """collect

    Collect data from a assignation

    Arguments:
        drawers: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required) (list) (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[str]
    """
    return (
        await aexecute(CollectMutation, {"input": {"drawers": drawers}}, rath=rath)
    ).collect


def collect(
    drawers: Iterable[ID], rath: Optional[RekuestNextRath] = None
) -> Tuple[str, ...]:
    """collect

    Collect data from a assignation

    Arguments:
        drawers: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required) (list) (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[str]
    """
    return execute(CollectMutation, {"input": {"drawers": drawers}}, rath=rath).collect


async def acreate_dashboard(
    name: Optional[str] = None,
    panels: Optional[Iterable[ID]] = None,
    tree: Optional[UITreeInput] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Dashboard:
    """CreateDashboard


    Arguments:
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        panels: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required) (list)
        tree:
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Dashboard
    """
    return (
        await aexecute(
            CreateDashboardMutation,
            {"input": {"name": name, "panels": panels, "tree": tree}},
            rath=rath,
        )
    ).create_dashboard


def create_dashboard(
    name: Optional[str] = None,
    panels: Optional[Iterable[ID]] = None,
    tree: Optional[UITreeInput] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Dashboard:
    """CreateDashboard


    Arguments:
        name: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
        panels: The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID. (required) (list)
        tree:
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Dashboard
    """
    return execute(
        CreateDashboardMutation,
        {"input": {"name": name, "panels": panels, "tree": tree}},
        rath=rath,
    ).create_dashboard


async def ashelve(
    instance_id: InstanceId,
    identifier: Identifier,
    resource_id: str,
    label: Optional[str] = None,
    description: Optional[str] = None,
    rath: Optional[RekuestNextRath] = None,
) -> ShelveMutationShelveinmemorydrawer:
    """shelve


    Arguments:
        instance_id: The instance ID of the agent. This is used to identify the agent in the system.
        identifier: The identifier of the drawer. This is used to identify the drawer in the system.
        resource_id: The resource ID of the drawer.
        label: The label of the drawer. This is used to identify the drawer in the system.
        description: The description of the drawer. This is used to identify the drawer in the system.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        ShelveMutationShelveinmemorydrawer
    """
    return (
        await aexecute(
            ShelveMutation,
            {
                "input": {
                    "instanceId": instance_id,
                    "identifier": identifier,
                    "resourceId": resource_id,
                    "label": label,
                    "description": description,
                }
            },
            rath=rath,
        )
    ).shelve_in_memory_drawer


def shelve(
    instance_id: InstanceId,
    identifier: Identifier,
    resource_id: str,
    label: Optional[str] = None,
    description: Optional[str] = None,
    rath: Optional[RekuestNextRath] = None,
) -> ShelveMutationShelveinmemorydrawer:
    """shelve


    Arguments:
        instance_id: The instance ID of the agent. This is used to identify the agent in the system.
        identifier: The identifier of the drawer. This is used to identify the drawer in the system.
        resource_id: The resource ID of the drawer.
        label: The label of the drawer. This is used to identify the drawer in the system.
        description: The description of the drawer. This is used to identify the drawer in the system.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        ShelveMutationShelveinmemorydrawer
    """
    return execute(
        ShelveMutation,
        {
            "input": {
                "instanceId": instance_id,
                "identifier": identifier,
                "resourceId": resource_id,
                "label": label,
                "description": description,
            }
        },
        rath=rath,
    ).shelve_in_memory_drawer


async def aunshelve(
    instance_id: InstanceId, resource_id: str, rath: Optional[RekuestNextRath] = None
) -> str:
    """unshelve


    Arguments:
        instance_id: The instance ID of the agent. This is used to identify the agent in the system.
        resource_id: The resource ID of the drawer.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        str
    """
    return (
        await aexecute(
            UnshelveMutation,
            {"input": {"instanceId": instance_id, "resourceId": resource_id}},
            rath=rath,
        )
    ).unshelve_memory_drawer


def unshelve(
    instance_id: InstanceId, resource_id: str, rath: Optional[RekuestNextRath] = None
) -> str:
    """unshelve


    Arguments:
        instance_id: The instance ID of the agent. This is used to identify the agent in the system.
        resource_id: The resource ID of the drawer.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        str
    """
    return execute(
        UnshelveMutation,
        {"input": {"instanceId": instance_id, "resourceId": resource_id}},
        rath=rath,
    ).unshelve_memory_drawer


async def acreate_state_schema(
    state_schema: StateSchemaInput, rath: Optional[RekuestNextRath] = None
) -> StateSchema:
    """CreateStateSchema


    Arguments:
        state_schema: The input for creating a state schema. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        StateSchema
    """
    return (
        await aexecute(
            CreateStateSchemaMutation,
            {"input": {"stateSchema": state_schema}},
            rath=rath,
        )
    ).create_state_schema


def create_state_schema(
    state_schema: StateSchemaInput, rath: Optional[RekuestNextRath] = None
) -> StateSchema:
    """CreateStateSchema


    Arguments:
        state_schema: The input for creating a state schema. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        StateSchema
    """
    return execute(
        CreateStateSchemaMutation, {"input": {"stateSchema": state_schema}}, rath=rath
    ).create_state_schema


async def acreate_implementation(
    implementation: ImplementationInput,
    instance_id: InstanceId,
    extension: str,
    rath: Optional[RekuestNextRath] = None,
) -> Implementation:
    """createImplementation


    Arguments:
        implementation: A implementation is a blueprint for a action. It is composed of a definition, a list of dependencies, and a list of params. (required)
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        extension: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Implementation
    """
    return (
        await aexecute(
            CreateImplementationMutation,
            {
                "input": {
                    "implementation": implementation,
                    "instanceId": instance_id,
                    "extension": extension,
                }
            },
            rath=rath,
        )
    ).create_implementation


def create_implementation(
    implementation: ImplementationInput,
    instance_id: InstanceId,
    extension: str,
    rath: Optional[RekuestNextRath] = None,
) -> Implementation:
    """createImplementation


    Arguments:
        implementation: A implementation is a blueprint for a action. It is composed of a definition, a list of dependencies, and a list of params. (required)
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        extension: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Implementation
    """
    return execute(
        CreateImplementationMutation,
        {
            "input": {
                "implementation": implementation,
                "instanceId": instance_id,
                "extension": extension,
            }
        },
        rath=rath,
    ).create_implementation


async def aset_extension_implementations(
    implementations: Iterable[ImplementationInput],
    instance_id: InstanceId,
    extension: str,
    run_cleanup: bool,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Implementation, ...]:
    """SetExtensionImplementations


    Arguments:
        implementations: The implementations to set. This is used to identify the implementations in the system.
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        extension: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        run_cleanup: The `Boolean` scalar type represents `true` or `false`. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Implementation]
    """
    return (
        await aexecute(
            SetExtensionImplementationsMutation,
            {
                "input": {
                    "implementations": implementations,
                    "instanceId": instance_id,
                    "extension": extension,
                    "runCleanup": run_cleanup,
                }
            },
            rath=rath,
        )
    ).set_extension_implementations


def set_extension_implementations(
    implementations: Iterable[ImplementationInput],
    instance_id: InstanceId,
    extension: str,
    run_cleanup: bool,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Implementation, ...]:
    """SetExtensionImplementations


    Arguments:
        implementations: The implementations to set. This is used to identify the implementations in the system.
        instance_id: The `ArrayLike` scalar type represents a reference to a store previously created by the user n a datalayer (required)
        extension: The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text. (required)
        run_cleanup: The `Boolean` scalar type represents `true` or `false`. (required)
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Implementation]
    """
    return execute(
        SetExtensionImplementationsMutation,
        {
            "input": {
                "implementations": implementations,
                "instanceId": instance_id,
                "extension": extension,
                "runCleanup": run_cleanup,
            }
        },
        rath=rath,
    ).set_extension_implementations


async def awatch_reservations(
    instance_id: InstanceId, rath: Optional[RekuestNextRath] = None
) -> AsyncIterator[Reservation]:
    """WatchReservations


    Arguments:
        instance_id (InstanceId): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Reservation
    """
    async for event in asubscribe(
        WatchReservationsSubscription, {"instanceId": instance_id}, rath=rath
    ):
        yield event.reservations


def watch_reservations(
    instance_id: InstanceId, rath: Optional[RekuestNextRath] = None
) -> Iterator[Reservation]:
    """WatchReservations


    Arguments:
        instance_id (InstanceId): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Reservation
    """
    for event in subscribe(
        WatchReservationsSubscription, {"instanceId": instance_id}, rath=rath
    ):
        yield event.reservations


async def awatch_assignations(
    instance_id: InstanceId, rath: Optional[RekuestNextRath] = None
) -> AsyncIterator[AssignationChangeEvent]:
    """WatchAssignations


    Arguments:
        instance_id (InstanceId): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        AssignationChangeEvent
    """
    async for event in asubscribe(
        WatchAssignationsSubscription, {"instanceId": instance_id}, rath=rath
    ):
        yield event.assignations


def watch_assignations(
    instance_id: InstanceId, rath: Optional[RekuestNextRath] = None
) -> Iterator[AssignationChangeEvent]:
    """WatchAssignations


    Arguments:
        instance_id (InstanceId): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        AssignationChangeEvent
    """
    for event in subscribe(
        WatchAssignationsSubscription, {"instanceId": instance_id}, rath=rath
    ):
        yield event.assignations


async def aget_testcase(id: ID, rath: Optional[RekuestNextRath] = None) -> TestCase:
    """get_testcase


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        TestCase
    """
    return (await aexecute(Get_testcaseQuery, {"id": id}, rath=rath)).test_case


def get_testcase(id: ID, rath: Optional[RekuestNextRath] = None) -> TestCase:
    """get_testcase


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        TestCase
    """
    return execute(Get_testcaseQuery, {"id": id}, rath=rath).test_case


async def aget_testresult(id: ID, rath: Optional[RekuestNextRath] = None) -> TestResult:
    """get_testresult


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        TestResult
    """
    return (await aexecute(Get_testresultQuery, {"id": id}, rath=rath)).test_result


def get_testresult(id: ID, rath: Optional[RekuestNextRath] = None) -> TestResult:
    """get_testresult


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        TestResult
    """
    return execute(Get_testresultQuery, {"id": id}, rath=rath).test_result


async def asearch_testcases(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Search_testcasesQueryOptions, ...]:
    """search_testcases


    Arguments:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Search_testcasesQueryTestcases]
    """
    return (
        await aexecute(
            Search_testcasesQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_testcases(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Search_testcasesQueryOptions, ...]:
    """search_testcases


    Arguments:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Search_testcasesQueryTestcases]
    """
    return execute(
        Search_testcasesQuery, {"search": search, "values": values}, rath=rath
    ).options


async def asearch_testresults(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Search_testresultsQueryOptions, ...]:
    """search_testresults


    Arguments:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Search_testresultsQueryTestresults]
    """
    return (
        await aexecute(
            Search_testresultsQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_testresults(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Search_testresultsQueryOptions, ...]:
    """search_testresults


    Arguments:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Search_testresultsQueryTestresults]
    """
    return execute(
        Search_testresultsQuery, {"search": search, "values": values}, rath=rath
    ).options


async def aget_me_actions(
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[GetMeActionsQueryActions, ...]:
    """GetMeActions


    Arguments:
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[GetMeActionsQueryActions]
    """
    return (await aexecute(GetMeActionsQuery, {}, rath=rath)).actions


def get_me_actions(
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[GetMeActionsQueryActions, ...]:
    """GetMeActions


    Arguments:
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[GetMeActionsQueryActions]
    """
    return execute(GetMeActionsQuery, {}, rath=rath).actions


async def aget_agent(id: ID, rath: Optional[RekuestNextRath] = None) -> Agent:
    """GetAgent


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Agent
    """
    return (await aexecute(GetAgentQuery, {"id": id}, rath=rath)).agent


def get_agent(id: ID, rath: Optional[RekuestNextRath] = None) -> Agent:
    """GetAgent


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Agent
    """
    return execute(GetAgentQuery, {"id": id}, rath=rath).agent


async def aget_panel(id: ID, rath: Optional[RekuestNextRath] = None) -> Panel:
    """GetPanel


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Panel
    """
    return (await aexecute(GetPanelQuery, {"id": id}, rath=rath)).panel


def get_panel(id: ID, rath: Optional[RekuestNextRath] = None) -> Panel:
    """GetPanel


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Panel
    """
    return execute(GetPanelQuery, {"id": id}, rath=rath).panel


async def aget_reservation(
    id: ID, rath: Optional[RekuestNextRath] = None
) -> Reservation:
    """get_reservation


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Reservation
    """
    return (await aexecute(Get_reservationQuery, {"id": id}, rath=rath)).reservation


def get_reservation(id: ID, rath: Optional[RekuestNextRath] = None) -> Reservation:
    """get_reservation


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Reservation
    """
    return execute(Get_reservationQuery, {"id": id}, rath=rath).reservation


async def areservations(
    instance_id: InstanceId, rath: Optional[RekuestNextRath] = None
) -> Tuple[Reservation, ...]:
    """reservations


    Arguments:
        instance_id (InstanceId): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Reservation]
    """
    return (
        await aexecute(ReservationsQuery, {"instance_id": instance_id}, rath=rath)
    ).reservations


def reservations(
    instance_id: InstanceId, rath: Optional[RekuestNextRath] = None
) -> Tuple[Reservation, ...]:
    """reservations


    Arguments:
        instance_id (InstanceId): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Reservation]
    """
    return execute(
        ReservationsQuery, {"instance_id": instance_id}, rath=rath
    ).reservations


async def alist_shortcuts(
    pagination: Optional[OffsetPaginationInput] = None,
    filters: Optional[ShortcutFilter] = None,
    order: Optional[ShortcutOrder] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[ListShortcut, ...]:
    """ListShortcuts


    Arguments:
        pagination (Optional[OffsetPaginationInput], optional): No description.
        filters (Optional[ShortcutFilter], optional): No description.
        order (Optional[ShortcutOrder], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[ListShortcut]
    """
    return (
        await aexecute(
            ListShortcutsQuery,
            {"pagination": pagination, "filters": filters, "order": order},
            rath=rath,
        )
    ).shortcuts


def list_shortcuts(
    pagination: Optional[OffsetPaginationInput] = None,
    filters: Optional[ShortcutFilter] = None,
    order: Optional[ShortcutOrder] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[ListShortcut, ...]:
    """ListShortcuts


    Arguments:
        pagination (Optional[OffsetPaginationInput], optional): No description.
        filters (Optional[ShortcutFilter], optional): No description.
        order (Optional[ShortcutOrder], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[ListShortcut]
    """
    return execute(
        ListShortcutsQuery,
        {"pagination": pagination, "filters": filters, "order": order},
        rath=rath,
    ).shortcuts


async def aget_shortcut(id: ID, rath: Optional[RekuestNextRath] = None) -> Shortcut:
    """GetShortcut


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Shortcut
    """
    return (await aexecute(GetShortcutQuery, {"id": id}, rath=rath)).shortcut


def get_shortcut(id: ID, rath: Optional[RekuestNextRath] = None) -> Shortcut:
    """GetShortcut


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Shortcut
    """
    return execute(GetShortcutQuery, {"id": id}, rath=rath).shortcut


async def arequests(
    instance_id: InstanceId, rath: Optional[RekuestNextRath] = None
) -> Tuple[Assignation, ...]:
    """requests


    Arguments:
        instance_id (InstanceId): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Assignation]
    """
    return (
        await aexecute(RequestsQuery, {"instance_id": instance_id}, rath=rath)
    ).assignations


def requests(
    instance_id: InstanceId, rath: Optional[RekuestNextRath] = None
) -> Tuple[Assignation, ...]:
    """requests


    Arguments:
        instance_id (InstanceId): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Assignation]
    """
    return execute(RequestsQuery, {"instance_id": instance_id}, rath=rath).assignations


async def aget_event(
    id: Optional[ID] = None, rath: Optional[RekuestNextRath] = None
) -> Tuple[AssignationEvent, ...]:
    """GetEvent


    Arguments:
        id (Optional[ID], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[AssignationEvent]
    """
    return (await aexecute(GetEventQuery, {"id": id}, rath=rath)).event


def get_event(
    id: Optional[ID] = None, rath: Optional[RekuestNextRath] = None
) -> Tuple[AssignationEvent, ...]:
    """GetEvent


    Arguments:
        id (Optional[ID], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[AssignationEvent]
    """
    return execute(GetEventQuery, {"id": id}, rath=rath).event


async def aget_dashboard(id: ID, rath: Optional[RekuestNextRath] = None) -> Dashboard:
    """GetDashboard


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Dashboard
    """
    return (await aexecute(GetDashboardQuery, {"id": id}, rath=rath)).dashboard


def get_dashboard(id: ID, rath: Optional[RekuestNextRath] = None) -> Dashboard:
    """GetDashboard


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Dashboard
    """
    return execute(GetDashboardQuery, {"id": id}, rath=rath).dashboard


async def alist_toolboxes(
    pagination: Optional[OffsetPaginationInput] = None,
    filters: Optional[ToolboxFilter] = None,
    order: Optional[ToolboxOrder] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[ListToolbox, ...]:
    """ListToolboxes


    Arguments:
        pagination (Optional[OffsetPaginationInput], optional): No description.
        filters (Optional[ToolboxFilter], optional): No description.
        order (Optional[ToolboxOrder], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[ListToolbox]
    """
    return (
        await aexecute(
            ListToolboxesQuery,
            {"pagination": pagination, "filters": filters, "order": order},
            rath=rath,
        )
    ).toolboxes


def list_toolboxes(
    pagination: Optional[OffsetPaginationInput] = None,
    filters: Optional[ToolboxFilter] = None,
    order: Optional[ToolboxOrder] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[ListToolbox, ...]:
    """ListToolboxes


    Arguments:
        pagination (Optional[OffsetPaginationInput], optional): No description.
        filters (Optional[ToolboxFilter], optional): No description.
        order (Optional[ToolboxOrder], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[ListToolbox]
    """
    return execute(
        ListToolboxesQuery,
        {"pagination": pagination, "filters": filters, "order": order},
        rath=rath,
    ).toolboxes


async def aget_toolbox(id: ID, rath: Optional[RekuestNextRath] = None) -> Toolbox:
    """GetToolbox


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Toolbox
    """
    return (await aexecute(GetToolboxQuery, {"id": id}, rath=rath)).toolbox


def get_toolbox(id: ID, rath: Optional[RekuestNextRath] = None) -> Toolbox:
    """GetToolbox


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Toolbox
    """
    return execute(GetToolboxQuery, {"id": id}, rath=rath).toolbox


async def aget_implementation(
    id: ID, rath: Optional[RekuestNextRath] = None
) -> Implementation:
    """get_implementation


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Implementation
    """
    return (
        await aexecute(Get_implementationQuery, {"id": id}, rath=rath)
    ).implementation


def get_implementation(
    id: ID, rath: Optional[RekuestNextRath] = None
) -> Implementation:
    """get_implementation


    Arguments:
        id (ID): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Implementation
    """
    return execute(Get_implementationQuery, {"id": id}, rath=rath).implementation


async def asearch_implementations(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Search_implementationsQueryOptions, ...]:
    """search_implementations


    Arguments:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Search_implementationsQueryImplementations]
    """
    return (
        await aexecute(
            Search_implementationsQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_implementations(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Search_implementationsQueryOptions, ...]:
    """search_implementations


    Arguments:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Search_implementationsQueryImplementations]
    """
    return execute(
        Search_implementationsQuery, {"search": search, "values": values}, rath=rath
    ).options


async def aimplementations_for(
    hash: ActionHash, rath: Optional[RekuestNextRath] = None
) -> Tuple[Implementation, ...]:
    """implementations_for


    Arguments:
        hash (ActionHash): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Implementation]
    """
    return (
        await aexecute(Implementations_forQuery, {"hash": hash}, rath=rath)
    ).implementations


def implementations_for(
    hash: ActionHash, rath: Optional[RekuestNextRath] = None
) -> Tuple[Implementation, ...]:
    """implementations_for


    Arguments:
        hash (ActionHash): No description
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Implementation]
    """
    return execute(Implementations_forQuery, {"hash": hash}, rath=rath).implementations


async def amy_implementation_at(
    instance_id: str,
    interface: Optional[str] = None,
    action_id: Optional[ID] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Implementation:
    """MyImplementationAt


    Arguments:
        instance_id (str): No description
        interface (Optional[str], optional): No description.
        action_id (Optional[ID], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Implementation
    """
    return (
        await aexecute(
            MyImplementationAtQuery,
            {"instanceId": instance_id, "interface": interface, "actionId": action_id},
            rath=rath,
        )
    ).my_implementation_at


def my_implementation_at(
    instance_id: str,
    interface: Optional[str] = None,
    action_id: Optional[ID] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Implementation:
    """MyImplementationAt


    Arguments:
        instance_id (str): No description
        interface (Optional[str], optional): No description.
        action_id (Optional[ID], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Implementation
    """
    return execute(
        MyImplementationAtQuery,
        {"instanceId": instance_id, "interface": interface, "actionId": action_id},
        rath=rath,
    ).my_implementation_at


async def afind(
    id: Optional[ID] = None,
    implementation: Optional[ID] = None,
    hash: Optional[ActionHash] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Action:
    """find


    Arguments:
        id (Optional[ID], optional): No description.
        implementation (Optional[ID], optional): No description.
        hash (Optional[ActionHash], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Action
    """
    return (
        await aexecute(
            FindQuery,
            {"id": id, "implementation": implementation, "hash": hash},
            rath=rath,
        )
    ).action


def find(
    id: Optional[ID] = None,
    implementation: Optional[ID] = None,
    hash: Optional[ActionHash] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Action:
    """find


    Arguments:
        id (Optional[ID], optional): No description.
        implementation (Optional[ID], optional): No description.
        hash (Optional[ActionHash], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        Action
    """
    return execute(
        FindQuery, {"id": id, "implementation": implementation, "hash": hash}, rath=rath
    ).action


async def aretrieveall(rath: Optional[RekuestNextRath] = None) -> Tuple[Action, ...]:
    """retrieveall


    Arguments:
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Action]
    """
    return (await aexecute(RetrieveallQuery, {}, rath=rath)).actions


def retrieveall(rath: Optional[RekuestNextRath] = None) -> Tuple[Action, ...]:
    """retrieveall


    Arguments:
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Action]
    """
    return execute(RetrieveallQuery, {}, rath=rath).actions


async def asearch_actions(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Search_actionsQueryOptions, ...]:
    """search_actions


    Arguments:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Search_actionsQueryActions]
    """
    return (
        await aexecute(
            Search_actionsQuery, {"search": search, "values": values}, rath=rath
        )
    ).options


def search_actions(
    search: Optional[str] = None,
    values: Optional[List[ID]] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[Search_actionsQueryOptions, ...]:
    """search_actions


    Arguments:
        search (Optional[str], optional): No description.
        values (Optional[List[ID]], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[Search_actionsQueryActions]
    """
    return execute(
        Search_actionsQuery, {"search": search, "values": values}, rath=rath
    ).options


async def aprimary_actions(
    pagination: Optional[OffsetPaginationInput] = None,
    identifier: Optional[str] = None,
    order: Optional[ActionOrder] = None,
    search: Optional[str] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[PrimaryAction, ...]:
    """PrimaryActions


    Arguments:
        pagination (Optional[OffsetPaginationInput], optional): No description.
        identifier (Optional[str], optional): No description.
        order (Optional[ActionOrder], optional): No description.
        search (Optional[str], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[PrimaryAction]
    """
    return (
        await aexecute(
            PrimaryActionsQuery,
            {
                "pagination": pagination,
                "identifier": identifier,
                "order": order,
                "search": search,
            },
            rath=rath,
        )
    ).actions


def primary_actions(
    pagination: Optional[OffsetPaginationInput] = None,
    identifier: Optional[str] = None,
    order: Optional[ActionOrder] = None,
    search: Optional[str] = None,
    rath: Optional[RekuestNextRath] = None,
) -> Tuple[PrimaryAction, ...]:
    """PrimaryActions


    Arguments:
        pagination (Optional[OffsetPaginationInput], optional): No description.
        identifier (Optional[str], optional): No description.
        order (Optional[ActionOrder], optional): No description.
        search (Optional[str], optional): No description.
        rath (rekuest_next.rath.RekuestNextRath, optional): The arkitekt rath client

    Returns:
        List[PrimaryAction]
    """
    return execute(
        PrimaryActionsQuery,
        {
            "pagination": pagination,
            "identifier": identifier,
            "order": order,
            "search": search,
        },
        rath=rath,
    ).actions


AssignInput.model_rebuild()
AssignWidgetInput.model_rebuild()
CreateDashboardInput.model_rebuild()
CreateImplementationInput.model_rebuild()
CreateStateSchemaInput.model_rebuild()
DefinitionInput.model_rebuild()
DependencyInput.model_rebuild()
ImplementationInput.model_rebuild()
PortDemandInput.model_rebuild()
PortGroupInput.model_rebuild()
PortInput.model_rebuild()
PortMatchInput.model_rebuild()
ShortcutFilter.model_rebuild()
ToolboxFilter.model_rebuild()
UIChildInput.model_rebuild()
UITreeInput.model_rebuild()
