"""
This type stub file was generated by pyright.
"""

import pathlib
import numpy as np
import pyarrow as pa
import pyarrow.fs as pa_fs
from datetime import date, datetime
from functools import singledispatch
from typing import Any, Optional, Tuple, Union

def safe_import_adlfs(): # -> Any | None:
    ...

adlfs = ...
def get_uri_scheme(uri: str) -> str:
    """
    Get the scheme of a URI. If the URI does not have a scheme, assume it is a file URI.

    Parameters
    ----------
    uri : str
        The URI to parse.

    Returns
    -------
    str: The scheme of the URI.
    """
    ...

def get_uri_location(uri: str) -> str:
    """
    Get the location of a URI. If the parameter is not a url, assumes it is just a path

    Parameters
    ----------
    uri : str
        The URI to parse.

    Returns
    -------
    str: Location part of the URL, without scheme
    """
    ...

def fs_from_uri(uri: str) -> Tuple[pa_fs.FileSystem, str]:
    """
    Get a PyArrow FileSystem from a URI, handling extra environment variables.
    """
    ...

def join_uri(base: Union[str, pathlib.Path], *parts: str) -> str:
    """
    Join a URI with multiple parts, handles both local and remote paths

    Parameters
    ----------
    base : str
        The base URI
    parts : str
        The parts to join to the base URI, each separated by the
        appropriate path separator for the URI scheme and OS
    """
    ...

def attempt_import_or_raise(module: str, mitigation=...): # -> ModuleType:
    """
    Import the specified module. If the module is not installed,
    raise an ImportError with a helpful message.

    Parameters
    ----------
    module : str
        The name of the module to import
    mitigation : Optional[str]
        The package(s) to install to mitigate the error.
        If not provided then the module name will be used.
    """
    ...

def flatten_columns(tbl: pa.Table, flatten: Optional[Union[int, bool]] = ...):
    """
    Flatten all struct columns in a table.

    Parameters
    ----------
    flatten: Optional[Union[int, bool]]
        If flatten is True, flatten all nested columns.
        If flatten is an integer, flatten the nested columns up to the
        specified depth.
        If unspecified, do not flatten the nested columns.
    """
    ...

def inf_vector_column_query(schema: pa.Schema) -> str:
    """
    Get the vector column name

    Parameters
    ----------
    schema : pa.Schema
        The schema of the vector column.

    Returns
    -------
    str: the vector column name.
    """
    ...

def is_vector_column(data_type: pa.DataType) -> bool:
    """
    Check if the column is a vector column.

    Parameters
    ----------
    data_type : pa.DataType
        The data type of the column.

    Returns
    -------
    bool: True if the column is a vector column.
    """
    ...

def infer_vector_column_name(schema: pa.Schema, query_type: str, query: Optional[Any], vector_column_name: Optional[str]): # -> str | None:
    ...

@singledispatch
def value_to_sql(value):
    ...

@value_to_sql.register(str)
def _(value: str): # -> str:
    ...

@value_to_sql.register(bytes)
def _(value: bytes): # -> str:
    """Convert bytes to a hex string literal.

    See https://datafusion.apache.org/user-guide/sql/data_types.html#binary-types
    """
    ...

@value_to_sql.register(int)
def _(value: int): # -> str:
    ...

@value_to_sql.register(float)
def _(value: float): # -> str:
    ...

@value_to_sql.register(bool)
def _(value: bool): # -> str:
    ...

@value_to_sql.register(type(None))
def _(value: type(None)): # -> Literal['NULL']:
    ...

@value_to_sql.register(datetime)
def _(value: datetime): # -> str:
    ...

@value_to_sql.register(date)
def _(value: date): # -> str:
    ...

@value_to_sql.register(list)
def _(value: list): # -> LiteralString:
    ...

@value_to_sql.register(np.ndarray)
def _(value: np.ndarray):
    ...

def deprecated(func): # -> _Wrapped[Callable[..., Any], Any, Callable[..., Any], Any]:
    """This is a decorator which can be used to mark functions
    as deprecated. It will result in a warning being emitted
    when the function is used."""
    ...

def validate_table_name(name: str): # -> None:
    """Verify the table name is valid."""
    ...

def add_note(base_exception: BaseException, note: str): # -> None:
    ...

