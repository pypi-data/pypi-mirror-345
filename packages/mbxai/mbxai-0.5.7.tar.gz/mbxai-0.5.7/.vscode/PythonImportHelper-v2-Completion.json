[
    {
        "label": "runpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "runpy",
        "description": "runpy",
        "detail": "runpy",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "site",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "site",
        "description": "site",
        "detail": "site",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "cast",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "httpx",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "httpx",
        "description": "httpx",
        "detail": "httpx",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "TypeAdapter",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "ValidationError",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "FastMCP",
        "importPath": "mcp.server.fastmcp",
        "description": "mcp.server.fastmcp",
        "isExtraImport": true,
        "detail": "mcp.server.fastmcp",
        "documentation": {}
    },
    {
        "label": "FastMCP",
        "importPath": "mcp.server.fastmcp",
        "description": "mcp.server.fastmcp",
        "isExtraImport": true,
        "detail": "mcp.server.fastmcp",
        "documentation": {}
    },
    {
        "label": "FastMCP",
        "importPath": "mcp.server.fastmcp",
        "description": "mcp.server.fastmcp",
        "isExtraImport": true,
        "detail": "mcp.server.fastmcp",
        "documentation": {}
    },
    {
        "label": "FastAPI",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "Body",
        "importPath": "fastapi",
        "description": "fastapi",
        "isExtraImport": true,
        "detail": "fastapi",
        "documentation": {}
    },
    {
        "label": "OpenAI",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "OpenAIError",
        "importPath": "openai",
        "description": "openai",
        "isExtraImport": true,
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "hello_world",
        "importPath": "mbxai.core",
        "description": "mbxai.core",
        "isExtraImport": true,
        "detail": "mbxai.core",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "AsyncMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "Mock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "TestClient",
        "importPath": "fastapi.testclient",
        "description": "fastapi.testclient",
        "isExtraImport": true,
        "detail": "fastapi.testclient",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "MCPClient",
        "importPath": "mbxai.mcp",
        "description": "mbxai.mcp",
        "isExtraImport": true,
        "detail": "mbxai.mcp",
        "documentation": {}
    },
    {
        "label": "MCPServer",
        "importPath": "mbxai.mcp",
        "description": "mbxai.mcp",
        "isExtraImport": true,
        "detail": "mbxai.mcp",
        "documentation": {}
    },
    {
        "label": "MCPTool",
        "importPath": "mbxai.mcp.client",
        "description": "mbxai.mcp.client",
        "isExtraImport": true,
        "detail": "mbxai.mcp.client",
        "documentation": {}
    },
    {
        "label": "OpenRouterClient",
        "importPath": "mbxai.openrouter",
        "description": "mbxai.openrouter",
        "isExtraImport": true,
        "detail": "mbxai.openrouter",
        "documentation": {}
    },
    {
        "label": "OpenRouterClient",
        "importPath": "mbxai.openrouter",
        "description": "mbxai.openrouter",
        "isExtraImport": true,
        "detail": "mbxai.openrouter",
        "documentation": {}
    },
    {
        "label": "OpenRouterConfig",
        "importPath": "mbxai.openrouter",
        "description": "mbxai.openrouter",
        "isExtraImport": true,
        "detail": "mbxai.openrouter",
        "documentation": {}
    },
    {
        "label": "OpenRouterClient",
        "importPath": "mbxai.openrouter",
        "description": "mbxai.openrouter",
        "isExtraImport": true,
        "detail": "mbxai.openrouter",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "OpenRouterModel",
        "importPath": "mbxai.openrouter.models",
        "description": "mbxai.openrouter.models",
        "isExtraImport": true,
        "detail": "mbxai.openrouter.models",
        "documentation": {}
    },
    {
        "label": "ToolClient",
        "importPath": "mbxai.tools",
        "description": "mbxai.tools",
        "isExtraImport": true,
        "detail": "mbxai.tools",
        "documentation": {}
    },
    {
        "label": "Tool",
        "importPath": "mbxai.tools",
        "description": "mbxai.tools",
        "isExtraImport": true,
        "detail": "mbxai.tools",
        "documentation": {}
    },
    {
        "label": "ToolCall",
        "importPath": "mbxai.tools",
        "description": "mbxai.tools",
        "isExtraImport": true,
        "detail": "mbxai.tools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "bin_dir",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "bin_dir = os.path.dirname(abs_file)\nbase = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"mbxai\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.12/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "base",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "base = bin_dir[: -len(\"bin\") - 1]  # strip away the bin part from the __file__, plus the path separator\n# prepend bin to PATH (this file is inside the bin directory)\nos.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"mbxai\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.12/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"PATH\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"PATH\"] = os.pathsep.join([bin_dir, *os.environ.get(\"PATH\", \"\").split(os.pathsep)])\nos.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"mbxai\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.12/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV\"] = base  # virtual env is right above bin directory\nos.environ[\"VIRTUAL_ENV_PROMPT\"] = \"mbxai\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.12/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "os.environ[\"VIRTUAL_ENV_PROMPT\"]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "os.environ[\"VIRTUAL_ENV_PROMPT\"] = \"mbxai\" or os.path.basename(base)  # noqa: SIM222\n# add the virtual environments libraries to the host python import mechanism\nprev_length = len(sys.path)\nfor lib in \"../lib/python3.12/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "prev_length",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "prev_length = len(sys.path)\nfor lib in \"../lib/python3.12/site-packages\".split(os.pathsep):\n    path = os.path.realpath(os.path.join(bin_dir, lib))\n    site.addsitedir(path)\nsys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.path[:]",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.path[:] = sys.path[prev_length:] + sys.path[0:prev_length]\nsys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.real_prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.real_prefix = sys.prefix\nsys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "sys.prefix",
        "kind": 5,
        "importPath": ".venv.bin.activate_this",
        "description": ".venv.bin.activate_this",
        "peekOfCode": "sys.prefix = base",
        "detail": ".venv.bin.activate_this",
        "documentation": {}
    },
    {
        "label": "MCPTool",
        "kind": 6,
        "importPath": "src.mbxai.mcp.client",
        "description": "src.mbxai.mcp.client",
        "peekOfCode": "class MCPTool(Tool):\n    \"\"\"MCP tool definition.\"\"\"\n    internal_url: str | None = Field(default=None, description=\"The internal URL to invoke the tool\")\n    service: str = Field(description=\"The service that provides the tool\")\n    strict: bool = Field(default=True, description=\"Whether the tool response is strictly validated\")\n    input_schema: dict[str, Any] = Field(description=\"The input schema for the tool\")\n    function: Callable[..., Any] | None = Field(default=None, description=\"The function that implements the tool\")\n    def to_openai_function(self) -> dict[str, Any]:\n        \"\"\"Convert the tool to an OpenAI function definition.\"\"\"\n        return {",
        "detail": "src.mbxai.mcp.client",
        "documentation": {}
    },
    {
        "label": "MCPClient",
        "kind": 6,
        "importPath": "src.mbxai.mcp.client",
        "description": "src.mbxai.mcp.client",
        "peekOfCode": "class MCPClient(ToolClient):\n    \"\"\"MCP client that extends ToolClient to support MCP tool servers.\"\"\"\n    def __init__(self, openrouter_client: OpenRouterClient):\n        \"\"\"Initialize the MCP client.\"\"\"\n        super().__init__(openrouter_client)\n        self._mcp_servers: dict[str, str] = {}\n        self._http_client = httpx.AsyncClient()\n    async def __aenter__(self):\n        \"\"\"Enter the async context.\"\"\"\n        return self",
        "detail": "src.mbxai.mcp.client",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.mbxai.mcp.client",
        "description": "src.mbxai.mcp.client",
        "peekOfCode": "logger = logging.getLogger(__name__)\nT = TypeVar(\"T\", bound=BaseModel)\nclass MCPTool(Tool):\n    \"\"\"MCP tool definition.\"\"\"\n    internal_url: str | None = Field(default=None, description=\"The internal URL to invoke the tool\")\n    service: str = Field(description=\"The service that provides the tool\")\n    strict: bool = Field(default=True, description=\"Whether the tool response is strictly validated\")\n    input_schema: dict[str, Any] = Field(description=\"The input schema for the tool\")\n    function: Callable[..., Any] | None = Field(default=None, description=\"The function that implements the tool\")\n    def to_openai_function(self) -> dict[str, Any]:",
        "detail": "src.mbxai.mcp.client",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "src.mbxai.mcp.client",
        "description": "src.mbxai.mcp.client",
        "peekOfCode": "T = TypeVar(\"T\", bound=BaseModel)\nclass MCPTool(Tool):\n    \"\"\"MCP tool definition.\"\"\"\n    internal_url: str | None = Field(default=None, description=\"The internal URL to invoke the tool\")\n    service: str = Field(description=\"The service that provides the tool\")\n    strict: bool = Field(default=True, description=\"Whether the tool response is strictly validated\")\n    input_schema: dict[str, Any] = Field(description=\"The input schema for the tool\")\n    function: Callable[..., Any] | None = Field(default=None, description=\"The function that implements the tool\")\n    def to_openai_function(self) -> dict[str, Any]:\n        \"\"\"Convert the tool to an OpenAI function definition.\"\"\"",
        "detail": "src.mbxai.mcp.client",
        "documentation": {}
    },
    {
        "label": "WeatherInput",
        "kind": 6,
        "importPath": "src.mbxai.mcp.example",
        "description": "src.mbxai.mcp.example",
        "peekOfCode": "class WeatherInput(BaseModel):\n    location: str\n    units: str = \"celsius\"  # Default to celsius, can be \"fahrenheit\" or \"celsius\"\nclass WeatherOutput(BaseModel):\n    location: str\n    temperature: float\n    units: str\n    condition: str\n    humidity: float\n@mcp.tool()",
        "detail": "src.mbxai.mcp.example",
        "documentation": {}
    },
    {
        "label": "WeatherOutput",
        "kind": 6,
        "importPath": "src.mbxai.mcp.example",
        "description": "src.mbxai.mcp.example",
        "peekOfCode": "class WeatherOutput(BaseModel):\n    location: str\n    temperature: float\n    units: str\n    condition: str\n    humidity: float\n@mcp.tool()\nasync def get_weather(input: WeatherInput) -> dict[str, Any]:\n    \"\"\"Get weather information for a location.\n    Args:",
        "detail": "src.mbxai.mcp.example",
        "documentation": {}
    },
    {
        "label": "mcp",
        "kind": 5,
        "importPath": "src.mbxai.mcp.example",
        "description": "src.mbxai.mcp.example",
        "peekOfCode": "mcp = FastMCP(\"weather-service\")\n# Define input/output models\nclass WeatherInput(BaseModel):\n    location: str\n    units: str = \"celsius\"  # Default to celsius, can be \"fahrenheit\" or \"celsius\"\nclass WeatherOutput(BaseModel):\n    location: str\n    temperature: float\n    units: str\n    condition: str",
        "detail": "src.mbxai.mcp.example",
        "documentation": {}
    },
    {
        "label": "Tool",
        "kind": 6,
        "importPath": "src.mbxai.mcp.server",
        "description": "src.mbxai.mcp.server",
        "peekOfCode": "class Tool(BaseModel):\n    \"\"\"MCP tool definition.\"\"\"\n    model_config = ConfigDict(strict=True)\n    name: str = Field(description=\"The name of the tool\")\n    description: str = Field(description=\"The description of what the tool does\")\n    input_schema: dict[str, Any] = Field(description=\"The input schema for the tool\")\n    strict: bool = Field(default=True, description=\"Whether the tool response is strictly validated\")\n    function: Callable[..., Any] = Field(description=\"The tool function\", exclude=True)\nclass MCPServer:\n    \"\"\"MCP server implementation.\"\"\"",
        "detail": "src.mbxai.mcp.server",
        "documentation": {}
    },
    {
        "label": "MCPServer",
        "kind": 6,
        "importPath": "src.mbxai.mcp.server",
        "description": "src.mbxai.mcp.server",
        "peekOfCode": "class MCPServer:\n    \"\"\"MCP server implementation.\"\"\"\n    def __init__(self, name: str, description: str | None = None):\n        \"\"\"Initialize the MCP server.\"\"\"\n        self.name = name\n        self.description = description or f\"A Model Context Protocol (MCP) tool server for {name}\"\n        # Create FastAPI app\n        self.app = FastAPI(\n            title=self.name,\n            description=self.description,",
        "detail": "src.mbxai.mcp.server",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "src.mbxai.mcp.server",
        "description": "src.mbxai.mcp.server",
        "peekOfCode": "T = TypeVar(\"T\", bound=BaseModel)\nclass Tool(BaseModel):\n    \"\"\"MCP tool definition.\"\"\"\n    model_config = ConfigDict(strict=True)\n    name: str = Field(description=\"The name of the tool\")\n    description: str = Field(description=\"The description of what the tool does\")\n    input_schema: dict[str, Any] = Field(description=\"The input schema for the tool\")\n    strict: bool = Field(default=True, description=\"Whether the tool response is strictly validated\")\n    function: Callable[..., Any] = Field(description=\"The tool function\", exclude=True)\nclass MCPServer:",
        "detail": "src.mbxai.mcp.server",
        "documentation": {}
    },
    {
        "label": "OpenRouterError",
        "kind": 6,
        "importPath": "src.mbxai.openrouter.client",
        "description": "src.mbxai.openrouter.client",
        "peekOfCode": "class OpenRouterError(Exception):\n    \"\"\"Base exception for OpenRouter client errors.\"\"\"\n    pass\nclass OpenRouterConnectionError(OpenRouterError):\n    \"\"\"Raised when there is a connection error.\"\"\"\n    pass\nclass OpenRouterAPIError(OpenRouterError):\n    \"\"\"Raised when the API returns an error.\"\"\"\n    pass\nclass OpenRouterClient:",
        "detail": "src.mbxai.openrouter.client",
        "documentation": {}
    },
    {
        "label": "OpenRouterConnectionError",
        "kind": 6,
        "importPath": "src.mbxai.openrouter.client",
        "description": "src.mbxai.openrouter.client",
        "peekOfCode": "class OpenRouterConnectionError(OpenRouterError):\n    \"\"\"Raised when there is a connection error.\"\"\"\n    pass\nclass OpenRouterAPIError(OpenRouterError):\n    \"\"\"Raised when the API returns an error.\"\"\"\n    pass\nclass OpenRouterClient:\n    \"\"\"Client for interacting with the OpenRouter API.\"\"\"\n    def __init__(\n        self,",
        "detail": "src.mbxai.openrouter.client",
        "documentation": {}
    },
    {
        "label": "OpenRouterAPIError",
        "kind": 6,
        "importPath": "src.mbxai.openrouter.client",
        "description": "src.mbxai.openrouter.client",
        "peekOfCode": "class OpenRouterAPIError(OpenRouterError):\n    \"\"\"Raised when the API returns an error.\"\"\"\n    pass\nclass OpenRouterClient:\n    \"\"\"Client for interacting with the OpenRouter API.\"\"\"\n    def __init__(\n        self,\n        token: str,\n        model: Union[str, OpenRouterModel] = OpenRouterModel.GPT4_TURBO,\n        base_url: Optional[str] = None,",
        "detail": "src.mbxai.openrouter.client",
        "documentation": {}
    },
    {
        "label": "OpenRouterClient",
        "kind": 6,
        "importPath": "src.mbxai.openrouter.client",
        "description": "src.mbxai.openrouter.client",
        "peekOfCode": "class OpenRouterClient:\n    \"\"\"Client for interacting with the OpenRouter API.\"\"\"\n    def __init__(\n        self,\n        token: str,\n        model: Union[str, OpenRouterModel] = OpenRouterModel.GPT4_TURBO,\n        base_url: Optional[str] = None,\n        default_headers: Optional[dict[str, str]] = None,\n    ) -> None:\n        \"\"\"Initialize the OpenRouter client.",
        "detail": "src.mbxai.openrouter.client",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.mbxai.openrouter.client",
        "description": "src.mbxai.openrouter.client",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass OpenRouterError(Exception):\n    \"\"\"Base exception for OpenRouter client errors.\"\"\"\n    pass\nclass OpenRouterConnectionError(OpenRouterError):\n    \"\"\"Raised when there is a connection error.\"\"\"\n    pass\nclass OpenRouterAPIError(OpenRouterError):\n    \"\"\"Raised when the API returns an error.\"\"\"\n    pass",
        "detail": "src.mbxai.openrouter.client",
        "documentation": {}
    },
    {
        "label": "OpenRouterConfig",
        "kind": 6,
        "importPath": "src.mbxai.openrouter.config",
        "description": "src.mbxai.openrouter.config",
        "peekOfCode": "class OpenRouterConfig(BaseModel):\n    \"\"\"Configuration for OpenRouter client.\"\"\"\n    token: str = Field(..., description=\"OpenRouter API token\")\n    model: Union[str, OpenRouterModel] = Field(\n        default=OpenRouterModel.GPT4_TURBO,\n        description=\"Model to use for completions\"\n    )\n    base_url: str = Field(\n        default=\"https://openrouter.ai/api/v1\",\n        description=\"Base URL for the OpenRouter API\"",
        "detail": "src.mbxai.openrouter.config",
        "documentation": {}
    },
    {
        "label": "OpenRouterModel",
        "kind": 6,
        "importPath": "src.mbxai.openrouter.models",
        "description": "src.mbxai.openrouter.models",
        "peekOfCode": "class OpenRouterModel(str, Enum):\n    \"\"\"Built-in OpenRouter models.\"\"\"\n    GPT4_TURBO = \"openai/gpt-4-turbo-preview\"\n    GPT4 = \"openai/gpt-4\"\n    GPT41 = \"openai/gpt-4.1\"\n    GPT35_TURBO = \"openai/gpt-3.5-turbo\"\n    CLAUDE_3_OPUS = \"anthropic/claude-3-opus\"\n    CLAUDE_3_SONNET = \"anthropic/claude-3-sonnet\"\n    CLAUDE_3_HAIKU = \"anthropic/claude-3-haiku\"\n    GEMINI_PRO = \"google/gemini-pro\"",
        "detail": "src.mbxai.openrouter.models",
        "documentation": {}
    },
    {
        "label": "OpenRouterModelRegistry",
        "kind": 6,
        "importPath": "src.mbxai.openrouter.models",
        "description": "src.mbxai.openrouter.models",
        "peekOfCode": "class OpenRouterModelRegistry:\n    \"\"\"Registry for OpenRouter models.\"\"\"\n    _custom_models: ClassVar[dict[str, str]] = {}\n    _initialized: ClassVar[bool] = False\n    @classmethod\n    def _initialize(cls) -> None:\n        \"\"\"Initialize the registry if not already initialized.\"\"\"\n        if not cls._initialized:\n            cls._custom_models = {}\n            cls._initialized = True",
        "detail": "src.mbxai.openrouter.models",
        "documentation": {}
    },
    {
        "label": "ToolClient",
        "kind": 6,
        "importPath": "src.mbxai.tools.client",
        "description": "src.mbxai.tools.client",
        "peekOfCode": "class ToolClient:\n    \"\"\"Client for handling tool calls with OpenRouter.\"\"\"\n    def __init__(self, openrouter_client: OpenRouterClient) -> None:\n        \"\"\"Initialize the ToolClient.\n        Args:\n            openrouter_client: The OpenRouter client to use\n        \"\"\"\n        self._client = openrouter_client\n        self._tools: dict[str, Tool] = {}\n    def register_tool(",
        "detail": "src.mbxai.tools.client",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "src.mbxai.tools.client",
        "description": "src.mbxai.tools.client",
        "peekOfCode": "logger = logging.getLogger(__name__)\nT = TypeVar(\"T\", bound=BaseModel)\nclass ToolClient:\n    \"\"\"Client for handling tool calls with OpenRouter.\"\"\"\n    def __init__(self, openrouter_client: OpenRouterClient) -> None:\n        \"\"\"Initialize the ToolClient.\n        Args:\n            openrouter_client: The OpenRouter client to use\n        \"\"\"\n        self._client = openrouter_client",
        "detail": "src.mbxai.tools.client",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "src.mbxai.tools.client",
        "description": "src.mbxai.tools.client",
        "peekOfCode": "T = TypeVar(\"T\", bound=BaseModel)\nclass ToolClient:\n    \"\"\"Client for handling tool calls with OpenRouter.\"\"\"\n    def __init__(self, openrouter_client: OpenRouterClient) -> None:\n        \"\"\"Initialize the ToolClient.\n        Args:\n            openrouter_client: The OpenRouter client to use\n        \"\"\"\n        self._client = openrouter_client\n        self._tools: dict[str, Tool] = {}",
        "detail": "src.mbxai.tools.client",
        "documentation": {}
    },
    {
        "label": "WeatherInfo",
        "kind": 6,
        "importPath": "src.mbxai.tools.example",
        "description": "src.mbxai.tools.example",
        "peekOfCode": "class WeatherInfo(BaseModel):\n    \"\"\"Weather information for a location.\"\"\"\n    location: str\n    temperature: float\n    conditions: str\n    humidity: float\n# Example tool function\ndef get_weather(location: str) -> str:\n    \"\"\"Get the current weather for a location.\n    Args:",
        "detail": "src.mbxai.tools.example",
        "documentation": {}
    },
    {
        "label": "get_weather",
        "kind": 2,
        "importPath": "src.mbxai.tools.example",
        "description": "src.mbxai.tools.example",
        "peekOfCode": "def get_weather(location: str) -> str:\n    \"\"\"Get the current weather for a location.\n    Args:\n        location: The location to get weather for\n    Returns:\n        A string describing the current weather\n    \"\"\"\n    # In a real implementation, this would call a weather API\n    return f\"The weather in {location} is sunny with a temperature of 25°C and 60% humidity.\"\ndef main() -> None:",
        "detail": "src.mbxai.tools.example",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "src.mbxai.tools.example",
        "description": "src.mbxai.tools.example",
        "peekOfCode": "def main() -> None:\n    # Initialize the OpenRouter client\n    client = OpenRouterClient(token=\"your-api-key\")\n    # Initialize the ToolClient\n    tool_client = ToolClient(client)\n    # Register the weather tool\n    tool_client.register_tool(\n        name=\"get_weather\",\n        description=\"Get the current weather for a location\",\n        function=get_weather,",
        "detail": "src.mbxai.tools.example",
        "documentation": {}
    },
    {
        "label": "ToolCall",
        "kind": 6,
        "importPath": "src.mbxai.tools.types",
        "description": "src.mbxai.tools.types",
        "peekOfCode": "class ToolCall(BaseModel):\n    \"\"\"A tool call from the model.\"\"\"\n    id: str\n    name: str\n    arguments: dict[str, Any]\nclass Tool(BaseModel):\n    \"\"\"A tool that can be used by the model.\"\"\"\n    name: str\n    description: str\n    function: Callable[..., Any]",
        "detail": "src.mbxai.tools.types",
        "documentation": {}
    },
    {
        "label": "Tool",
        "kind": 6,
        "importPath": "src.mbxai.tools.types",
        "description": "src.mbxai.tools.types",
        "peekOfCode": "class Tool(BaseModel):\n    \"\"\"A tool that can be used by the model.\"\"\"\n    name: str\n    description: str\n    function: Callable[..., Any]\n    schema: dict[str, Any]\n    def to_openai_function(self) -> dict[str, Any]:\n        \"\"\"Convert the tool to an OpenAI function definition.\"\"\"\n        return {\n            \"type\": \"function\",",
        "detail": "src.mbxai.tools.types",
        "documentation": {}
    },
    {
        "label": "hello_world",
        "kind": 2,
        "importPath": "src.mbxai.core",
        "description": "src.mbxai.core",
        "peekOfCode": "def hello_world() -> str:\n    \"\"\"\n    Returns a greeting message.\n    Returns:\n        str: A greeting message\n    \"\"\"\n    return \"Hello from MBX AI!\"",
        "detail": "src.mbxai.core",
        "documentation": {}
    },
    {
        "label": "test_hello_world",
        "kind": 2,
        "importPath": "tests.test_core",
        "description": "tests.test_core",
        "peekOfCode": "def test_hello_world():\n    \"\"\"Test the hello_world function.\"\"\"\n    assert hello_world() == \"Hello from MBX AI!\"",
        "detail": "tests.test_core",
        "documentation": {}
    },
    {
        "label": "TestInput",
        "kind": 6,
        "importPath": "tests.test_mcp",
        "description": "tests.test_mcp",
        "peekOfCode": "class TestInput(BaseModel):\n    \"\"\"Test input model.\"\"\"\n    text: str\nclass TestOutput(BaseModel):\n    \"\"\"Test output model.\"\"\"\n    result: str\n    count: int\n# Create a FastMCP instance for testing\nmcp = FastMCP(\"test-service\")\n# Create the test tool",
        "detail": "tests.test_mcp",
        "documentation": {}
    },
    {
        "label": "TestOutput",
        "kind": 6,
        "importPath": "tests.test_mcp",
        "description": "tests.test_mcp",
        "peekOfCode": "class TestOutput(BaseModel):\n    \"\"\"Test output model.\"\"\"\n    result: str\n    count: int\n# Create a FastMCP instance for testing\nmcp = FastMCP(\"test-service\")\n# Create the test tool\n@mcp.tool()\n@pytest.mark.skip(reason=\"This is a tool function, not a test\")\nasync def test_tool(argument: TestInput) -> TestOutput:",
        "detail": "tests.test_mcp",
        "documentation": {}
    },
    {
        "label": "openrouter_client",
        "kind": 2,
        "importPath": "tests.test_mcp",
        "description": "tests.test_mcp",
        "peekOfCode": "def openrouter_client():\n    \"\"\"Create a mock OpenRouter client.\"\"\"\n    return Mock(spec=OpenRouterClient)\n@pytest.fixture\ndef mcp_client(openrouter_client):\n    \"\"\"Create an MCP client with a mock OpenRouter client.\"\"\"\n    return MCPClient(openrouter_client)\n@pytest.fixture\ndef mcp_server():\n    \"\"\"Create an MCP server.\"\"\"",
        "detail": "tests.test_mcp",
        "documentation": {}
    },
    {
        "label": "mcp_client",
        "kind": 2,
        "importPath": "tests.test_mcp",
        "description": "tests.test_mcp",
        "peekOfCode": "def mcp_client(openrouter_client):\n    \"\"\"Create an MCP client with a mock OpenRouter client.\"\"\"\n    return MCPClient(openrouter_client)\n@pytest.fixture\ndef mcp_server():\n    \"\"\"Create an MCP server.\"\"\"\n    server = MCPServer(\"test-service\")\n    server.app.dependency_overrides = {}  # Clear any overrides\n    return server\n@pytest.fixture",
        "detail": "tests.test_mcp",
        "documentation": {}
    },
    {
        "label": "mcp_server",
        "kind": 2,
        "importPath": "tests.test_mcp",
        "description": "tests.test_mcp",
        "peekOfCode": "def mcp_server():\n    \"\"\"Create an MCP server.\"\"\"\n    server = MCPServer(\"test-service\")\n    server.app.dependency_overrides = {}  # Clear any overrides\n    return server\n@pytest.fixture\ndef test_client(mcp_server):\n    \"\"\"Create a test client for the FastAPI app.\"\"\"\n    return TestClient(mcp_server.app)\n@pytest.mark.asyncio",
        "detail": "tests.test_mcp",
        "documentation": {}
    },
    {
        "label": "test_client",
        "kind": 2,
        "importPath": "tests.test_mcp",
        "description": "tests.test_mcp",
        "peekOfCode": "def test_client(mcp_server):\n    \"\"\"Create a test client for the FastAPI app.\"\"\"\n    return TestClient(mcp_server.app)\n@pytest.mark.asyncio\nasync def test_register_mcp_server(mcp_client):\n    \"\"\"Test registering an MCP server.\"\"\"\n    # Mock the HTTP client\n    mock_response = Mock()\n    mock_response.json.return_value = [\n        {",
        "detail": "tests.test_mcp",
        "documentation": {}
    },
    {
        "label": "mcp",
        "kind": 5,
        "importPath": "tests.test_mcp",
        "description": "tests.test_mcp",
        "peekOfCode": "mcp = FastMCP(\"test-service\")\n# Create the test tool\n@mcp.tool()\n@pytest.mark.skip(reason=\"This is a tool function, not a test\")\nasync def test_tool(argument: TestInput) -> TestOutput:\n    \"\"\"A test tool that returns a simple response.\"\"\"\n    return TestOutput(\n        result=f\"Processed: {argument.text}\",\n        count=len(argument.text)\n    )",
        "detail": "tests.test_mcp",
        "documentation": {}
    },
    {
        "label": "Step",
        "kind": 6,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "class Step(BaseModel):\n    \"\"\"A step in a coding task.\"\"\"\n    file_path: str\n    repo_name: str\n    type: str\n    diff: str\n    description: str\n    commit_message: str\nclass CodingOutput(BaseModel):\n    \"\"\"Structured output for coding tasks.\"\"\"",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "CodingOutput",
        "kind": 6,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "class CodingOutput(BaseModel):\n    \"\"\"Structured output for coding tasks.\"\"\"\n    steps: list[Step]\nclass SimpleOutput(BaseModel):\n    \"\"\"Simple structured output for testing.\"\"\"\n    message: str\n    count: int\n@pytest.fixture\ndef client():\n    \"\"\"Create a test client with API key from environment.\"\"\"",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "SimpleOutput",
        "kind": 6,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "class SimpleOutput(BaseModel):\n    \"\"\"Simple structured output for testing.\"\"\"\n    message: str\n    count: int\n@pytest.fixture\ndef client():\n    \"\"\"Create a test client with API key from environment.\"\"\"\n    if not API_KEY or API_KEY == \"test-token\":\n        pytest.skip(\"OPENROUTER_API_KEY not set in environment\")\n    return OpenRouterClient(token=API_KEY)",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "client",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def client():\n    \"\"\"Create a test client with API key from environment.\"\"\"\n    if not API_KEY or API_KEY == \"test-token\":\n        pytest.skip(\"OPENROUTER_API_KEY not set in environment\")\n    return OpenRouterClient(token=API_KEY)\ndef test_openrouter_config_default_url():\n    \"\"\"Test that OpenRouterConfig accepts default URL.\"\"\"\n    config = OpenRouterConfig(token=API_KEY)\n    assert str(config.base_url) == \"https://openrouter.ai/api/v1\"\ndef test_openrouter_config_custom_url():",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_config_default_url",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_config_default_url():\n    \"\"\"Test that OpenRouterConfig accepts default URL.\"\"\"\n    config = OpenRouterConfig(token=API_KEY)\n    assert str(config.base_url) == \"https://openrouter.ai/api/v1\"\ndef test_openrouter_config_custom_url():\n    \"\"\"Test that OpenRouterConfig accepts custom URL.\"\"\"\n    config = OpenRouterConfig(\n        token=API_KEY,\n        base_url=\"https://custom.api.example.com\",\n    )",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_config_custom_url",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_config_custom_url():\n    \"\"\"Test that OpenRouterConfig accepts custom URL.\"\"\"\n    config = OpenRouterConfig(\n        token=API_KEY,\n        base_url=\"https://custom.api.example.com\",\n    )\n    assert str(config.base_url) == \"https://custom.api.example.com/\"\ndef test_openrouter_config_invalid_token():\n    \"\"\"Test that OpenRouterConfig validates token format.\"\"\"\n    with pytest.raises(ValueError, match=\"Token cannot be empty\"):",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_config_invalid_token",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_config_invalid_token():\n    \"\"\"Test that OpenRouterConfig validates token format.\"\"\"\n    with pytest.raises(ValueError, match=\"Token cannot be empty\"):\n        OpenRouterConfig(token=\"   \")  # Empty or whitespace-only token\ndef test_openrouter_config_default_model():\n    \"\"\"Test that OpenRouterConfig uses GPT-4 Turbo as default model.\"\"\"\n    config = OpenRouterConfig(token=API_KEY)\n    assert config.model == OpenRouterModel.GPT4_TURBO\n    assert config.model.value == \"openai/gpt-4-turbo-preview\"\ndef test_openrouter_config_custom_model():",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_config_default_model",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_config_default_model():\n    \"\"\"Test that OpenRouterConfig uses GPT-4 Turbo as default model.\"\"\"\n    config = OpenRouterConfig(token=API_KEY)\n    assert config.model == OpenRouterModel.GPT4_TURBO\n    assert config.model.value == \"openai/gpt-4-turbo-preview\"\ndef test_openrouter_config_custom_model():\n    \"\"\"Test that OpenRouterConfig accepts custom model.\"\"\"\n    config = OpenRouterConfig(\n        token=API_KEY,\n        model=OpenRouterModel.CLAUDE_3_OPUS,",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_config_custom_model",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_config_custom_model():\n    \"\"\"Test that OpenRouterConfig accepts custom model.\"\"\"\n    config = OpenRouterConfig(\n        token=API_KEY,\n        model=OpenRouterModel.CLAUDE_3_OPUS,\n    )\n    assert str(config.model) == OpenRouterModel.CLAUDE_3_OPUS.value\ndef test_openrouter_client_initialization():\n    \"\"\"Test OpenRouterClient initialization.\"\"\"\n    client = OpenRouterClient(token=API_KEY)",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_client_initialization",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_client_initialization():\n    \"\"\"Test OpenRouterClient initialization.\"\"\"\n    client = OpenRouterClient(token=API_KEY)\n    assert isinstance(client.config, OpenRouterConfig)\n    assert client.config.token == API_KEY\n    assert str(client.config.base_url) == \"https://openrouter.ai/api/v1/\"\n    assert client.config.model == OpenRouterModel.GPT4_TURBO\ndef test_openrouter_client_custom_url():\n    \"\"\"Test OpenRouterClient with custom URL.\"\"\"\n    client = OpenRouterClient(",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_client_custom_url",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_client_custom_url():\n    \"\"\"Test OpenRouterClient with custom URL.\"\"\"\n    client = OpenRouterClient(\n        token=API_KEY,\n        base_url=\"https://custom.api.example.com\",\n    )\n    assert str(client.config.base_url) == \"https://custom.api.example.com/\"\ndef test_openrouter_client_custom_model():\n    \"\"\"Test OpenRouterClient with custom model.\"\"\"\n    client = OpenRouterClient(",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_client_custom_model",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_client_custom_model():\n    \"\"\"Test OpenRouterClient with custom model.\"\"\"\n    client = OpenRouterClient(\n        token=API_KEY,\n        model=OpenRouterModel.CLAUDE_3_OPUS,\n    )\n    assert client.config.model == OpenRouterModel.CLAUDE_3_OPUS\ndef test_openrouter_client_custom_model_and_url():\n    \"\"\"Test OpenRouterClient with custom model and URL.\"\"\"\n    client = OpenRouterClient(",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_client_custom_model_and_url",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_client_custom_model_and_url():\n    \"\"\"Test OpenRouterClient with custom model and URL.\"\"\"\n    client = OpenRouterClient(\n        token=API_KEY,\n        model=OpenRouterModel.GEMINI_PRO,\n        base_url=\"https://custom.api.example.com\",\n    )\n    assert client.config.model == OpenRouterModel.GEMINI_PRO\n    assert str(client.config.base_url) == \"https://custom.api.example.com/\"\ndef test_openrouter_client_set_model():",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_openrouter_client_set_model",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_openrouter_client_set_model():\n    \"\"\"Test setting a new model after client initialization.\"\"\"\n    client = OpenRouterClient(token=API_KEY)\n    assert client.config.model == OpenRouterModel.GPT4_TURBO\n    client.set_model(OpenRouterModel.CLAUDE_3_OPUS)\n    assert client.config.model == OpenRouterModel.CLAUDE_3_OPUS\n    client.set_model(OpenRouterModel.GEMINI_PRO)\n    assert client.config.model == OpenRouterModel.GEMINI_PRO\ndef test_register_custom_model():\n    \"\"\"Test registering a custom model.\"\"\"",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_register_custom_model",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_register_custom_model():\n    \"\"\"Test registering a custom model.\"\"\"\n    # Register a new model\n    OpenRouterClient.register_model(\"CUSTOM_MODEL\", \"custom/model-1\")\n    # Verify the model is in the list\n    models = OpenRouterClient.list_models()\n    assert \"CUSTOM_MODEL\" in models\n    assert models[\"CUSTOM_MODEL\"] == \"custom/model-1\"\ndef test_register_duplicate_model():\n    \"\"\"Test that registering a duplicate model raises an error.\"\"\"",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_register_duplicate_model",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_register_duplicate_model():\n    \"\"\"Test that registering a duplicate model raises an error.\"\"\"\n    # Register a model\n    OpenRouterClient.register_model(\"DUPLICATE_MODEL\", \"custom/model-2\")\n    # Try to register it again\n    with pytest.raises(ValueError, match=\"Model DUPLICATE_MODEL is already registered\"):\n        OpenRouterClient.register_model(\"DUPLICATE_MODEL\", \"custom/model-3\")\ndef test_list_models_includes_builtin_and_custom():\n    \"\"\"Test that list_models includes both built-in and custom models.\"\"\"\n    # Register a custom model",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_list_models_includes_builtin_and_custom",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_list_models_includes_builtin_and_custom():\n    \"\"\"Test that list_models includes both built-in and custom models.\"\"\"\n    # Register a custom model\n    OpenRouterClient.register_model(\"TEST_MODEL\", \"test/model-1\")\n    # Get all models\n    models = OpenRouterClient.list_models()\n    # Check that both built-in and custom models are present\n    assert \"GPT4_TURBO\" in models  # Built-in\n    assert \"TEST_MODEL\" in models  # Custom\n    assert models[\"GPT4_TURBO\"] == \"openai/gpt-4-turbo-preview\"",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_chat_completion",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_chat_completion():\n    \"\"\"Test chat completion functionality.\"\"\"\n    client = OpenRouterClient(token=API_KEY)\n    messages = [\n        {\"role\": \"user\", \"content\": \"Hello, how are you?\"}\n    ]\n    response = client.chat_completion(messages)\n    assert response is not None\n    assert hasattr(response, \"choices\")\n    assert len(response.choices) > 0",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_streaming_chat_completion",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_streaming_chat_completion():\n    \"\"\"Test streaming chat completion functionality.\"\"\"\n    client = OpenRouterClient(token=API_KEY)\n    messages = [\n        {\"role\": \"user\", \"content\": \"Hello, how are you?\"}\n    ]\n    response = client.chat_completion(messages, stream=True)\n    assert response is not None\n    assert hasattr(response, \"__iter__\")  # Should be an iterator\n    chunks = list(response)  # Collect all chunks",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_custom_model_chat_completion",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_custom_model_chat_completion():\n    \"\"\"Test chat completion with a custom model.\"\"\"\n    # Register a custom model with a valid provider/model format\n    model_name = \"TEST_MODEL_\" + str(hash(\"test\"))  # Generate unique name\n    OpenRouterClient.register_model(model_name, \"openai/gpt-3.5-turbo\")\n    client = OpenRouterClient(token=API_KEY, model=model_name)\n    messages = [\n        {\"role\": \"user\", \"content\": \"Hello, how are you?\"}\n    ]\n    response = client.chat_completion(messages)",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_custom_default_headers",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_custom_default_headers():\n    \"\"\"Test custom default headers.\"\"\"\n    custom_headers = {\n        \"HTTP-Referer\": \"https://custom.example.com\",\n        \"X-Title\": \"Custom App\",\n        \"X-Custom\": \"test-value\"\n    }\n    client = OpenRouterClient(\n        token=API_KEY,\n        default_headers=custom_headers",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_chat_completion_parse_simple",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_chat_completion_parse_simple(client):\n    \"\"\"Test chat completion with simple structured output.\"\"\"\n    messages = [\n        {\n            \"content\": \"You are a helpful assistant.\",\n            \"role\": \"system\",\n        },\n        {\n            \"content\": \"Return a simple message with count 42.\",\n            \"role\": \"user\",",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_chat_completion_parse_coding",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_chat_completion_parse_coding(client):\n    \"\"\"Test chat completion with coding task structured output.\"\"\"\n    messages = [\n        {\n            \"content\": \"You are an exceptional principal engineer that is amazing at finding and fixing issues in codebases.\",\n            \"role\": \"system\",\n        },\n        {\n            \"content\": \"We need to enhance error handling in the `from_str` method.\",\n            \"role\": \"assistant\",",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_chat_completion_parse_with_tool_calls",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_chat_completion_parse_with_tool_calls(client):\n    \"\"\"Test chat completion with structured output and tool calls.\"\"\"\n    messages = [\n        {\n            \"content\": \"You are an exceptional principal engineer that is amazing at finding and fixing issues in codebases.\",\n            \"role\": \"system\",\n        },\n        {\n            \"content\": None,  # Important: content must be None for tool calls\n            \"role\": \"assistant\",",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_chat_completion_parse_invalid_model",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_chat_completion_parse_invalid_model(client):\n    \"\"\"Test chat completion with invalid response format.\"\"\"\n    messages = [\n        {\"role\": \"user\", \"content\": \"Hello\"}\n    ]\n    with pytest.raises(ValueError):\n        client.chat_completion_parse(\n            messages=messages,\n            response_format=str,  # Invalid response format\n        )",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_chat_completion_parse_streaming",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_chat_completion_parse_streaming(client):\n    \"\"\"Test streaming chat completion with structured output.\"\"\"\n    messages = [\n        {\"role\": \"user\", \"content\": \"Count to 3.\"}\n    ]\n    response = client.chat_completion_parse(\n        messages=messages,\n        response_format=SimpleOutput,\n        stream=True,\n    )",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_chat_completion_parse_with_custom_model",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_chat_completion_parse_with_custom_model(client):\n    \"\"\"Test chat completion with a custom model.\"\"\"\n    messages = [\n        {\n            \"role\": \"system\",\n            \"content\": \"\"\"You are a helpful assistant that responds in valid JSON format.\n            When asked to respond, provide a JSON object with two fields:\n            - message: a string containing your response\n            - count: an integer representing the number of words in your message\"\"\"\n        },",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_embeddings",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_embeddings():\n    \"\"\"Test embeddings functionality.\"\"\"\n    client = OpenRouterClient(token=API_KEY)\n    text = \"This is a test sentence.\"\n    response = client.embeddings(text)\n    assert response is not None\n    assert hasattr(response, \"data\")\n    assert len(response.data) > 0\n    assert hasattr(response.data[0], \"embedding\")\n    assert len(response.data[0].embedding) > 0",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "test_embeddings_parse",
        "kind": 2,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "def test_embeddings_parse():\n    \"\"\"Test embeddings with parse functionality.\"\"\"\n    client = OpenRouterClient(token=API_KEY)\n    text = \"This is a test sentence.\"\n    # Test with parse=True (default)\n    parsed_response = client.embeddings(text, parse=True)\n    assert parsed_response is not None\n    assert isinstance(parsed_response, list)\n    assert len(parsed_response) > 0\n    assert isinstance(parsed_response[0], list)",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "API_KEY",
        "kind": 5,
        "importPath": "tests.test_openrouter",
        "description": "tests.test_openrouter",
        "peekOfCode": "API_KEY = os.getenv(\"OPENROUTER_API_KEY\", \"test-token\")\n# Test models\nclass Step(BaseModel):\n    \"\"\"A step in a coding task.\"\"\"\n    file_path: str\n    repo_name: str\n    type: str\n    diff: str\n    description: str\n    commit_message: str",
        "detail": "tests.test_openrouter",
        "documentation": {}
    },
    {
        "label": "TestOutput",
        "kind": 6,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "class TestOutput(BaseModel):\n    \"\"\"Test output model.\"\"\"\n    message: str\n    count: int\ndef test_tool_registration():\n    \"\"\"Test tool registration.\"\"\"\n    # Setup\n    openrouter_client = Mock(spec=OpenRouterClient)\n    tool_client = ToolClient(openrouter_client)\n    # Define a test tool",
        "detail": "tests.test_tools",
        "documentation": {}
    },
    {
        "label": "test_tool_registration",
        "kind": 2,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "def test_tool_registration():\n    \"\"\"Test tool registration.\"\"\"\n    # Setup\n    openrouter_client = Mock(spec=OpenRouterClient)\n    tool_client = ToolClient(openrouter_client)\n    # Define a test tool\n    def test_function(arg1: str) -> str:\n        return f\"Test: {arg1}\"\n    # Register the tool\n    tool_client.register_tool(",
        "detail": "tests.test_tools",
        "documentation": {}
    },
    {
        "label": "test_tool_to_openai_function",
        "kind": 2,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "def test_tool_to_openai_function():\n    \"\"\"Test converting a tool to OpenAI function format.\"\"\"\n    # Create a test tool\n    def test_function(arg1: str) -> str:\n        return f\"Test: {arg1}\"\n    tool = Tool(\n        name=\"test_tool\",\n        description=\"A test tool\",\n        function=test_function,\n        schema={",
        "detail": "tests.test_tools",
        "documentation": {}
    },
    {
        "label": "test_chat_without_tools",
        "kind": 2,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "def test_chat_without_tools():\n    \"\"\"Test chat without any tools.\"\"\"\n    # Setup\n    openrouter_client = Mock(spec=OpenRouterClient)\n    tool_client = ToolClient(openrouter_client)\n    # Mock response\n    mock_response = Mock()\n    mock_response.choices = [Mock()]\n    mock_response.choices[0].message = Mock()\n    mock_response.choices[0].message.content = \"Hello!\"",
        "detail": "tests.test_tools",
        "documentation": {}
    },
    {
        "label": "test_chat_with_tools",
        "kind": 2,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "def test_chat_with_tools():\n    \"\"\"Test chat with tool calls.\"\"\"\n    # Setup\n    openrouter_client = Mock(spec=OpenRouterClient)\n    tool_client = ToolClient(openrouter_client)\n    # Register a test tool\n    def test_function(arg1: str) -> str:\n        return f\"Result: {arg1}\"\n    tool_client.register_tool(\n        name=\"test_tool\",",
        "detail": "tests.test_tools",
        "documentation": {}
    },
    {
        "label": "test_parse_without_tools",
        "kind": 2,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "def test_parse_without_tools():\n    \"\"\"Test parse without any tools.\"\"\"\n    # Setup\n    openrouter_client = Mock(spec=OpenRouterClient)\n    tool_client = ToolClient(openrouter_client)\n    # Mock response\n    mock_response = Mock()\n    mock_response.choices = [Mock()]\n    mock_response.choices[0].message = Mock()\n    mock_response.choices[0].message.content = '{\"message\": \"Hello\", \"count\": 42}'",
        "detail": "tests.test_tools",
        "documentation": {}
    },
    {
        "label": "test_parse_with_tools",
        "kind": 2,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "def test_parse_with_tools():\n    \"\"\"Test parse with tool calls.\"\"\"\n    # Setup\n    openrouter_client = Mock(spec=OpenRouterClient)\n    tool_client = ToolClient(openrouter_client)\n    # Register a test tool\n    def test_function(arg1: str) -> str:\n        return f\"Result: {arg1}\"\n    tool_client.register_tool(\n        name=\"test_tool\",",
        "detail": "tests.test_tools",
        "documentation": {}
    },
    {
        "label": "test_streaming_chat",
        "kind": 2,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "def test_streaming_chat():\n    \"\"\"Test streaming chat.\"\"\"\n    # Setup\n    openrouter_client = Mock(spec=OpenRouterClient)\n    tool_client = ToolClient(openrouter_client)\n    # Mock response\n    mock_response = Mock()\n    mock_response.choices = [Mock()]\n    mock_response.choices[0].delta = Mock()\n    mock_response.choices[0].delta.content = \"Hello\"",
        "detail": "tests.test_tools",
        "documentation": {}
    },
    {
        "label": "test_streaming_parse",
        "kind": 2,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "def test_streaming_parse():\n    \"\"\"Test streaming parse.\"\"\"\n    # Setup\n    openrouter_client = Mock(spec=OpenRouterClient)\n    tool_client = ToolClient(openrouter_client)\n    # Mock response\n    mock_response = Mock()\n    mock_response.choices = [Mock()]\n    mock_response.choices[0].delta = Mock()\n    mock_response.choices[0].delta.content = '{\"message\": \"Hello\", \"count\": 42}'",
        "detail": "tests.test_tools",
        "documentation": {}
    },
    {
        "label": "test_unknown_tool",
        "kind": 2,
        "importPath": "tests.test_tools",
        "description": "tests.test_tools",
        "peekOfCode": "def test_unknown_tool():\n    \"\"\"Test handling of unknown tool calls.\"\"\"\n    # Setup\n    openrouter_client = Mock(spec=OpenRouterClient)\n    tool_client = ToolClient(openrouter_client)\n    # Mock response with unknown tool\n    mock_tool_call = Mock()\n    mock_tool_call.function = Mock()\n    mock_tool_call.function.name = \"unknown_tool\"\n    mock_tool_call.function.arguments = {\"arg1\": \"test\"}",
        "detail": "tests.test_tools",
        "documentation": {}
    }
]