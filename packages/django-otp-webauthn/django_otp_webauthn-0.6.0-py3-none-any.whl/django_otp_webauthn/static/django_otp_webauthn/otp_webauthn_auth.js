(()=>{"use strict";var b;(function(e){e.UNKNOWN_ERROR="unknown-error",e.STATE_ERROR="state-error",e.SECURITY_ERROR="security-error",e.GET_OPTIONS_FAILED="get-options-failed",e.ABORTED="aborted",e.NOT_ALLOWED_OR_ABORTED="not-allowed-or-aborted",e.SERVER_ERROR="server-error",e.SUCCESS="success",e.BUSY="busy"})(b||(b={}));async function L(){let e=null;const t=document.getElementById("otp_webauthn_config");if(t)return e=JSON.parse(t.innerText),Object.freeze(e);throw new Error("otp_webauthn_config element not found")}function N(e){const n=document.querySelector("input[name='next']")?.value||new URLSearchParams(window.location.search).get("next");if(n){const s=new URL(e,window.location.origin);return s.searchParams.set("next",n),s.toString()}return e}function I(){return V.stubThis(globalThis?.PublicKeyCredential!==void 0&&typeof globalThis.PublicKeyCredential=="function")}const V={stubThis:e=>e};class _ extends Error{constructor({message:t,code:n,cause:s,name:l}){super(t,{cause:s}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=l??s.name,this.code=n}}function M({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new WebAuthnError({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(n.authenticatorSelection?.requireResidentKey===!0)return new WebAuthnError({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(t.mediation==="conditional"&&n.authenticatorSelection?.userVerification==="required")return new WebAuthnError({message:"User verification was required during automatic registration but it could not be performed",code:"ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",cause:e});if(n.authenticatorSelection?.userVerification==="required")return new WebAuthnError({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new WebAuthnError({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new WebAuthnError({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return n.pubKeyCredParams.filter(l=>l.type==="public-key").length===0?new WebAuthnError({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new WebAuthnError({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const s=globalThis.location.hostname;if(isValidDomain(s)){if(n.rp.id!==s)return new WebAuthnError({message:`The RP ID "${n.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new WebAuthnError({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new WebAuthnError({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new WebAuthnError({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class B{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const k=new B;async function J(e){!e.optionsJSON&&e.challenge&&(console.warn("startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useAutoRegister:n=!1}=e;if(!browserSupportsWebAuthn())throw new Error("WebAuthn is not supported in this browser");const s={...t,challenge:base64URLStringToBuffer(t.challenge),user:{...t.user,id:base64URLStringToBuffer(t.user.id)},excludeCredentials:t.excludeCredentials?.map(toPublicKeyCredentialDescriptor)},l={};n&&(l.mediation="conditional"),l.publicKey=s,l.signal=WebAuthnAbortService.createNewAbortSignal();let f;try{f=await navigator.credentials.create(l)}catch(r){throw identifyRegistrationError({error:r,options:l})}if(!f)throw new Error("Registration was not completed");const{id:h,rawId:u,response:i,type:S}=f;let E;typeof i.getTransports=="function"&&(E=i.getTransports());let c;if(typeof i.getPublicKeyAlgorithm=="function")try{c=i.getPublicKeyAlgorithm()}catch(r){v("getPublicKeyAlgorithm()",r)}let g;if(typeof i.getPublicKey=="function")try{const r=i.getPublicKey();r!==null&&(g=bufferToBase64URLString(r))}catch(r){v("getPublicKey()",r)}let w;if(typeof i.getAuthenticatorData=="function")try{w=bufferToBase64URLString(i.getAuthenticatorData())}catch(r){v("getAuthenticatorData()",r)}return{id:h,rawId:bufferToBase64URLString(u),response:{attestationObject:bufferToBase64URLString(i.attestationObject),clientDataJSON:bufferToBase64URLString(i.clientDataJSON),transports:E,publicKeyAlgorithm:c,publicKey:g,authenticatorData:w},type:S,clientExtensionResults:f.getClientExtensionResults(),authenticatorAttachment:toAuthenticatorAttachment(f.authenticatorAttachment)}}function v(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function T(e){const t=new Uint8Array(e);let n="";for(const l of t)n+=String.fromCharCode(l);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function P(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,s=t.padEnd(t.length+n,"="),l=atob(s),f=new ArrayBuffer(l.length),h=new Uint8Array(f);for(let u=0;u<l.length;u++)h[u]=l.charCodeAt(u);return f}function D(){if(!I())return C.stubThis(new Promise(t=>t(!1)));const e=globalThis.PublicKeyCredential;return e?.isConditionalMediationAvailable===void 0?C.stubThis(new Promise(t=>t(!1))):C.stubThis(e.isConditionalMediationAvailable())}const C={stubThis:e=>e};function K(e){const{id:t}=e;return{...e,id:P(t),transports:e.transports}}function x(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}function W({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new _({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new _({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const s=globalThis.location.hostname;if(x(s)){if(n.rpId!==s)return new _({message:`The RP ID "${n.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new _({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new _({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}const F=["cross-platform","platform"];function q(e){if(e&&!(F.indexOf(e)<0))return e}async function U(e){!e.optionsJSON&&e.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),e={optionsJSON:e});const{optionsJSON:t,useBrowserAutofill:n=!1,verifyBrowserAutofillInput:s=!0}=e;if(!I())throw new Error("WebAuthn is not supported in this browser");let l;t.allowCredentials?.length!==0&&(l=t.allowCredentials?.map(K));const f={...t,challenge:P(t.challenge),allowCredentials:l},h={};if(n){if(!await D())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&s)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');h.mediation="conditional",f.allowCredentials=[]}h.publicKey=f,h.signal=k.createNewAbortSignal();let u;try{u=await navigator.credentials.get(h)}catch(w){throw W({error:w,options:h})}if(!u)throw new Error("Authentication was not completed");const{id:i,rawId:S,response:E,type:c}=u;let g;return E.userHandle&&(g=T(E.userHandle)),{id:i,rawId:T(S),response:{authenticatorData:T(E.authenticatorData),clientDataJSON:T(E.clientDataJSON),signature:T(E.signature),userHandle:g},type:c,clientExtensionResults:u.getClientExtensionResults(),authenticatorAttachment:q(u.authenticatorAttachment)}}function j(){return browserSupportsWebAuthn()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}(async function(){const e="passkey-verification-button",t="passkey-verification-status-message",n="visible",s="passkey-verification-placeholder",l="passkey-verification-unavailable-template",f="passkey-verification-available-template",h="otp_webauthn.verification_start",u="otp_webauthn.verification_complete",i="otp_webauthn.verification_failed";async function S(r){if(!r.autocompleteLoginFieldSelector)return;const o=document.querySelector(r.autocompleteLoginFieldSelector);if(!o){console.error(`Could not find login field with selector ${r.autocompleteLoginFieldSelector}. WebAuthn autofill cannot continue.`);return}const a=o.getAttribute("autocomplete")||"";o.setAttribute("autocomplete",a+" webauthn"),o.dispatchEvent(new CustomEvent(h,{detail:{fromAutofill:!0},bubbles:!0}));const y=await fetch(r.beginAuthenticationUrl,{method:"POST",credentials:"same-origin",headers:{"X-CSRFToken":r.csrfToken,Accept:"application/json"}});if(!y.ok){console.error("Unable to fetch options from server. Will not attempt autofill."),o.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,response:y},bubbles:!0}));return}let A;try{A=await U({optionsJSON:await y.json(),useBrowserAutofill:!0})}catch(p){console.error("Got error during the webauthn credential autofill call",p),o.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,error:p},bubbles:!0}));return}const O=N(r.completeAuthenticationUrl),R=await fetch(O,{method:"POST",headers:{"Content-Type":"application/json","X-CSRFToken":r.csrfToken},credentials:"same-origin",body:JSON.stringify(A)});if(!R.headers.get("content-type")?.includes("application/json")){o.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,response:R},bubbles:!0})),alert(gettext("Verification failed. A server error occurred."));return}const d=await R.json();if(!R.ok&&"detail"in d){o.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,response:R},bubbles:!0})),alert(d.detail);return}if(d&&d.id)o.dispatchEvent(new CustomEvent(u,{detail:{fromAutofill:!0,response:R},bubbles:!0})),d.redirect_url&&(window.location.href=d.redirect_url);else{o.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!0,response:R},bubbles:!0}));const p=d.error||gettext("An error occurred during verification.");alert(p)}}async function E(r){const o=document.getElementById(e);if(!o)return;const a=o.textContent||gettext("Verify with Passkey");o.addEventListener("click",async y=>{o.dispatchEvent(new CustomEvent(h,{detail:{fromAutofill:!1},bubbles:!0})),await c({buttonDisabled:!0,statusEnum:b.BUSY,buttonLabel:gettext("Verifying...")});const A=await fetch(r.beginAuthenticationUrl,{method:"POST",credentials:"same-origin",headers:{"X-CSRFToken":r.csrfToken,Accept:"application/json"}});if(!A.ok){await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.GET_OPTIONS_FAILED,status:gettext("Verification failed. Could not retrieve parameters from the server.")}),o.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!1,response:A},bubbles:!0}));return}let O;try{O=await U({optionsJSON:await A.json(),useBrowserAutofill:!1})}catch(m){if(m instanceof Error||m instanceof _){switch(console.error(m),m.name){case"AbortError":await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.ABORTED,status:gettext("Verification aborted.")});break;case"NotAllowedError":await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.NOT_ALLOWED_OR_ABORTED,status:gettext("Verification canceled or not allowed.")});break;default:throw await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.UNKNOWN_ERROR,status:gettext("Verification failed. An unknown error occurred.")}),m}o.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!1,error:m},bubbles:!0}));return}}await c({buttonDisabled:!0,statusEnum:b.BUSY,buttonLabel:gettext("Finishing verification...")});const R=N(r.completeAuthenticationUrl),d=await fetch(R,{method:"POST",headers:{"Content-Type":"application/json","X-CSRFToken":r.csrfToken},credentials:"same-origin",body:JSON.stringify(O)});if(!d.headers.get("content-type")?.includes("application/json")){await c({buttonDisabled:!1,buttonLabel:a,requestFocus:!0,statusEnum:b.SERVER_ERROR,status:gettext("Verification failed. An unknown server error occurred.")}),o.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!1,response:d},bubbles:!0}));return}const p=await d.json();if(!d.ok){const m=p.detail||gettext("Verification failed. An unknown error occurred.");await c({buttonDisabled:!1,buttonLabel:a,statusEnum:b.SERVER_ERROR,requestFocus:!0,status:m}),o.dispatchEvent(new CustomEvent(i,{detail:{fromAutofill:!1,response:d},bubbles:!0}));return}if(p&&p.id)await c({buttonDisabled:!1,buttonLabel:a,statusEnum:b.SUCCESS,status:gettext("Verification successful!")}),o.dispatchEvent(new CustomEvent(u,{detail:{fromAutofill:!1,response:d,id:p.id},bubbles:!0})),p.redirect_url&&(window.location.href=p.redirect_url);else{const m=p.error||gettext("An error occurred during verification.");await c({buttonDisabled:!1,buttonLabel:a,statusEnum:b.SERVER_ERROR,requestFocus:!0,status:m})}})}async function c(r){const o=document.getElementById(e);if(!o)return;const a=document.getElementById(t);o.disabled=r.buttonDisabled,o.textContent=r.buttonLabel,r.statusEnum?a.setAttribute("data-status-enum",r.statusEnum):a.removeAttribute("data-status-enum"),a&&(r.status?(o.setAttribute("aria-describedby",t),a.classList.add(n),a.textContent=r.status,a.setAttribute("aria-live","assertive"),r.requestFocus&&o.focus()):(o.removeAttribute("aria-describedby"),a.removeAttribute("aria-live"),a.classList.remove(n)))}async function g(r){const o=document.getElementById(s),a=document.getElementById(f),y=document.getElementById(l);if(!o)throw new Error("Placeholder element not found");if(!a)throw new Error("Available template not found");if(r){const A=a.content.cloneNode(!0);o.replaceWith(A)}else if(y){const A=y.content.cloneNode(!0);o.replaceWith(A)}else o.remove()}const w=await L();w.autocompleteLoginFieldSelector&&await D()&&S(w),I()?(await g(!0),E(w)):await g(!1)})()})();

//# sourceMappingURL=otp_webauthn_auth.js.map