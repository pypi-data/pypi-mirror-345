#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Dump and load formatted data generated by CRYSTALpytools itself.
"""
import os.path
from warnings import warn

import numpy as np
from yaml import dump, add_representer, safe_load
from pandas import DataFrame, set_option

# Pandas display width
set_option('display.max_columns', None)  # Show all columns
set_option('display.max_colwidth', None)  # No truncation in cells


# Data format for YAML files
def _inp_rep(dumper, value):
    return dumper.represent_scalar('tag:yaml.org,2002:float', '{0:.4f}'.format(value))
def _fit_rep(dumper, value):
    return dumper.represent_scalar('tag:yaml.org,2002:float', '{0:.12f}'.format(value))
def _out_rep(dumper, value):
    return dumper.represent_scalar('tag:yaml.org,2002:float', '{0:.10f}'.format(value))


# Thermodynamics, HA
class ThermoHA():
    """Harmonic lattice dynamics I/O."""
    @classmethod
    def write(cls, ha):
        """
        Write harmonic phonon information.

        Args:
            ha (Harmonic): Harmonic object.
        """
        if os.path.isfile(ha.filename):
            warn("The existing HA file will be overwritten.", stacklevel=2)

        file = open(ha.filename, 'w')
        file.write("# Units\n\n")
        unit = {'unit' : {'temperature'   : 'K',
                          'pressure'      : 'GPa',
                          'volume'        : 'Angstrom**3',
                          'frequency'     : 'THz',
                          'free_energy'   : 'kJ/mol',
                          'entropy'       : 'J/K/mol',
                          'heat_capacity' : 'J/K/mol'}}
        dump(unit, file, sort_keys=False, default_flow_style=False)
        file.write('\n')

        combine_info = {'volume'       : float(ha.volume),
                        'natom'        : int(ha.natom),
                        'total_energy' : float(ha.u_0),
                        'nqpoint'      : int(ha.nqpoint),
                        'nmode'        : int(ha.nmode),
                        'structure'    : {},
                        'phonon'       : []}

        struc = {'lattice' : ha.structure.lattice.matrix.tolist(),
                 'points' : []}
        points = []
        for spec, fcrd in zip(ha.structure.species, ha.structure.frac_coords):
            points.append({'symbol'      : str(spec.symbol),
                           'coordinates' : fcrd.tolist(),
                           'mass'        : float(spec.data['Atomic mass'])})
        struc['points'] = points
        combine_info['structure'] = struc

        phonon = []
        if len(ha.eigenvector) == 0:
            for iq in range(ha.nqpoint):
                qphonon = {'q_rank' : iq+1, 'q_position' : ha.qpoint[iq, 0:3].tolist(),
                           'weight' : int(ha.qpoint[iq, 3]), 'mode' : []}
                mode = []
                for im in range(ha.nmode):
                    mode.append({'rank' : im+1, 'frequency' : ha.frequency[iq, im].tolist(),
                                 'symmetry' : str(ha.mode_symm[iq, im])})
                qphonon['mode'] = mode
                phonon.append(qphonon)
        else:
            eigvt = np.stack([ha.eigenvector.real, ha.eigenvector.imag], axis=4)
            for iq in range(ha.nqpoint):
                qphonon = {'q_rank' : iq+1, 'q_position' : ha.qpoint[iq, 0:3].tolist(),
                           'weight' : int(ha.qpoint[iq, 3]), 'mode' : []}
                mode = []
                for im in range(ha.nmode):
                    minfo = {'rank' : im+1,
                             'frequency' : ha.frequency[iq, im].tolist(),
                             'symmetry' : str(ha.mode_symm[iq, im]),
                             'eigenvector' : eigvt[iq, im, :, :, :].tolist()}
                    mode.append(minfo)
                qphonon['mode'] = mode
                phonon.append(qphonon)

        combine_info['phonon'] = phonon
        file.write("# HA phonon information\n\n")
        add_representer(float, _out_rep)
        dump(combine_info, file, sort_keys=False, default_flow_style=None, width=float("inf"))
        file.write('\n')
        del struc, phonon, qphonon, mode, combine_info

        # basics
        if hasattr(ha, 'temperature'):
            header = {'temperature'        : ha.temperature.tolist(),
                      'pressure'           : ha.pressure.tolist()}
            file.write("# HA frequency conditions\n\n")
            add_representer(float, _inp_rep)
            dump(header, file, sort_keys=False, default_flow_style=None, width=float("inf"))
            file.write('\n')

        # functions
        if hasattr(ha, 'zp_energy'):
            results = {'zp_energy' : float(ha.zp_energy),
                       'u_vib'     : ha.u_vib.tolist(),
                       'entropy'   : ha.entropy.tolist(),
                       'c_v'       : ha.c_v.tolist(),
                       'helmholtz' : ha.helmholtz.tolist(),
                       'gibbs'     : ha.gibbs.tolist()}
            file.write("# HA thermodynamic functions\n\n")
            add_representer(float, _out_rep)
            dump(results, file, sort_keys=False, default_flow_style=None, indent=3)
            del results
            file.write('\n')

        file.close()
        return

    @classmethod
    def restart(cls, inyaml):
        """
        Regenerate a ``Harmonic`` object from the restart YAML file.

        Args:
            inyaml (str): Input file name.
        Returns:
            ha (Harmonic): HA object.
        """
        from CRYSTALpytools.thermodynamics import Harmonic
        from CRYSTALpytools.geometry import CStructure

        file = open(inyaml, 'r', errors='ignore')
        data = safe_load(file)
        file.close()

        # Unit check
        for prop, unit in zip(['temperature', 'pressure', 'volume', 'frequency',
                               'free_energy', 'entropy', 'heat_capacity'],
                              ['K', 'GPa', 'Angstrom**3', 'THz', 'kJ/mol',
                               'J/K/mol', 'J/K/mol']):
            if data['unit'][prop] != unit:
                raise Exception("The dumped property '{}' must in '{}'.".format(prop, unit))


        # Basic info
        ha = Harmonic(filename=None, autocalc=False)
        try:
            vol = data['volume']
            natom = data['natom']
            edft = data['total_energy']
            nqpoint = data['nqpoint']
            latt = np.array(data['structure']['lattice'], dtype=float)
            species = []; coords = []
            for p in data['structure']['points']:
                species.append(p['symbol'])
                coords.append(p['coordinates'])
            struc = CStructure(latt, species, coords, standarize=False)

            phonon = data['phonon']
            qpoint = []; freq = []; symm = []; eigvt = []
            if 'eigenvector' in phonon[0]['mode'][0].keys():
                eigvt_tmp = []
                for p in phonon:
                    qpoint.append(np.concatenate([p['q_position'], [p['weight']]]))
                    freq_q = []; symm_q = []; eigvt_q = []
                    for m in p['mode']:
                        freq_q.append(m['frequency'])
                        symm_q.append(m['symmetry'])
                        eigvt_q.append(m['eigenvector'])
                    freq.append(freq_q)
                    symm.append(symm_q)
                    eigvt_tmp.append(eigvt_q)
                freq = np.array(freq, dtype=float)
                symm = np.array(symm, dtype=str)
                qpoint = np.array(qpoint, dtype=float)
                eigvt_tmp = np.array(eigvt_tmp, dtype=float)
                eigvt = np.zeros(eigvt_tmp.shape[:-1], dtype=complex)
                eigvt.real = eigvt_tmp[:, :, :, :, 0]
                eigvt.imag = eigvt_tmp[:, :, :, :, 1]
            else:
                for p in phonon:
                    qpoint.append(np.concatenate([p['q_position'], [p['weight']]]))
                    freq_q = []; symm_q = []
                    for m in p['mode']:
                        freq_q.append(m['frequency'])
                        symm_q.append(m['symmetry'])
                    freq.append(freq_q)
                    symm.append(symm_q)
                freq = np.array(freq, dtype=float)
                symm = np.array(symm, dtype=str)
                qpoint = np.array(qpoint, dtype=float)
        except KeyError:
            raise Exception('Basic HA information missing. File is broken.')

        ha.from_frequency(edft, qpoint, freq, eigvt, symm, structure=struc)

        # thermodynamics
        properties = ['temperature', 'pressure',
                      'zp_energy', 'u_vib', 'entropy', 'c_v', 'helmholtz', 'gibbs']
        for p in properties:
            try:
                setattr(ha, p, np.array(data[p], dtype=float))
            except KeyError:
                pass
        return ha

# -------------------------- Deprecated Methods ------------------------------#
    @classmethod
    def old_write(cls, ha):
        """Deprecated"""
        import scipy.constants as scst
        from CRYSTALpytools.units import kjmol_to_H

        file = open(ha.filename, 'w')
        file.write('%21s%20.9e%15s%20.12e%s\n' %
                   ('# DFT TOTAL ENERGY = ', kjmol_to_H(ha.u_0),
                    ' Hartree     = ', ha.u_0, ' kJ/mol'))
        file.write('%21s%20.4f%15s%20.4f%s\n' %
                   ('# CELL VOLUME      = ', ha.volume,
                    ' Angstrom^3  = ', ha.volume * scst.Avogadro * 1e-24, ' cm^3/mol'))
        file.write('%s\n' % '# LATTICE PARAMETERS (ANGSTROM, DEGREE)')
        file.write('%12s%12s%12s%12s%12s%12s\n' % ('A', 'B', 'C',
                                                   'ALPHA', 'BETA', 'GAMMA'))
        file.write('%12.4f%12.4f%12.4f%12.4f%12.4f%12.4f\n\n' %
                   (ha.structure.lattice.parameters[0:6]))

        file.write('%-40s\n\n' % '# HARMONIC THERMODYNAMICS')
        file.write('%s%20.12e%s\n\n' % ('## ZERO POINT ENERGY = ', ha.zp_energy, ' kJ/mol'))
        file.write('%s\n\n' % '## TEMPERATURE DEPENDENT PROPERTIES')
        file.write('%8s%20s%20s%20s%20s\n' %
                   ('T(K)', 'U_vib(kJ/mol)', 'Entropy(J/mol*K)', 'C_V(J/mol*K)', 'Helmholtz(kJ/mol)'))
        for t, tempt in enumerate(ha.temperature):
            file.write('%8.2f%20.12e%20.12e%20.12e%20.12e\n' %
                       (tempt, ha.u_vib[t], ha.entropy[t], ha.c_v[t], ha.helmholtz[t]))
            file.write('\n')
            for idx_p, gibbs_p in enumerate(ha.gibbs):
                file.write('%s%8.2f%s\n\n' % ('## GIBBS FREE ENERGY AT', ha.pressure[idx_p], ' GPa'))
                file.write('%8s%20s\n' % ('T(K)', 'Gibbs(kJ/mol)'))
                for idx_t, gibbs_t in enumerate(gibbs_p):
                    file.write('%8.2f%20.12e\n' % (ha.temperature[idx_t], gibbs_t))
                file.write('\n')
            file.write('\n')

        file.write('\n')
        file.close()
        return


# Thermodynamics, QHA

class ThermoQHA():
    """Quasi-harmonic lattice dynamics I/O."""
    @classmethod
    def write_combine_data(cls, qha, overlap=[], pdt=[]):
        """
        Write combined QHA frequency info to YAML file.

        Args:
            qha (Quasi_harmonic): QHA object
            overlap (array[int]): nQpoint\*nMode_ref\*nCalc\*nMode_sort. Boolean
                array of close overlaps. The first Calc is useless (always 0).
            pdt (array[float]): nQpoint\*nCalc Dot products between n-1 and n
                calculations.
        """
        if os.path.isfile(qha.filename):
            warn("The existing QHA file will be overwritten.", stacklevel=2)

        file = open(qha.filename, 'w')
        file.write("# Units\n\n")
        unit = {'unit' : {'temperature'   : 'K',
                          'pressure'      : 'GPa',
                          'volume'        : 'Angstrom**3',
                          'frequency'     : 'THz',
                          'free_energy'   : 'kJ/mol',
                          'entropy'       : 'J/K/mol',
                          'heat_capacity' : 'J/K/mol'}}
        dump(unit, file, sort_keys=False, default_flow_style=False)
        file.write('\n')

        combine_info = {'nsample'      : len(qha.combined_volume),
                        'sample_volume': qha.combined_volume.tolist(),
                        'natom'        : qha.natom,
                        'total_energy' : qha.combined_u0.tolist(),
                        'nqpoint'      : qha.nqpoint,
                        'nmode'        : qha.nmode,
                        'modes_sorted' : qha._mode_sorted,
                        'structure'    : [],
                        'phonon'       : []}
        struc_yaml = []
        for struc in qha.combined_struc:
            entry = {'lattice' : struc.lattice.matrix.tolist(),
                     'points' : []}
            points = []
            for spec, fcrd in zip(struc.species, struc.frac_coords):
                points.append({'symbol'      : str(spec.symbol),
                               'coordinates' : fcrd.tolist(),
                               'mass'        : float(spec.data['Atomic mass'])})
            entry['points'] = points
            struc_yaml.append(entry)
        combine_info['structure'] = struc_yaml

        phonon = []
        for iq in range(qha.nqpoint):
            qphonon = {'q_rank' : iq+1, 'q_position' : qha.qpoint[iq, 0:3].tolist(),
                       'weight' : int(qha.qpoint[iq, 3]), 'mode' : []}
            mode = []
            for im in range(qha.nmode):
                mode.append({'rank' : im+1, 'frequency' : qha.combined_freq[iq, im].tolist(),
                             'symmetry' : qha.combined_symm[iq, im].tolist()})
            qphonon['mode'] = mode
            phonon.append(qphonon)
        combine_info['phonon'] = phonon

        file.write("# QHA phonon information\n\n")
        add_representer(float, _out_rep)
        dump(combine_info, file, sort_keys=False, default_flow_style=None, width=float("inf"))
        file.write('\n')
        del phonon, qphonon, mode, struc_yaml, entry, points, combine_info

        if len(overlap) == 0 or len(pdt) == 0:
            file.close()
            return

        file.write("# Close overlaps of phonon modes\n\n")
        allinfo = {'total_overlap'        : int(overlap.sum()),
                   'averaged_dot_product' : float(pdt.sum()/pdt.shape[0]/pdt.shape[1])}
        dump(allinfo, file, sort_keys=False)

        countq = 0; dumpall = []
        for qpt, qoverlap, qpdt in zip(qha.qpoint, overlap, pdt):
            countq += 1
            sort = {'q_rank' : countq,
                    'q_position' : qpt[0:3].tolist(),
                    'n_overlap' : int(qoverlap.sum()),
                    'dot_product' : qpdt.tolist()}
            rmode, scalc, smode = np.where(qoverlap==1)
            close_overlap = [{'ref_calc_rank' : int(scalc[i]),
                              'ref_mode_rank' : int(rmode[i]+1),
                              'sort_calc_rank' : int(scalc[i]+1),
                              'sort_mode_rank' : int(smode[i]+1)} for i in range(rmode.shape[0])]
            sort['close_overlap'] = close_overlap
            dumpall.append(sort)

        add_representer(float, _out_rep)
        dump({'mode_overlap' : dumpall}, file, sort_keys=False, default_flow_style=None)
        file.write('\n')
        file.close()
        return

    @classmethod
    def write_thermo_freq(cls, qha, r2tot, r2avg, min_method, volume_bound):
        """Write ``Quasi_harmonic.thermo_eos()`` fit info to YAML file."""

        if qha.method != 'thermo_freq':
            raise Exception("QHA object not generated by 'thermo_freq'. Method: {}".format(qha.method))
        if not os.path.isfile(qha.filename):
            cls.write_combine_data(qha)

        # Insert phonon frequency fitting info
        file = open(qha.filename, 'r')
        df = DataFrame(file)
        linebreak1 = df[df[0].str.contains(r'^\s*phonon:')].index.tolist()[0]
        linebreak2 = df[df[0].str.contains(r'^\s*# Close overlaps of phonon modes')].index.tolist()
        data1 = ''.join([i for i in df[0].loc[0:linebreak1-1]])
        if len(linebreak2) > 0:
            data2 = ''.join([i for i in df[0].loc[linebreak2[0]:]])
        file.close(); del df

        file = open(qha.filename, 'w')
        file.write('%s' % data1)

        phonon = []
        for iq in range(qha.nqpoint):
            qphonon = {'q_rank' : iq+1, 'q_position' : qha.qpoint[iq, 0:3].tolist(),
                       'weight' : int(qha.qpoint[iq, 3]), 'mode' : []}
            mode = []
            for im in range(qha.nmode):
                tmpmode = {'rank' : im+1,
                           'frequency' : qha.combined_freq[iq, im].tolist(),
                           'symmetry'  : qha.combined_symm[iq, im].tolist(),
                           'fit_order' : len(qha.freq_fit[iq][im].coef)-1,
                           'fit_coeff' : qha.freq_fit[iq][im].coef.tolist(),
                           'r^2'       : r2tot[iq][im]}
                mode.append(tmpmode)
            qphonon['mode'] = mode
            phonon.append(qphonon)
        tmp = {'phonon' : phonon}
        add_representer(float, _fit_rep)
        dump(tmp, file, sort_keys=False, default_flow_style=None, width=float("inf"))
        file.write('\n')

        if len(linebreak2) > 0: file.write('%s' % data2)

        # QHA basic
        header = {'temperature'        : qha.temperature.tolist(),
                  'pressure'           : qha.pressure.tolist(),
                  'method'             : qha.method,
                  'poly_order'         : qha.fit_order.tolist(),
                  'overall_r^2'        : r2avg,
                  'min_method'         : min_method}
        if np.all(volume_bound!=None):
            header['volume_bound'] = [i for i in volume_bound]
        header['equation_of_states'] = qha.eos_method

        file = open(qha.filename, 'a')
        file.write("# QHA frequency polynomial fit\n\n")
        add_representer(float, _inp_rep)
        dump(header, file, sort_keys=False, default_flow_style=None, width=float("inf"))

        # EOS fittings
        fits = {'nfit_e0'     : 1,
                'fitted_e0'   : [],
                'nfit_eos'   : len(qha.temperature),
                'fitted_eos' : []}
        eosParams = []
        if qha.eos_method in ["murnaghan", "birch", "birch_murnaghan", "pourier_tarantola", "vinet"]:
            fits['fitted_e0'] = [{'e0' : float(qha.u0_fit.e0), 'b0' : float(qha.u0_fit.b0),
                                  'b1' : float(qha.u0_fit.b1), 'v0' : float(qha.u0_fit.v0)}]
            for eos in qha.eos:
                eosParams.append({'e0' : float(eos.e0), 'b0' : float(eos.b0),
                                  'b1' : float(eos.b1), 'v0' : float(eos.v0)})
        else:
            fits['fitted_e0'] = [{'e0' : float(qha.u0_fit.e0), 'b0' : float(qha.u0_fit.b0),
                                  'b1' : float(qha.u0_fit.b1), 'v0' : float(qha.u0_fit.v0),
                                  'polynomial' : qha.u0_fit.eos_params.tolist()}]
            for eos in qha.eos:
                eosParams.append({'e0' : float(eos.e0), 'b0' : float(eos.b0),
                                  'b1' : float(eos.b1), 'v0' : float(eos.v0),
                                  'polynomial' : eos.eos_params.tolist()})
        fits['fitted_eos'] = eosParams

        add_representer(float, _fit_rep)
        dump(fits, file, sort_keys=False, default_flow_style=None, width=float("inf"))
        del header, fits, eosParams
        file.write('\n')

        file.write("# QHA thermal expansion fit\n\n")
        vt = {'volume_expansion' : {'method' : 'gruneisen'}}
        dump(vt, file, sort_keys=False, default_flow_style=None)

        # functions
        file.write("# QHA thermodynamic functions\n\n")
        results = {'gruneisen' : qha.gruneisen.tolist(),
                   'volume'    : qha.volume.tolist(),
                   'alpha_v'   : qha.alpha_v.tolist(),
                   'helmholtz' : qha.helmholtz.tolist(),
                   'gibbs'     : qha.gibbs.tolist(),
                   'entropy'   : qha.entropy.tolist(),
                   'c_v'       : qha.c_v.tolist(),
                   'c_p'       : qha.c_p.tolist(),
                   'k_t'       : qha.k_t.tolist(),
                   'k_s'       : qha.k_s.tolist()}
        add_representer(float, _out_rep)
        dump(results, file, sort_keys=False, default_flow_style=None, indent=3)
        del results
        file.write('\n')
        file.close()
        return

    @classmethod
    def write_thermo_gru(cls, qha, r2tot, r2avg, min_method, volume_bound):
        """Write ``Quasi_harmonic.thermo_gruneisen()`` fit info to YAML file."""

        if qha.method != 'thermo_gruneisen':
            raise Exception("QHA object not generated by 'thermo_gruneisen'. Method: {}".format(qha.method))
        if not os.path.isfile(qha.filename):
            cls.write_combine_data(qha)

        # Insert mode gruneisen fitting info
        file = open(qha.filename, 'r')
        df = DataFrame(file)
        linebreak1 = df[df[0].str.contains(r'^\s*phonon:')].index.tolist()[0]
        linebreak2 = df[df[0].str.contains(r'^\s*# Close overlaps of phonon modes')].index.tolist()
        data1 = ''.join([i for i in df[0].loc[0:linebreak1-1]])
        if len(linebreak2) > 0:
            data2 = ''.join([i for i in df[0].loc[linebreak2[0]:]])
        file.close(); del df

        file = open(qha.filename, 'w')
        file.write('%s' % data1)

        phonon = []
        for iq in range(qha.nqpoint):
            qphonon = {'q_rank' : iq+1, 'q_position' : qha.qpoint[iq, 0:3].tolist(),
                       'weight' : int(qha.qpoint[iq, 3]), 'mode' : []}
            mode = []
            for im in range(qha.nmode):
                tmpmode = {'rank' : im+1,
                           'frequency' : qha.combined_freq[iq, im].tolist(),
                           'symmetry'  : qha.combined_symm[iq, im].tolist(),
                           'fit_gru'   : float(qha.gru_fit[iq][im]),
                           'r^2'       : r2tot[iq][im]}
                mode.append(tmpmode)
            qphonon['mode'] = mode
            phonon.append(qphonon)
        tmp = {'phonon' : phonon}
        add_representer(float, _fit_rep)
        dump(tmp, file, sort_keys=False, default_flow_style=None, width=float("inf"))
        file.write('\n')

        if len(linebreak2) > 0: file.write('%s' % data2)

        # QHA basic
        header = {'temperature'        : qha.temperature.tolist(),
                  'pressure'           : qha.pressure.tolist(),
                  'method'             : qha.method,
                  'overall_r^2'        : r2avg,
                  'min_method'         : min_method}
        if np.all(volume_bound!=None):
            header['volume_bound'] = [i for i in volume_bound]
        header['equation_of_states'] = qha.eos_method

        ile = open(qha.filename, 'a')
        file.write("# QHA frequency polynomial fit\n\n")
        add_representer(float, _inp_rep)
        dump(header, file, sort_keys=False, default_flow_style=None, width=float("inf"))

        # EOS fittings
        fits = {'nfit_e0'     : 1,
                'fitted_e0'   : [],
                'nfit_eos'   : len(qha.temperature),
                'fitted_eos' : []}
        eosParams = []
        if qha.eos_method in ["murnaghan", "birch", "birch_murnaghan", "pourier_tarantola", "vinet"]:
            fits['fitted_e0'] = [{'e0' : float(qha.u0_fit.e0), 'b0' : float(qha.u0_fit.b0),
                                  'b1' : float(qha.u0_fit.b1), 'v0' : float(qha.u0_fit.v0)}]
            for eos in qha.eos:
                eosParams.append({'e0' : float(eos.e0), 'b0' : float(eos.b0),
                                  'b1' : float(eos.b1), 'v0' : float(eos.v0)})
        else:
            fits['fitted_e0'] = [{'e0' : float(qha.u0_fit.e0), 'b0' : float(qha.u0_fit.b0),
                                  'b1' : float(qha.u0_fit.b1), 'v0' : float(qha.u0_fit.v0),
                                  'polynomial' : qha.u0_fit.eos_params.tolist()}]
            for eos in qha.eos:
                eosParams.append({'e0' : float(eos.e0), 'b0' : float(eos.b0),
                                  'b1' : float(eos.b1), 'v0' : float(eos.v0),
                                  'polynomial' : eos.eos_params.tolist()})
        fits['fitted_eos'] = eosParams

        add_representer(float, _fit_rep)
        dump(fits, file, sort_keys=False, default_flow_style=None, width=float("inf"))
        del header, fits, eosParams
        file.write('\n')

        file.write("# QHA thermal expansion fit\n\n")
        vt = {'volume_expansion' : {'method' : 'gruneisen'}}
        dump(vt, file, sort_keys=False, default_flow_style=None)

        # functions
        file.write("# QHA thermodynamic functions\n\n")
        results = {'gruneisen' : qha.gruneisen.tolist(),
                   'volume'    : qha.volume.tolist(),
                   'alpha_v'   : qha.alpha_v.tolist(),
                   'helmholtz' : qha.helmholtz.tolist(),
                   'gibbs'     : qha.gibbs.tolist(),
                   'entropy'   : qha.entropy.tolist(),
                   'c_v'       : qha.c_v.tolist(),
                   'c_p'       : qha.c_p.tolist(),
                   'k_t'       : qha.k_t.tolist(),
                   'k_s'       : qha.k_s.tolist()}
        add_representer(float, _out_rep)
        dump(results, file, sort_keys=False, default_flow_style=None, indent=3)
        del results
        file.write('\n')
        file.close()
        return

    @classmethod
    def write_thermo_eos(cls, qha, r2tot, r2avg, min_method, volume_bound):
        """Write ``Quasi_harmonic.thermo_eos()`` fit info to YAML file."""

        if qha.method != 'thermo_eos':
            raise Exception("QHA object not generated by 'thermo_eos'. Method: {}".format(qha.method))
        if not os.path.isfile(qha.filename):
            cls.write_combine_data(qha)

        # Attach EOS fitting info
        file = open(qha.filename, 'r')
        df = DataFrame(file)
        linebreak = df[df[0].str.contains(r'\s*# QHA .* fit')].index.tolist()
        if len(linebreak) > 0:
            data = ''.join([i for i in df[0].loc[:linebreak-1]])
        else:
            data = ''.join([i for i in df[0].loc[:]])
        file.close(); del df

        file = open(qha.filename, 'w')
        file.write('%s' % data)

        # QHA basic
        header = {'temperature'        : qha.temperature.tolist(),
                  'pressure'           : qha.pressure.tolist(),
                  'method'             : qha.method,
                  'poly_order'         : qha.fit_order.tolist(),
                  'overall_r^2'        : r2avg,
                  'min_method'         : min_method}
        if np.all(volume_bound!=None):
            header['volume_bound'] = [i for i in volume_bound]
        header['equation_of_states'] = qha.eos_method
        file.write("# QHA EoS fit\n\n")
        add_representer(float, _inp_rep)
        dump(header, file, sort_keys=False, default_flow_style=None, width=float("inf"))

        # EOS fittings
        fits = {'nfit_eos'     : len(qha.temperature),
                'fitted_eos'   : [],
                'nfit_gibbs'   : len(qha.pressure),
                'fitted_gibbs' : []}
        eosParams = []
        if qha.eos_method in ["murnaghan", "birch", "birch_murnaghan", "pourier_tarantola", "vinet"]:
            for eos in qha.eos:
                eosParams.append({'e0' : float(eos.e0), 'b0' : float(eos.b0),
                                  'b1' : float(eos.b1), 'v0' : float(eos.v0)})
        else: # Polynomials
            for eos in qha.eos:
                eosParams.append({'e0' : float(eos.e0), 'b0' : float(eos.b0),
                                  'b1' : float(eos.b1), 'v0' : float(eos.v0),
                                  'polynomial' : eos.eos_params.tolist()})
        fits['fitted_eos'] = eosParams
        gibbsParams = []
        for gibbs, r2 in zip(qha.gibbs_fit, r2tot):
            gibbsParams.append({'coeffs' : gibbs.coef.tolist(),
                                'r^2'    : r2})
        fits['fitted_gibbs'] = gibbsParams

        add_representer(float, _fit_rep)
        dump(fits, file, sort_keys=False, default_flow_style=None, width=float("inf"))
        del header, fits, eosParams, gibbsParams
        file.write('\n')

        # functions
        results = {'volume'    : qha.volume.tolist(),
                   'helmholtz' : qha.helmholtz.tolist(),
                   'gibbs'     : qha.gibbs.tolist(),
                   'entropy'   : qha.entropy.tolist(),
                   'c_p'       : qha.c_p.tolist(),
                   'k_t'       : qha.k_t.tolist()}

        file.write("# QHA thermodynamic functions\n\n")
        add_representer(float, _out_rep)
        dump(results, file, sort_keys=False, default_flow_style=None, indent=3)
        del results
        file.write('\n')
        file.close()
        return

    @classmethod
    def write_expansion_vol(cls, qha, fit_order, r2tot, r2avg):
        """Write ``Quasi_harmonic.expansion_vol()`` fit info to YAML file."""

        if not hasattr(qha, 'vol_fit'):
            raise Exception("Volume expansion coefficients must be fitted by 'expansion_vol()' method.")
        data = cls._append_QHAthermo(qha, r'\s*# QHA thermal expansion fit')
        file = open(qha.filename, 'w')
        file.write('%s' % data)

        # V(T) fit
        file.write("# QHA thermal expansion fit\n\n")
        vt = {'volume_expansion' : {'method'      : 'polynomial',
                                    'poly_order'  : fit_order.tolist(),
                                    'overall_r^2' : r2avg,
                                    'vol_fit'     : []}}
        fitvt = []
        for ip in range(len(qha.pressure)):
            fitvt.append({'pressure'  : float(qha.pressure[ip]),
                          'fit_order' : len(qha.vol_fit[ip].coef)-1,
                          'fit_coeff' : qha.vol_fit[ip].coef.tolist(),
                          'r^2'       : r2tot[ip]})
        vt['volume_expansion']['vol_fit'] = fitvt
        add_representer(float, _fit_rep)
        dump(vt, file, sort_keys=False, default_flow_style=None, width=float("inf"))
        file.write('\n')
        del vt, fitvt

        # functions
        file.write("# QHA thermodynamic functions\n\n")
        results = {}
        for i in ['volume', 'alpha_v', 'helmholtz', 'gibbs', 'entropy',
                  'c_v', 'c_p', 'k_t', 'k_s']:
            if hasattr(qha, i):
                results[i] = getattr(qha, i).tolist()
        add_representer(float, _out_rep)
        dump(results, file, sort_keys=False, default_flow_style=None, indent=3)
        del results
        file.write('\n')
        file.close()
        return

    @classmethod
    def write_specific_heat(cls, qha):
        """Write ``Quasi_harmonic.specific_heat()`` info to YAML file."""

        if not hasattr(qha, 'c_v') or not hasattr(qha, 'c_p'):
            raise Exception("Missing 'c_v' or 'c_p'. The 'specific_heat()' method must be called.")
        data = cls._append_QHAthermo(qha, r'\s*# QHA thermodynamic functions')
        file = open(qha.filename, 'w')
        file.write('%s' % data)

        # functions
        file.write("# QHA thermodynamic functions\n\n")
        results = {}
        for i in ['volume', 'alpha_v', 'helmholtz', 'gibbs', 'entropy',
                  'c_v', 'c_p', 'k_t', 'k_s']:
            if hasattr(qha, i):
                results[i] = getattr(qha, i).tolist()
        add_representer(float, _out_rep)
        dump(results, file, sort_keys=False, default_flow_style=None, indent=3)
        del results
        file.write('\n')
        file.close()
        return

    @classmethod
    def write_bulk_modulus(cls, qha):
        """Write ``Quasi_harmonic.bulk_modulus()`` info to YAML file."""

        if not hasattr(qha, 'k_t') or not hasattr(qha, 'k_s'):
            raise Exception("Missing 'k_t' or 'k_s'. The 'specific_heat()' method must be called.")
        data = cls._append_QHAthermo(qha, r'\s*# QHA thermodynamic functions')
        file = open(qha.filename, 'w')
        file.write('%s' % data)

        # functions
        file.write("# QHA thermodynamic functions\n\n")
        results = {}
        for i in ['volume', 'alpha_v', 'helmholtz', 'gibbs', 'entropy',
                  'c_v', 'c_p', 'k_t', 'k_s']:
            if hasattr(qha, i):
                results[i] = getattr(qha, i).tolist()
        add_representer(float, _out_rep)
        dump(results, file, sort_keys=False, default_flow_style=None, indent=3)
        del results
        file.write('\n')
        file.close()
        return

    @classmethod
    def write_latt_poly(cls, qha, poly_order, interp, lfit, r2tot, r2avg):
        """Write ``Quasi_harmonic.lattice_poly()`` info to YAML file."""

        if not hasattr(qha, 'lattice'):
            raise Exception("Missing 'lattice' attribute. The 'lattice_poly()' method must be called.")
        data = cls._append_QHAthermo(qha, r'\s*# QHA anisotropic lattice expansions')
        file = open(qha.filename, 'w')
        file.write('%s' % data)

        # lattice - fit
        file.write("# QHA anisotropic lattice expansions\n\n")
        results = {'latt_method'     : 'polynomial',
                   'latt_sg'         : int(qha.sg),
                   'latt_nparam'     : len(lfit)+1,
                   'latt_params'     : [],
                   'latt_poly_order' : poly_order.tolist(),
                   'latt_interp'     : int(interp),
                   'latt_overall_r^2': float(r2avg),
                   'latt_nfit'       : len(lfit),
                   'latt_fitted'     : [{'fit_order' : len(lfit[i].coef)-1,
                                         'fit_coeff' : lfit[i].coef.tolist(),
                                         'r^2'       : float(r2tot[i])}
                                        for i in range(len(lfit))],
                  }
        # lattice - results
        lattice = {}
        if qha.sg > 195: # cubic
            results['latt_params'] = ['a']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
        elif qha.sg >= 75 and qha.sg < 195: # tetragonal, hexagonal and trigonal
            results['latt_params'] = ['a', 'c']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
            lattice['latt_c'] = qha.latt_params[:, :, 1].tolist()
        elif qha.sg >= 16 and qha.sg < 75:  # orthorhombic
            results['latt_params'] = ['a', 'b', 'c']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
            lattice['latt_b'] = qha.latt_params[:, :, 1].tolist()
            lattice['latt_c'] = qha.latt_params[:, :, 2].tolist()
        elif qha.sg >= 3 and qha.sg < 16:  # monoclinic
            results['latt_params'] = ['a', 'b', 'c', 'beta']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
            lattice['latt_b'] = qha.latt_params[:, :, 1].tolist()
            lattice['latt_c'] = qha.latt_params[:, :, 2].tolist()
            lattice['latt_beta'] = qha.latt_params[:, :, 3].tolist()
        else: # triclinic
            results['latt_params'] = ['a', 'b', 'c', 'alpha', 'beta', 'gamma']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
            lattice['latt_b'] = qha.latt_params[:, :, 1].tolist()
            lattice['latt_c'] = qha.latt_params[:, :, 2].tolist()
            lattice['latt_alpha'] = qha.latt_params[:, :, 3].tolist()
            lattice['latt_beta'] = qha.latt_params[:, :, 4].tolist()
            lattice['latt_gamma'] = qha.latt_params[:, :, 5].tolist()

        lattice['matrix'] = {}
        for i, a in enumerate(['a', 'b', 'c']):
            for j, c in enumerate(['x', 'y', 'z']):
                lattice['matrix']['{}_{}'.format(a, c)] = qha.lattice[:, :, i, j].tolist()

        add_representer(float, _fit_rep)
        dump(results, file, sort_keys=False, default_flow_style=None, indent=3)
        add_representer(float, _out_rep)
        dump({'lattice' : lattice}, file, sort_keys=False, default_flow_style=None, indent=3)
        del results, lattice
        file.write('\n')
        file.close()
        return

    @classmethod
    def write_latt_hess(cls, qha, interp, minargs, nlatt, r2avg):
        """Write ``Quasi_harmonic.lattice_hess()`` info to YAML file."""

        if not hasattr(qha, 'lattice'):
            raise Exception("Missing 'lattice' attribute. The 'lattice_poly()' method must be called.")
        data = cls._append_QHAthermo(qha, r'\s*# QHA anisotropic lattice expansions')
        file = open(qha.filename, 'w')
        file.write('%s' % data)

        # lattice - fit
        file.write("# QHA anisotropic lattice expansions\n\n")
        results = {'latt_method'     : 'hessian',
                   'latt_sg'         : int(qha.sg),
                   'latt_nparam'     : int(nlatt),
                   'latt_params'     : [],
                   'latt_interp'     : int(interp),
                   'latt_overall_r^2': float(r2avg)}

        # lattice - results
        lattice = {}
        if qha.sg > 195: # cubic
            results['latt_params'] = ['a']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
        elif qha.sg >= 75 and qha.sg < 195: # tetragonal, hexagonal and trigonal
            results['latt_params'] = ['a', 'c']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
            lattice['latt_c'] = qha.latt_params[:, :, 1].tolist()
        elif qha.sg >= 16 and qha.sg < 75:  # orthorhombic
            results['latt_params'] = ['a', 'b', 'c']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
            lattice['latt_b'] = qha.latt_params[:, :, 1].tolist()
            lattice['latt_c'] = qha.latt_params[:, :, 2].tolist()
        elif qha.sg >= 3 and qha.sg < 16:  # monoclinic
            results['latt_params'] = ['a', 'b', 'c', 'beta']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
            lattice['latt_b'] = qha.latt_params[:, :, 1].tolist()
            lattice['latt_c'] = qha.latt_params[:, :, 2].tolist()
            lattice['latt_beta'] = qha.latt_params[:, :, 3].tolist()
        else: # triclinic
            results['latt_params'] = ['a', 'b', 'c', 'alpha', 'beta', 'gamma']
            lattice['latt_a'] = qha.latt_params[:, :, 0].tolist()
            lattice['latt_b'] = qha.latt_params[:, :, 1].tolist()
            lattice['latt_c'] = qha.latt_params[:, :, 2].tolist()
            lattice['latt_alpha'] = qha.latt_params[:, :, 3].tolist()
            lattice['latt_beta'] = qha.latt_params[:, :, 4].tolist()
            lattice['latt_gamma'] = qha.latt_params[:, :, 5].tolist()

        lattice['matrix'] = {}
        for i, a in enumerate(['a', 'b', 'c']):
            for j, c in enumerate(['x', 'y', 'z']):
                lattice['matrix']['{}_{}'.format(a, c)] = qha.lattice[:, :, i, j].tolist()

        add_representer(float, _fit_rep)
        dump(results, file, sort_keys=False, indent=3)
        add_representer(float, _out_rep)
        dump({'lattice' : lattice}, file, sort_keys=False, default_flow_style=None, indent=3)
        del results, lattice
        file.write('\n')
        file.close()
        return

    @classmethod
    def write_expansion_latt(cls, qha, symbol, poly_order, r2tot, r2avg):
        """Write ``Quasi_harmonic.expansion_latt()`` info to YAML file."""

        if not hasattr(qha, 'latt_fit') or not hasattr(qha, 'alpha_l'):
            raise Exception("Missing 'latt_fit' or 'alpha_l' attributes. The 'expansion_latt()' method must be called.")
        data = cls._append_QHAthermo(qha, r'\s*# QHA linear thermal expansion fit')
        file = open(qha.filename, 'w')
        file.write('%s' % data)

        file.write("# QHA linear thermal expansion fit\n\n")

        if 'x' in symbol: crd = 'Cartesian'
        else: crd = 'Lattice'

        vt = {'linear_expansion' : {'method'      : 'polynomial',
                                    'poly_order'  : poly_order.tolist(),
                                    'coordinate'  : crd,
                                    'n_params'    : len(symbol),
                                    'params'      : symbol,
                                    'overall_r^2' : r2avg.tolist(),
                                    'latt_fit'    : []}}
        fits = []
        for ip in range(len(qha.pressure)):
            order = [len(i.coef)-1 for i in qha.latt_fit[ip]]
            coeff = [i.coef.tolist() for i in qha.latt_fit[ip]]
            fits.append({'pressure'  : float(qha.pressure[ip]),
                         'fit_order' : order,
                         'fit_coeff' : coeff,
                         'r^2'       : r2tot[ip].tolist()})
        vt['linear_expansion']['latt_fit'] = fits
        add_representer(float, _fit_rep)
        dump(vt, file, sort_keys=False, default_flow_style=None, width=float("inf"))
        file.write('\n')
        del vt, fits

        exp = {'alpha_l' : {}}
        alpha = np.transpose(qha.alpha_l, axes=[2,0,1])
        for s, alpha_l in zip(symbol, alpha):
            exp['alpha_l'][s] = alpha_l.tolist()
        add_representer(float, _out_rep)
        dump(exp, file, sort_keys=False, default_flow_style=None, indent=3)
        del alpha, exp
        file.write('\n')
        file.close()
        return

    @classmethod
    def restart(cls, inyaml):
        """
        Regenerate a ``Quasi_harmonic`` object from the restart YAML file.

        Args:
            inyaml (str): Input file name.
        Returns:
            qha (Quasi_harmonic): QHA object.
        """
        from pymatgen.analysis.eos import Murnaghan, Birch, BirchMurnaghan, \
            PourierTarantola, Vinet, DeltaFactor, NumericalEOS, PolynomialEOS
        from CRYSTALpytools.thermodynamics import Quasi_harmonic, Harmonic
        from CRYSTALpytools.geometry import CStructure
        from numpy.polynomial.polynomial import Polynomial

        file = open(inyaml, 'r', errors='ignore')
        data = safe_load(file)
        file.close()

        # Unit check
        for prop, unit in zip(['temperature', 'pressure', 'volume', 'frequency',
                               'free_energy', 'entropy', 'heat_capacity'],
                              ['K', 'GPa', 'Angstrom**3', 'THz', 'kJ/mol',
                               'J/K/mol', 'J/K/mol']):
            if data['unit'][prop] != unit:
                raise Exception("The dumped property '{}' must in '{}'.".format(prop, unit))

        # Basic info
        qha = Quasi_harmonic(filename=None)
        try:
            qha.ncalc = data['nsample']
            vol = data['sample_volume']
            natom = data['natom']
            edft = data['total_energy']
            nqpoint = data['nqpoint']
            mode_sorted = data['modes_sorted']
            struc = []
            for s in data['structure']:
                latt = np.array(s['lattice'], dtype=float)
                species = []; coords = []
                for p in s['points']:
                    species.append(p['symbol'])
                    coords.append(p['coordinates'])
                struc.append(CStructure(latt, species, coords, standarize=False))

            phonon = data['phonon']
            qpoint = []; freq = []; symm = []
            for p in phonon:
                qpoint.append(np.concatenate([p['q_position'], [p['weight']]]))
                freq_q = []; symm_q = []
                for m in p['mode']:
                    freq_q.append(m['frequency'])
                    symm_q.append(m['symmetry'])
                freq.append(freq_q)
                symm.append(symm_q)
            freq = np.transpose(np.array(freq, dtype=float), axes=[2, 0, 1]) # nQ*nMode*nSys to nSys*nQ*nMode
            symm = np.transpose(np.array(symm, dtype=str), axes=[2, 0, 1]) # nQ*nMode*nSys to nSys*nQ*nMode
            qpoint = np.array(qpoint, dtype=float)
        except KeyError:
            raise Exception('Basic QHA information missing. File is broken.')

        halist = []
        ## empty eigenvector
        eigvt = np.array([[[[] for i in range(natom)] for j in range(freq.shape[-1])] for k in range(freq.shape[1])])
        for i in range(qha.ncalc):
            halist.append(
                Harmonic(filename=None, autocalc=False).from_frequency(
                    edft[i], qpoint, freq[i], eigvt, symm[i], structure=struc[i]
                )
            )
        _ = qha._combine_data(halist, mode_sort_tol=None)
        qha._mode_sorted = mode_sorted # Bug fix for sorted dumping files.

        # Shared method by thermo_eos / thermo_freq / thermo_gru
        def parameterize_eos(data):
            classes = {
                "murnaghan"         : Murnaghan,
                "birch"             : Birch,
                "birch_murnaghan"   : BirchMurnaghan,
                "pourier_tarantola" : PourierTarantola,
                "vinet"             : Vinet,
                "deltafactor"       : DeltaFactor,
                "numerical_eos"     : NumericalEOS,
                "polynomial"        : PolynomialEOS,
            }
            alleos = []
            e0eos = None
            try:
                method = data['equation_of_states']
                if method in ["murnaghan", "birch", "birch_murnaghan", "pourier_tarantola", "vinet"]:
                    for i in range(data['nfit_eos']):
                        eos = classes[data['equation_of_states']]([], [])
                        eos._params = np.array([data['fitted_eos'][i]['e0'],
                                                data['fitted_eos'][i]['b0'],
                                                data['fitted_eos'][i]['b1'],
                                                data['fitted_eos'][i]['v0']], dtype=float)
                        eos.eos_params = eos._params
                        alleos.append(eos)
                    if data['method'] == 'thermo_freq' or data['method'] == 'thermo_gruneisen':
                        e0eos = classes[data['equation_of_states']]([], [])
                        e0eos._params = np.array([data['fitted_e0'][0]['e0'],
                                                  data['fitted_e0'][0]['b0'],
                                                  data['fitted_e0'][0]['b1'],
                                                  data['fitted_e0'][0]['v0']], dtype=float)
                        e0eos.eos_params = e0eos._params
                else:
                    for i in range(data['nfit_eos']):
                        eos = classes[data['equation_of_states']]([], [])
                        eos._params = np.array([data['fitted_eos'][i]['e0'],
                                                data['fitted_eos'][i]['b0'],
                                                data['fitted_eos'][i]['b1'],
                                                data['fitted_eos'][i]['v0']], dtype=float)
                        eos.eos_params = np.array(data['fitted_eos'][i]['polynomial'], dtype=float)
                        alleos.append(eos)
                    if data['method'] == 'thermo_freq' or data['method'] == 'thermo_gruneisen':
                        e0eos = classes[data['equation_of_states']]([], [])
                        e0eos._params = np.array([data['fitted_e0'][0]['e0'],
                                                  data['fitted_e0'][0]['b0'],
                                                  data['fitted_e0'][0]['b1'],
                                                  data['fitted_e0'][0]['v0']], dtype=float)
                        e0eos.eos_params = np.array(data['fitted_eos'][i]['polynomial'], dtype=float)
            except KeyError:
                pass
            return alleos, e0eos

        # Shared method by thermo_eos / thermo_freq / thermo_gru
        def parameterize_poly(data):
            allpoly = []
            try:
                if data['method'] == 'thermo_freq':
                    for iq in range(data['nqpoint']):
                        poly_q = []
                        for im in range(data['nmode']):
                            poly_q.append(Polynomial(data['phonon'][iq]['mode'][im]['fit_coeff']))
                        allpoly.append(poly_q)
                elif data['method'] == 'thermo_gruneisen':
                    for iq in range(data['nqpoint']):
                        poly_q = []
                        for im in range(data['nmode']):
                            poly_q.append(data['phonon'][iq]['mode'][im]['fit_gru'])
                        allpoly.append(poly_q)
                else:
                    for i in range(data['nfit_gibbs']):
                        allpoly.append(Polynomial(data['fitted_gibbs'][i]['coeffs']))
            except KeyError:
                pass
            return allpoly

        # QHA fit
        try:
            qha.temperature = np.array(data['temperature'], dtype=float)
            qha.pressure = np.array(data['pressure'], dtype=float)
            qha.method = data['method']
            qha.eos_method = data['equation_of_states']
            if data['method'] != 'thermo_gruneisen':
                qha.fit_order = data['poly_order']
        except KeyError: # thermo_* methods not called
            qha.method = 'unknown'
            for i in ['fit_order', 'eos_method']:
                if hasattr(qha, i): delattr(qha, i)
            return qha

        # EOS, Gibbs, freq fits
        allpoly = parameterize_poly(data)
        if qha.method == 'thermo_freq':
            if len(allpoly) == 0:
                warn('Fittings of frequencies are missing. Related information is erased.', stacklevel=2)
                delattr(qha, 'fit_order')
            else:
                qha.freq_fit = allpoly
        elif qha.method == 'thermo_gruneisen':
            if len(allpoly) == 0:
                warn('Fittings of Gruneisen parameters are missing. Related information is erased.', stacklevel=2)
            else:
                qha.gru_fit = np.array(allpoly)
        elif qha.method == 'thermo_eos':
            if len(allpoly) == 0:
                warn('Fittings of Gibbs free energy are missing. Related information is erased.', stacklevel=2)
                delattr(qha, 'fit_order')
            else:
                qha.gibbs_fit = allpoly

        eos, e0eos = parameterize_eos(data)
        if len(eos) == 0:
            warn('Fittings of equation of states are missing. Related information is erased.', stacklevel=2)
            delattr(qha, 'eos_method')
        else:
            qha.eos = eos
        if qha.method == 'thermo_freq' or qha.method == 'thermo_gruneisen':
            if e0eos == None:
                warn('Fittings of equation of states are missing. Related information is erased.', stacklevel=2)
                delattr(qha, 'eos_method')
            else:
                qha.u0_fit = e0eos

        # Expansion rate
        try:
            expmethod = data['volume_expansion']['method']
            vol_fit = []
            for i in data['volume_expansion']['vol_fit']:
                vol_fit.append(Polynomial(i['fit_coeff']))
            qha.vol_fit = vol_fit
        except KeyError:
            pass

        # Fitted data
        properties = ['gruneisen', 'volume', 'alpha_v', 'helmholtz', 'gibbs',
                      'entropy', 'c_v', 'c_p', 'k_t', 'k_s', ]
        for p in properties:
            try:
                setattr(qha, p, np.array(data[p], dtype=float))
            except KeyError:
                pass

        # Lattice expansion
        try:
            qha.sg = data['latt_sg']
            latt = data['lattice']['matrix']
            qha.lattice = np.zeros([qha.volume.shape[0], qha.volume.shape[1], 3, 3], dtype=float)
            for i, symi in enumerate(['a', 'b', 'c']):
                for j, symj in enumerate(['x', 'y', 'z']):
                    qha.lattice[:, :, i, j] = latt['{}_{}'.format(symi, symj)]
        except KeyError:
            if hasattr(qha, 'lattice'): delattr(qha, 'lattice')
            if hasattr(qha, 'sg'): delattr(qha, 'sg')

        try:
            nparam = data['linear_expansion']['n_params']
            names = data['linear_expansion']['params']
            qha.latt_fit = []
            for ip in range(len(qha.pressure)):
                latt_p = []
                for i in range(nparam):
                    latt_p.append(Polynomial(data['linear_expansion']['latt_fit'][ip]['fit_coeff'][i]))
                qha.latt_fit.append(latt_p)

            qha.alpha_l = np.zeros([len(qha.pressure), len(qha.temperature), nparam])
            for i in range(nparam):
                qha.alpha_l[:, :, i] = data['alpha_l'][names[i]]
        except KeyError:
            if hasattr(qha, 'alpha_l'): delattr(qha, 'alpha_l')
            if hasattr(qha, 'latt_fit'): delattr(qha, 'latt_fit')

        return qha

    @classmethod
    def _append_QHAthermo(cls, qha, commentline):
        """For expansion coefficients, specific heat and bulk modulus"""
        if not os.path.isfile(qha.filename):
            if qha.method == 'thermo_freq' or qha.method == 'thermo_gruneisen':
                r2tot = [['unknown' for i in range(qha.nmode)] for j in range(qha.nqpoint)]
                cls.write_thermo_freq(qha, r2tot, 'unknown', 'unknown', None)
            elif qha.method == 'thermo_eos':
                r2tot = ['unknown' for i in range(len(qha.pressure))]
                cls.write_thermo_eos(qha, r2tot, 'unknown', 'unknown', None)
            else:
                raise Exception("Unknown QHA fitting method: '{}'. Unable to dump the data correctly.".format(qha.method))

        file = open(qha.filename, 'r')
        df = DataFrame(file)
        linebreak = df[df[0].str.contains(commentline)].index.tolist()
        if len(linebreak) > 0:
            data = ''.join([i for i in df[0].loc[:linebreak[0]-1]])
        else:
            data = ''.join([i for i in df[0].loc[:]])
        file.close(); del df
        return data

# -------------------------- Deprecated Methods ------------------------------#
    @classmethod
    def old_write_combine_data(cls, qha, overlap):
        """Deprecated"""
        file = open(qha.filename, 'w')
        file.write('%s\n' % '# COMBINED QHA DATA')
        file.write('%s' % '## SAMPLED VOLUMES(ANGSTROM^3) = ')
        for v in qha.combined_volume:
            file.write('%16.4e' % v)

        file.write('\n')

        file.write('%s' % '## DFT TOTAL ENERGIES(KJ/MOL CELL) = ')
        for e in qha.combined_u0:
            file.write('%16.6e' % e)

        file.write('\n\n')

        file.write('%s\n\n' % '## COMBINED MODES')
        for idx_q, mode_q in enumerate(qha.combined_freq):
            file.write('%s%8i\n\n' % ('### FREQUENCIES AT QPOINT #', idx_q))
            for imode, mode in enumerate(mode_q):
                file.write('%8s%22s%22s\n' % ('Mode #', 'Volume(Angstrom^3)', 'Frequency(THz)'))
                for i in range(qha.ncalc):
                    if i == 0:
                        file.write('{:8d}'.format(imode+1))
                    else:
                        file.write('%8s' % '')

                    file.write('%22.4f%22.4f\n' % (qha.combined_volume[i], mode[i]))
                file.write('\n')
            file.write('\n')

        if len(overlap) > 0:
            file.write('%s\n\n' % '## CLOSE OVERLAPS OF PHONON FREQUENCIES')
            for idx_q, mode_q in enumerate(qha.combined_freq):
                file.write('%30s%8i\n\n' % ('### CLOSE OVERLAPS AT QPOINT #', idx_q))
                file.write('%s%8i\n\n' % ('    Total number of overlaps =', np.sum(close_overlap[idx_q])))
                file.write('%6s%s\n' % ('', 'Mode and calc order starts from 1. Calc number in ascending order of volume'))
                file.write('%16s%16s%16s%16s\n' %
                           ('Ref_mode #', 'Sort_mode #', 'Ref_Calc #', 'Sort_Calc #'))
                for idx_mref, mode in enumerate(mode_q):
                    if np.sum(close_overlap[idx_q, idx_mref]) < 1:
                        continue
                    for idx_csort in range(1, qha.ncalc):
                        for idx_msort in range(qha.nmode):
                            if close_overlap[idx_q, idx_mref, idx_csort, idx_msort] != 0:
                                file.write('%16i%16i%16i%16i\n' %
                                           (idx_mref + 1, idx_msort + 1, idx_csort, idx_csort + 1))
                file.write('\n')
        file.close()
        return

    @classmethod
    def old_write_eosfit(cls, qha, eos, method):
        """Deprecated"""
        import scipy.constants as scst

        file = open(qha.filename, 'a+')
        file.write('%s%s\n' % ('# EQUATION OF STATES FITTED FOR ELECTRON TOTAL ENERGY: ', method))
        file.write('%s\n' % '  Electron total energy is fitted as the function of volume, of which the')
        file.write('%s\n\n' % '  formalism is given by equation of states.')
        file.write('%16s%16s%12s%12s\n' % ('E0(kJ/mol)', 'V0(Angstrom^3)', 'B0(GPa)', 'B1'))
        file.write('%16.4f%16.4f%12.4f%12.4f\n' % (eos.e0, eos.v0, eos.b0 * 1e24 / scst.Avogadro, eos.b1))
        file.write('\n')
        file.close()
        return

    @classmethod
    def old_write_polyfit(cls, qha, r2tot, r2avg):
        """Deprecated"""
        file = open(qha.filename, 'a+')
        file.write('%s\n' % '# POLYNOMIAL FIT OF MODE FREQUENCY')
        file.write('%s\n' % '  Frequency of each vibrational mode is fitted as the polynomial function of')
        file.write('%s\n' % '  volume, with specified orders of power.')
        for idx_q, mode_q in enumerate(qha.combined_freq):
            file.write('%8s%8s%12s%s\n' %
                       ('Mode #', 'Order', 'R^2', '  Coeff low to high (Constant term = 0)'))
            for imode, mode in enumerate(mode_q):
                file.write('{:8d}'.format(imode+1))
                file.write('%8i%10.6f%2s' % (qha.freq_fit[idx_q][imode].coef.shape[0]-1,
                                             r2tot[idx_q, imode], ''))
                for idx_c, c in enumerate(qha.freq_fit[idx_q][imode].coef):
                    if idx_c == 0:
                        continue
                    file.write('%12.4e' % c)
                file.write('\n')

            # Overall performance
            file.write('%s%8i\n' % ('## POLYNOMIAL FIT GOODNESS AT QPOINT #', idx_q))
            file.write('%12s\n' % ('R^2'))
            file.write('%12.6f\n' % (r2avg[idx_q]))
            file.write('\n')

        # file.write('%s%8i\n\n' % ('## THE OPTIMAL ORDER OF POLYNOMIAL =', qha.fit_order))
        file.close()
        return

    @classmethod
    def old_write_thermo_freq(cls, qha, min_method, volume_bound):
        """Deprecated"""
        file = open(qha.filename, 'a+')
        file.write('%s\n' % '# QHA THERMODYNAMIC PROPERTIES - FREQUENCY')
        file.write('%s\n\n' % '  QHA thermodynamic properties by explicitly fitting frequencies.')
        file.write('## FREQUENCY POLYNOMIAL ORDER: ')
        for i in qha.fit_order:
            file.write('%6i' % i)
        file.write('\n')
        file.write('%s%s\n' % ('## EQUILIBRIUM VOLUME MINIMISATION: ', min_method))
        file.write('%s%s\n' % ('## HELMHOLTZ FREE ENERGY EOS: ', qha.eos_method))
        if np.all(volume_bound!=None):
            file.write('%s\n' %
                       ('## CONSTRAINED VOLUME MINIMIZATION LAUNCHED. VOLUME BOUNDARIES (UNIT: ANGSTROM^3):'))
            file.write('%s%8.2f%s%8.2f\n\n' % 
                       ('## LOWER: ', volume_bound[0], ' UPPER: ', volume_bound[1]))

        for idx_p, press in enumerate(qha.pressure):
            file.write('%s%6.2f%s\n\n' % ('## THERMODYNAMIC PROPERTIES AT ', press, '  GPa'))
            file.write('%10s%20s%20s%20s%20s%20s\n' %
                       ('T(K)', 'Vol(Angstrom^3)', 'Helmholtz(kJ/mol)',
                        'Gibbs(kJ/mol)', 'Entropy(J/mol*K)', 'C_V(J/mol*K)'))
            for idx_t, tempt in enumerate(qha.temperature):
                file.write('%10.2f%20.4f%20.8e%20.8e%20.8e%20.8e\n' %
                           (tempt, qha.volume[idx_p, idx_t],
                            qha.helmholtz[idx_p, idx_t],
                            qha.gibbs[idx_p, idx_t],
                            qha.entropy[idx_p, idx_t],
                            qha.c_v[idx_p, idx_t])
                          )
            file.write('\n')

        file.write('\n')
        file.close()
        return


    @classmethod
    def old_write_thermo_eos(cls, qha):
        """Deprecated"""
        file = open(qha.filename, 'a+')
        file.write('%s\n' % '# QHA THERMODYNAMIC PROPERTIES - EOS FIT')
        file.write('%s\n\n' % '  Thermodynamic properties obtained by overall fitting of equation of states.')
        file.write('%s%s\n' % ('## EQUATION OF STATES: ', qha.eos_method))
        # file.write('%s%i\n' % ('## G(T) POLYNOMIAL ORDER: ', qha.fit_order)) # that only saves the last polynomial's order.
        file.write('%s\n' %
                   '  WARNING: Entropy at low temperature is probably inaccurate due to the poor fitting of G(T) near 0K.')
        for idx_p, press in enumerate(qha.pressure):
            file.write('%s%6.2f%s\n\n' % ('## THERMODYNAMIC PROPERTIES AT ', press, '  GPa'))
            file.write('%10s%20s%20s%20s%20s%20s\n' %
                        ('T(K)', 'Vol(Angstrom^3)', 'Helmholtz(kJ/mol)',
                         'Gibbs(kJ/mol)', 'Entropy(J/mol*K)', 'C_p(J/mol*K)'))
            for idx_t, tempt in enumerate(qha.temperature):
                file.write('%10.1f%20.4f%20.8e%20.8e%20.8e%20.8e\n' %
                               (tempt,
                                qha.volume[idx_p, idx_t],
                                qha.helmholtz[idx_p, idx_t],
                                qha.gibbs[idx_p, idx_t],
                                qha.entropy[idx_p, idx_t],
                                qha.c_p[idx_p, idx_t])
                          )
            file.write('\n')

        file.write('\n')
        file.close()
        return

    @classmethod
    def old_write_thermo_gru(cls, qha):
        """Deprecated"""
        file = open(qha.filename, 'a+')
        file.write('%s\n' % '# QHA THERMODYNAMIC PROPERTIES - GRÜENEISEN MODEL')
        file.write('%s\n\n' % '  Linear dependency of frequency with volume is assumed.')
        for idx_p, p in enumerate(qha.pressure):
            file.write('%s%6.2f%s\n\n' % ('## GRÜENEISEN THERMODYNAMICS AT ', p, '  GPa'))
            file.write('%10s%10s%20s%20s%20s%20s%20s\n' %
                        ('T(K)', 'GRÜ PARAM','alpha_VGRÜ(K^-1)', 'C_v(J/mol*K)',
                         'C_pGRÜ(J/mol*K)', 'K_T(GPa)', 'K_SGRÜ(GPa)'))
            for idx_t, t in enumerate(qha.temperature):
                file.write('%10.1f%10.4f%20.8e%20.8e%20.8e%20.8e%20.8e\n' %
                            (t,
                             qha.gruneisen[idx_p, idx_t],
                             qha.alpha_v[idx_p, idx_t],
                             qha.c_v[idx_p, idx_t],
                             qha.c_p[idx_p, idx_t],
                             qha.k_t[idx_p, idx_t],
                             qha.k_s[idx_p, idx_t])
                          )
            file.write('\n')

        file.write('\n')
        file.close()
        return


    @classmethod
    def old_write_expansion_vol(cls, qha, r2tot, r2avg):
        """Deprecated"""
        idx_tmin = np.argmin(qha.temperature)
        tmin = qha.temperature[idx_tmin]

        file = open(qha.filename, 'a+')
        file.write('%s\n' % '# THERMAL EXPANSION COEFFICIENTS')
        file.write('%s\n\n' % '  To get thermal expansion coefficients, equilibrium volumes are fit as polynomial function of temperature at constant pressure.')
        # file.write('%s%i\n' % ('## TESTED ORDERS OF POLYNOMIAL: ', fit_order))
        for idx_p, p in enumerate(qha.pressure):
            file.write('%s%6.2f%s%6.4f\n\n' %
                        ('## EXPANSIONS AT ', p, '  GPa, R^2 = ', r2tot[idx_p]))
            file.write('%10s%20s%20s\n' %
                       ('T(K)', 'Vol(Angstrom^3)', 'alpha_V(K^-1)'))
            for idx_t, t in enumerate(qha.temperature):
                file.write('%10.1f%20.4f%20.8e\n' %
                            (t, qha.vol_fit[idx_p](t - tmin), qha.alpha_v[idx_p, idx_t]))
            file.write('\n')

        file.write('\n')
        file.close()
        return

    @classmethod
    def old_write_bulk_modulus(cls, qha, adiabatic):
        """Deprecated"""
        file = open(qha.filename, 'a+')
        file.write('%s\n' % '# QHA BULK MODULI')
        file.write('%s\n\n' % '  Isothermal and adiabatic bulk moduli.')
        for idx_p, p in enumerate(qha.pressure):
            file.write('%s%6.2f%s\n\n' % ('## BULK MODULI K_T and K_S AT ', p, '  GPa'))
            if adiabatic == True:
                file.write('%10s%20s%20s\n' % ('T(K)', 'K_T(GPa)', 'K_S(GPa)'))
                for idx_t, t in enumerate(qha.temperature):
                    file.write('%10.1f%20.8e%20.8e\n' %
                               (t, qha.k_t[idx_p, idx_t], qha.k_s[idx_p, idx_t]))
                file.write('\n')
            else:
                file.write('%10s%20s\n' % ('T(K)', 'K_T(GPa)'))
                for idx_t, t in enumerate(qha.temperature):
                    file.write('%10.1f%20.8e\n' % (t, qha.k_t[idx_p, idx_t]))
                file.write('\n')

        file.write('\n')
        file.close()
        return

    @classmethod
    def old_write_specific_heat(cls, qha):
        """Deprecated"""
        file = open(qha.filename, 'a+')
        file.write('%s\n' % '# QHA SPECIFIC HEAT')
        file.write('%s\n\n' % '  Constant volume and pressure specific heat.')
        for idx_p, p in enumerate(qha.pressure):
            file.write('%s%6.2f%s\n\n' % ('## SPECIFIC HEAT C_V and C_P AT ', p, '  GPa'))
            file.write('%10s%20s%20s\n' % ('T(K)', 'C_v(J/mol*K)', 'C_p(J/mol*K)'))
            for idx_t, t in enumerate(qha.temperature):
                file.write('%10.1f%20.8e%20.8e\n' % (t, qha.c_v[idx_p, idx_t], qha.c_p[idx_p, idx_t]))
            file.write('\n')

        file.write('\n')
        file.close()
        return

