# filename: codebase/spatial_matching.py
#!/usr/bin/env python3
"""
This script implements the spatial matching algorithm to assign users to energy operators.
It uses an R-tree spatial index for efficient point-in-polygon queries and also includes a naive 
implementation for benchmarking purposes. Additionally, the script tests edge case scenarios 
(e.g., points on polygon boundaries) and validates that both methods produce identical results.

The script reads operator and user data from CSV files located in the 'data/' folder (generated by 
the simulated data generator). The operator CSV contains polygons stored as WKT strings (in the column 
'polygon_wkt'). The output matching results are stored in 'data/user_operator_matches.csv'.

Usage:
    python codebase/spatial_matching.py
"""

import os
import time
import pandas as pd
import numpy as np
import random
from shapely.geometry import Point
from shapely import wkt
from shapely.strtree import STRtree
import matplotlib.pyplot as plt
from matplotlib import rcParams

# Enable LaTeX rendering for plots and set font family
rcParams['text.usetex'] = True
rcParams['font.family'] = 'serif'

def load_operator_data(filepath="data/operators.csv"):
    r"""
    Loads operator data from a CSV file and reconstructs the polygon geometries.

    Args:
        filepath (str): Path to the operators CSV file.

    Returns:
        tuple: A tuple (operator_geoms, operator_info_list) where:
            - operator_geoms (list): List of shapely.geometry.Polygon objects.
            - operator_info_list (list): List of dictionaries with operator information 
              (each dict includes keys such as 'operator_id', 'county', etc.).
    """
    df = pd.read_csv(filepath)
    operator_geoms = []
    operator_info_list = []
    for _, row in df.iterrows():
        poly = wkt.loads(row['polygon_wkt'])
        operator_geoms.append(poly)
        # Store operator details
        info = {
            "operator_id": row["operator_id"],
            "county": row["county"],
            "base_cost": row["base_cost"],
            "winter_cost": row["winter_cost"],
            "spring_cost": row["spring_cost"],
            "summer_cost": row["summer_cost"],
            "autumn_cost": row["autumn_cost"]
        }
        operator_info_list.append(info)
    return operator_geoms, operator_info_list

def load_user_data(filepath="data/users.csv"):
    r"""
    Loads user data from a CSV file.

    Args:
        filepath (str): Path to the users CSV file.

    Returns:
        pd.DataFrame: DataFrame containing user data.
    """
    users_df = pd.read_csv(filepath)
    return users_df

def build_rtree(operator_geoms, operator_info_list):
    r"""
    Builds an R-tree spatial index for the operator polygons and creates a mapping from polygon id to operator info.

    Args:
        operator_geoms (list): List of shapely.geometry.Polygon objects.
        operator_info_list (list): List of operator information dictionaries.

    Returns:
        tuple: (tree, operator_mapping) where:
            - tree (STRtree): Spatial index built from operator_geoms.
            - operator_mapping (dict): Mapping from id(polygon) to operator info.
    """
    tree = STRtree(operator_geoms)
    operator_mapping = {id(geom): info for geom, info in zip(operator_geoms, operator_info_list)}
    return tree, operator_mapping

def match_users_rtree(users_df, tree, operator_mapping, operator_geoms):
    r"""
    Matches each user to operator polygons using the R-tree for spatial filtering.

    For each user, constructs a Point from (longitude, latitude), queries the R-tree to retrieve candidate 
    polygons using bounding box intersection, and then performs an exact test (using contains/touches) to verify 
    if the point is in (or on the boundary of) the polygon.

    This function handles cases where the STRtree returns indices instead of geometry objects by checking 
    the type of returned candidate.

    Args:
        users_df (pd.DataFrame): DataFrame containing user data.
        tree (STRtree): R-tree spatial index of operator polygons.
        operator_mapping (dict): Mapping from id(polygon) to operator info.
        operator_geoms (list): Original list of operator polygons.

    Returns:
        dict: Dictionary mapping user_id to a list of matched operator_ids.
    """
    matches = {}
    for _, user in users_df.iterrows():
        user_id = user["user_id"]
        point = Point(user["longitude"], user["latitude"])
        # Query the R-tree for candidate polygons. Depending on the Shapely version, this might return indices.
        candidate_items = tree.query(point)
        matched_operator_ids = []
        for candidate in candidate_items:
            # If candidate doesn't have 'contains', assume it's an index
            if not hasattr(candidate, "contains"):
                candidate_geom = operator_geoms[int(candidate)]
            else:
                candidate_geom = candidate
            # Check if the point is inside or on the boundary
            if candidate_geom.contains(point) or candidate_geom.touches(point):
                op_info = operator_mapping[id(candidate_geom)]
                matched_operator_ids.append(op_info["operator_id"])
        matches[user_id] = matched_operator_ids
    return matches

def match_users_naive(users_df, operator_geoms, operator_info_list):
    r"""
    Naively matches each user to operators by iterating through all operator polygons.

    This function serves as a baseline for benchmarking. It does not use any spatial index.

    Args:
        users_df (pd.DataFrame): DataFrame containing user data.
        operator_geoms (list): List of operator polygons.
        operator_info_list (list): List of operator information dictionaries.

    Returns:
        dict: Dictionary mapping user_id to a list of matched operator_ids.
    """
    matches = {}
    for _, user in users_df.iterrows():
        user_id = user["user_id"]
        point = Point(user["longitude"], user["latitude"])
        matched_operator_ids = []
        for poly, op_info in zip(operator_geoms, operator_info_list):
            if poly.contains(point) or poly.touches(point):
                matched_operator_ids.append(op_info["operator_id"])
        matches[user_id] = matched_operator_ids
    return matches

def benchmark_matching(users_df, operator_geoms, operator_info_list, tree, operator_mapping):
    r"""
    Benchmarks the R-tree based matching algorithm against the naive approach.

    Args:
        users_df (pd.DataFrame): DataFrame containing user data.
        operator_geoms (list): List of operator polygons.
        operator_info_list (list): List of operator information dictionaries.
        tree (STRtree): Spatial index built from operator_geoms.
        operator_mapping (dict): Mapping from id(polygon) to operator info.

    Returns:
        tuple: (rtree_time, naive_time) representing the execution times (in seconds) of the two methods.
    """
    # Benchmark R-tree matching
    start_time = time.perf_counter()
    _ = match_users_rtree(users_df, tree, operator_mapping, operator_geoms)
    rtree_time = time.perf_counter() - start_time

    # Benchmark naive matching
    start_time = time.perf_counter()
    _ = match_users_naive(users_df, operator_geoms, operator_info_list)
    naive_time = time.perf_counter() - start_time

    return rtree_time, naive_time

def validate_matches(rtree_matches, naive_matches):
    r"""
    Validates that the R-tree based matching and the naive matching return identical results.

    Args:
        rtree_matches (dict): Matching results from the R-tree method.
        naive_matches (dict): Matching results from the naive method.

    Returns:
        bool: True if both methods produce identical results for every user, False otherwise.
    """
    all_match = True
    for user_id in rtree_matches:
        rtree_list = sorted(rtree_matches[user_id])
        naive_list = sorted(naive_matches.get(user_id, []))
        if rtree_list != naive_list:
            print(f"Mismatch for user {user_id}: R-tree = {rtree_list}, Naive = {naive_list}")
            all_match = False
    return all_match

def test_edge_cases(operator_geoms, operator_mapping):
    r"""
    Tests edge cases by creating points exactly on the boundaries of each operator polygon.

    For each operator, uses one of the boundary coordinates (first coordinate of the exterior) to create a test point,
    then uses the R-tree to determine which operator(s) the point is matched to.

    Prints the results.

    Args:
        operator_geoms (list): List of operator polygons.
        operator_mapping (dict): Mapping from id(polygon) to operator info.
    """
    print("\nTesting Edge Cases (Points on Boundaries):")
    tree = STRtree(operator_geoms)
    for poly in operator_geoms:
        boundary_point = Point(poly.exterior.coords[0])
        candidates = tree.query(boundary_point)
        matched = []
        for candidate in candidates:
            if not hasattr(candidate, "contains"):
                candidate_geom = operator_geoms[int(candidate)]
            else:
                candidate_geom = candidate
            if candidate_geom.contains(boundary_point) or candidate_geom.touches(boundary_point):
                op_info = operator_mapping[id(candidate_geom)]
                matched.append(op_info["operator_id"])
        op_info_main = operator_mapping[id(poly)]
        print(f"Boundary point of operator {op_info_main['operator_id']} (county: {op_info_main['county']}) "
              f"matched with operators: {matched}")

def save_matches_to_csv(matches, output_filepath="data/user_operator_matches.csv"):
    r"""
    Saves the user to operator matching results to a CSV file.

    Args:
        matches (dict): Dictionary mapping user_id to list of matched operator_ids.
        output_filepath (str): File path for the CSV output.
    """
    records = []
    for user_id, op_ids in matches.items():
        records.append({
            "user_id": user_id,
            "matched_operator_ids": ";".join(map(str, op_ids)) if op_ids else ""
        })
    df = pd.DataFrame(records)
    df.to_csv(output_filepath, index=False)
    print(f"\nUser to operator matching results saved to: {output_filepath}")

def plot_benchmark(rtree_time, naive_time, output_path="data/benchmark_comparison.png"):
    r"""
    Creates a bar chart comparing the runtime of the R-tree method vs. the Naive method.
    
    Args:
        rtree_time (float): Runtime of the R-tree based matching.
        naive_time (float): Runtime of the naive matching.
        output_path (str): Path to save the benchmark plot image.
    """
    methods = ['R-tree', 'Naive']
    times = [rtree_time, naive_time]
    
    fig, ax = plt.subplots(figsize=(6, 5))
    bars = ax.bar(methods, times, color=['green', 'red'], alpha=0.7)
    for bar, t in zip(bars, times):
        ax.text(bar.get_x() + bar.get_width()/2, bar.get_height(), f"{t:.6f}s",
                ha="center", va="bottom", fontsize=10)
    ax.set_title(r"Benchmark: R-tree vs. Naive Matching", fontsize=14)
    ax.set_ylabel(r"Time (seconds)", fontsize=12)
    ax.grid(True, linestyle='--', alpha=0.5)
    ax.relim()
    ax.autoscale_view()
    plt.savefig(output_path, dpi=300, bbox_inches='tight')
    plt.close(fig)
    print(f"Benchmark plot saved to: {output_path}")

def main():
    r"""
    Main function to perform spatial matching of users to energy operators using both R-tree and naive methods.
    Benchmarks the performance of each method, validates the matching results, tests edge cases, and saves the
    final matching output to a CSV file.
    """
    # Create data directory if it doesn't exist
    data_dir = "data"
    os.makedirs(data_dir, exist_ok=True)
    
    # Load operator and user data
    operator_geoms, operator_info_list = load_operator_data()
    users_df = load_user_data()

    # Build R-tree spatial index
    tree, operator_mapping = build_rtree(operator_geoms, operator_info_list)

    # Perform matching using the R-tree based method (passing operator_geoms for candidate resolution)
    rtree_matches = match_users_rtree(users_df, tree, operator_mapping, operator_geoms)

    # Perform matching using the naive method (for benchmarking and validation)
    naive_matches = match_users_naive(users_df, operator_geoms, operator_info_list)

    # Benchmark both methods
    rtree_time, naive_time = benchmark_matching(users_df, operator_geoms, operator_info_list, tree, operator_mapping)
    print(f"\nBenchmark Results:\nR-tree matching time: {rtree_time:.6f} seconds\nNaive matching time: {naive_time:.6f} seconds")

    # Plot benchmark comparison
    plot_benchmark(rtree_time, naive_time)

    # Validate that both methods yield identical results
    if validate_matches(rtree_matches, naive_matches):
        print("\nValidation Successful: Both matching methods produced identical results.")
    else:
        print("\nValidation Failed: Mismatches found between matching methods.")

    # Test edge case scenarios (points on boundaries)
    test_edge_cases(operator_geoms, operator_mapping)

    # Save matching results to CSV
    save_matches_to_csv(rtree_matches)

if __name__ == '__main__':
    # Set random seeds for reproducibility
    random.seed(42)
    np.random.seed(42)
    main()