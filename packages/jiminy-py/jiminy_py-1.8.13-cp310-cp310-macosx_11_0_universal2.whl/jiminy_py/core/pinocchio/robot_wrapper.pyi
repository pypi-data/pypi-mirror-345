from _typeshed import Incomplete

__all__ = ['RobotWrapper']

class RobotWrapper:
    @staticmethod
    def BuildFromURDF(filename, package_dirs: Incomplete | None = None, root_joint: Incomplete | None = None, verbose: bool = False, meshLoader: Incomplete | None = None): ...
    def initFromURDF(self, filename, package_dirs: Incomplete | None = None, root_joint: Incomplete | None = None, verbose: bool = False, meshLoader: Incomplete | None = None) -> None: ...
    model: Incomplete
    collision_model: Incomplete
    visual_model: Incomplete
    v0: Incomplete
    q0: Incomplete
    viz: Incomplete
    def __init__(self, model=..., collision_model: Incomplete | None = None, visual_model: Incomplete | None = None, verbose: bool = False) -> None: ...
    @property
    def nq(self): ...
    @property
    def nv(self): ...
    def com(self, q: Incomplete | None = None, v: Incomplete | None = None, a: Incomplete | None = None): ...
    def vcom(self, q, v): ...
    def acom(self, q, v, a): ...
    def centroidalMomentum(self, q, v): ...
    def centroidalMap(self, q): ...
    def centroidal(self, q, v): ...
    def centroidalMomentumVariation(self, q, v, a): ...
    def Jcom(self, q): ...
    def mass(self, q): ...
    def nle(self, q, v): ...
    def gravity(self, q): ...
    def forwardKinematics(self, q, v: Incomplete | None = None, a: Incomplete | None = None) -> None: ...
    def placement(self, q, index, update_kinematics: bool = True): ...
    def velocity(self, q, v, index, update_kinematics: bool = True, reference_frame=...): ...
    def acceleration(self, q, v, a, index, update_kinematics: bool = True, reference_frame=...): ...
    def classicalAcceleration(self, q, v, a, index, update_kinematics: bool = True, reference_frame=...): ...
    def framePlacement(self, q, index, update_kinematics: bool = True): ...
    def frameVelocity(self, q, v, index, update_kinematics: bool = True, reference_frame=...): ...
    def frameAcceleration(self, q, v, a, index, update_kinematics: bool = True, reference_frame=...): ...
    def frameClassicalAcceleration(self, q, v, a, index, update_kinematics: bool = True, reference_frame=...): ...
    def frameClassicAcceleration(self, index): ...
    def jointJacobian(self, q, index): ...
    def computeJointJacobian(self, q, index): ...
    def getJointJacobian(self, index, rf_frame=...): ...
    def computeJointJacobians(self, q): ...
    def updateGeometryPlacements(self, q: Incomplete | None = None, visual: bool = False) -> None: ...
    def framesForwardKinematics(self, q) -> None: ...
    def buildReducedRobot(self, list_of_joints_to_lock, reference_configuration: Incomplete | None = None): ...
    def getFrameJacobian(self, frame_id, rf_frame=...): ...
    def frameJacobian(self, q, frame_id): ...
    def computeFrameJacobian(self, q, frame_id): ...
    data: Incomplete
    collision_data: Incomplete
    visual_data: Incomplete
    def rebuildData(self) -> None: ...
    def index(self, name): ...
    @property
    def viewer(self): ...
    def setVisualizer(self, visualizer, init: bool = True, copy_models: bool = False) -> None: ...
    def getViewerNodeName(self, geometry_object, geometry_type): ...
    def initViewer(self, share_data: bool = True, *args, **kwargs) -> None: ...
    def initDisplay(self, windowName: str = 'python-pinocchio', sceneName: str = 'world', loadModel: bool = False) -> None: ...
    def initMeshcatDisplay(self, meshcat_visualizer, robot_name: str = 'pinocchio', robot_color: Incomplete | None = None) -> None: ...
    def loadViewerModel(self, *args, **kwargs) -> None: ...
    def loadDisplayModel(self, rootNodeName: str = 'pinocchio') -> None: ...
    def display(self, q) -> None: ...
    def displayCollisions(self, visibility) -> None: ...
    def displayVisuals(self, visibility) -> None: ...
    def play(self, q_trajectory, dt) -> None: ...
