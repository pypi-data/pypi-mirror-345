import socket
from scapy.all import *
from scapy.layers.inet import IP, UDP, ICMP, TCP
import threading
from queue import Queue

# Deprecated
def scan_tcp_port_v0_1_5(ip: str, port: int, timeout: float = 0.5) -> bool:
    try:
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(timeout)
            return sock.connect_ex((ip, port)) == 0
    except Exception:
        return False
    
def scan_tcp_port(ip: str, port: int, timeout: float = 0.5, is_root=False, is_verbose=False,
            open_ports: list[int] = []) -> bool:
    if is_root:
        # SYN Scan (requires root privileges)
        pkt = IP(dst=ip)/TCP(dport=port, flags="S")
        ans = sr1(pkt, timeout=timeout, verbose=0)
        if ans is None:
            if is_verbose:
                print(f"[-] {ip}:{port}     CLOSED/FILTERED")
            return False
        elif ans.haslayer(TCP):
            if ans[TCP].flags & 0x12:  # SYN-ACK (0x12) means port is open
                rst_pkt = IP(dst=ip)/TCP(dport=port, flags="R")
                send(rst_pkt, verbose=0)
                print(f"[+] {ip}:{port}     OPEN")
                open_ports.append(port)
                return True
        elif ans.haslayer(ICMP):
            if is_verbose:
                print(f"[-] {ip}:{port}     FILTERED")
            return False
        if is_verbose:
            print(f"[-] {ip}:{port}     UNKNOWN")
        return False
    else:
        # TCP Connect Scan (no root privileges needed)
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((ip, port))
            if result == 0:
                print(f"[+] {ip}:{port}     OPEN")
                open_ports.append(port)
                return True
            else:
                if is_verbose:
                    print(f"[-] {ip}:{port}     CLOSED")
                return False
        except socket.error as err:
            if is_verbose:
                print(f"[-] {ip}:{port}     ERROR: {err}")
            return False
        finally:
            sock.close()
    
def scan_udp_port(ip: str, open_ports: list[int], port=53, timeout: float=2, is_root=False, 
            is_verbose=False) -> bool:
    if is_root:
        udp_pkt = IP(dst=ip) / UDP(dport=port)
        ans = sr1(udp_pkt, timeout=timeout, verbose=0)
        if ans is None:
            # possibly open/filtered by firewall
            print(f"[?] {ip}:{port}     OPEN/FILTERED")
            return False
        elif ans.haslayer(ICMP):
            icmp_type = ans[ICMP].type
            icmp_code = ans[ICMP].code
            if icmp_type == 3 and icmp_code == 3:
                if is_verbose:
                    print(f"[-] {ip}:{port}     CLOSED")
                return False
            else:
                # host unreachable
                if is_verbose:
                    print(f"[-] {ip}:{port}     FILTERED")  
                return False
        else:
            # receive response except icmp
            open_ports.append(port)
            print(f"[+] {ip}:{port}     OPEN")  
            return True
    else:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(1)
        try:
            sock.sendto(b'', (ip, port))
            try:
                data, addr = sock.recvfrom(1024)
                open_ports.append(port)
                print(f"[+] {ip}:{port}     OPEN")
                return True
            except socket.timeout:
                print(f"[?] {ip}:{port}     OPEN/FILTERED")
                return False
        except socket.error as err:
            if is_verbose:
                print(f"[-] {ip}:{port}     ERROR: {err}")
            return False
        finally:
            sock.close()        

def udp_multiple_threaded(ip: str, ports: list[int], threads: int = 10, 
        is_root: bool = False, is_verbose: bool = False, open_ports: list[int] = []):
    port_queue = Queue()
    for port in ports:
        port_queue.put(port)

    def worker():
        while not port_queue.empty():
            port = port_queue.get()
            try:
                scan_udp_port(ip, open_ports=open_ports, port=port, 
                        timeout=2, is_root=is_root, is_verbose=is_verbose)
            finally:
                port_queue.task_done()

    thread_list = []
    for _ in range(min(threads, len(ports))):
        t = threading.Thread(target=worker)
        t.start()
        thread_list.append(t)

    for t in thread_list:
        t.join()